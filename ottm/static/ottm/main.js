// noinspection JSUnusedGlobalSymbols

/**
 * Base script for the whole site.
 */
"use strict";

(function () {
  /**
   * Immutable object that maps keys to values.
   */
  class Mapping {
    /** @type {Object<string, *>} */
    #mappings;

    /**
     * Internal data is queried from the global `WIKI_CONFIG` object generated by the server.
     * The object and associated `<script>` tag are deleted once this object is initialized.
     * @param data {Object<string, *>} Initial data.
     */
    constructor(data) {
      this.#mappings = data;
    }

    /**
     * Return the value for the given key.
     * @param key {string} The key.
     * @return {*} The corresponding value or undefined if the key is absent.
     */
    get(key) {
      return this.#mappings[key];
    }

    /**
     * Check whether this object contains the given key.
     * @param key {string} The key to check.
     * @return {boolean} True if the key is present, false otherwise.
     */
    containsKey(key) {
      return this.get(key) !== undefined;
    }

    /**
     * @return {string[]} An array of all keys of this object.
     */
    keys() {
      return Object.keys(this.#mappings);
    }

    /**
     *
     * @return {*[]} An array of all values of this object.
     */
    values() {
      return Object.values(this.#mappings);
    }

    /**
     * @return {[string, *][]} An array of all key-value entries of this object.
     */
    entries() {
      return Object.entries(this.#mappings);
    }

    /**
     * @return {{next: (function(): {value: string, done: boolean})}} An iterator over the key of this object.
     */
    [Symbol.iterator]() {
      const keys = this.keys();
      let i = -1;
      return {
        next: () => ({value: keys[++i], done: !(i in keys)}),
      };
    }
  }

  /**
   * Class representing a UI language.
   */
  class Language {
    /** @type {string} */
    #code;
    /** @type {string} */
    #name;
    /** @type {string} */
    #comma;
    /** @type {string} */
    #and;
    /** @type {string} */
    #writingDirection;
    /** @type {string[]} */
    #dayNames;
    /** @type {string[]} */
    #abbrDayNames;
    /** @type {string[]} */
    #monthNames;
    /** @type {string[]} */
    #abbrMonthNames;
    /** @type {string[]} */
    #ampm;
    /** @type {string} */
    #decimalSep;
    /** @type {string} */
    #thousandsSep;

    constructor(code, name, writingDirection, comma, and, dayNames, abbrDayNames, monthNames, abbrMonthNames, ampm, decimalSep, thousandsSep) {
      if (dayNames.length !== 7) {
        throw new Error("dayNames expected 7 values");
      }
      if (abbrDayNames.length !== 7) {
        throw new Error("abbrDayNames expected 7 values");
      }
      if (monthNames.length !== 12) {
        throw new Error("monthNames expected 12 values");
      }
      if (abbrMonthNames.length !== 12) {
        throw new Error("abbrMonthNames expected 12 values");
      }
      if (ampm.length !== 2) {
        throw new Error("ampm expected 2 values");
      }
      this.#code = code;
      this.#name = name;
      this.#writingDirection = writingDirection;
      this.#comma = comma;
      this.#and = and;
      this.#dayNames = dayNames;
      this.#abbrDayNames = abbrDayNames;
      this.#monthNames = monthNames;
      this.#abbrMonthNames = abbrMonthNames;
      this.#ampm = ampm;
      this.#decimalSep = decimalSep;
      this.#thousandsSep = thousandsSep;
    }

    /** @return {string} This language’s code. */
    get code() {
      return this.#code;
    }

    /** @return {string} This language’s name. */
    get name() {
      return this.#name;
    }

    /** @return {string} This language’s writing direction, either "ltr" or "rtl". */
    get writingDirection() {
      return this.#writingDirection;
    }

    /** @return {string} This language’s comma character. */
    get comma() {
      return this.#comma;
    }

    /** @return {string} This language’s word equivalent to english "and". */
    get and() {
      return this.#and;
    }

    /** @return {string[]} This language’s week day names. */
    get dayNames() {
      return this.#dayNames;
    }

    /** @return {string[]} This language’s abbreviated week day names. */
    get abbrDayNames() {
      return this.#abbrDayNames;
    }

    /** @return {string[]} This language’s month names. */
    get monthNames() {
      return this.#monthNames;
    }

    /** @return {string[]} This language’s abbreviated month names. */
    get abbrMonthNames() {
      return this.#abbrMonthNames;
    }

    /** @return {string[]} This language’s equivalent of AM and PM. */
    get ampm() {
      return this.#ampm;
    }

    /** @return {string} This language’s decimal separator. */
    get decimalSep() {
      return this.#decimalSep;
    }

    /** @return {string} This language’s thousands separator. */
    get thousandsSep() {
      return this.#thousandsSep;
    }

    /**
     * Format the given number.
     * @param n {number} A number.
     * @return {string} The formatted number.
     */
    formatNumber(n) {
      const s = n.toString();
      const decPart = s.includes(".") ? s.split(".")[1] : "";
      // Regex from https://stackoverflow.com/a/2901298/3779986
      const intPart = Math.floor(n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSep);
      return intPart + (decPart ? this.decimalSep + decPart : "");
    }

    /**
     * Turn a list of string into a simple list using commas and 'and'.
     * @param values {*[]} List of values to format.
     * @return {string} Formatted list.
     */
    listToText(values) {
      if (values.length === 0) {
        return '';
      }
      if (values.length === 1) {
        return values[0];
      }
      let list = values.slice(0, values.length - 1).join(this.comma);
      return `${list}${this.and}${values[values.length - 1]}`;
    }
  }

  /**
   * Class that manages all JS interactions.
   */
  window.ottm = {
    /** Site’s configuration values. */
    config: new Mapping(window.OTTM_CONFIG.config),
    /** Current page’s data. */
    page: new Mapping(window.OTTM_CONFIG.page),
    /** Current user’s data. */
    user: new Mapping(window.OTTM_CONFIG.user),
    /** UI translations. */
    _translations: new Mapping(window.OTTM_CONFIG.translations),
    /** @type {Language[]} List of all available UI languages. */
    languages: [],
    // Expose classes
    Mapping: Mapping,
    Language: Language,

    /**
     * Convert a date to the given timezone.
     * @param date {Date} Date to convert.
     * @param timezone {string} Target timezone.
     * @returns {Date} Converted date.
     */
    convertDateTimezone: function (date, timezone) {
      return new Date(date.toLocaleString("en-US", {timeZone: timezone}));
    },

    /**
     * Format a date as "HH:MM".
     * @param date {Date} Date to format.
     * @returns {string} Formatted time.
     */
    formatTime: function (date) {
      // Append 0s if necessary
      const hours = date.getHours().toLocaleString("en-US", {minimumIntegerDigits: 2});
      const minutes = date.getMinutes().toLocaleString("en-US", {minimumIntegerDigits: 2});
      return `${hours}:${minutes}`;
    },

    /**
     * Add the shortcut to the title attribute of any element that has an access key.
     */
    setAccessKeys: function () {
      $("*[accesskey]").each((_, element) => {
        const $element = $(element);
        const accessKey = $element.attr("accesskey");
        if (accessKey) {
          const title = $element.attr("title");
          const shortcut = `[Alt+Shift+${accessKey}]`;
          $element.attr("title", (title ? title + " " : "") + shortcut);
        }
      });
    },

    /**
     * Set referer URL to login-related links.
     */
    setReferer: function () {
      const path = window.location.pathname + window.location.hash;
      const linkSelectors = [
        "#nav-login-link",
        "#nav-logout-link",
      ];
      for (const linkSelector of linkSelectors) {
        const $link = $(linkSelector);
        if ($link.length) {
          this.setReturnTo($link, path);
        }
      }
    },

    /**
     * Add "return_to" argument to the given link’s href attribute.
     * @param $link Link element to modify.
     * @param path {string} Path to pass to "return_to" argument.
     * @param args {Object<string, *>?} Additional arguments to append to URL.
     */
    setReturnTo: function ($link, path, args) {
      const url = new URL($link.prop("href"));
      // TODO use URLSearchParams
      url.search = "return_to=" + encodeURIComponent(path);
      if (args) {
        url.search += "&" + $.map(Object.entries(args),
          e => `${encodeURIComponent(e[0])}=${encodeURIComponent(e[1])}`).join("&");
      }
      $link.attr("href", url.href);
    },

    /**
     * Return the value of a cookie.
     * @param name {string} Cookie’s name.
     * @param defaultValue {*?} A value to return if the cookie is undefined.
     * @returns {*} The cookie’s value.
     */
    getCookie: function (name, defaultValue) {
      return Cookies.get(name) ?? defaultValue;
    },

    /**
     * Set the value of a cookie.
     * @param name {string} Cookie’s name.
     * @param value {*} Cookie’s value.
     * @param options {{expires: number?, path: string, domain: string?}?} Options.
     */
    setCookie: function (name, value, options) {
      Cookies.set(name, value, options);
    },

    /**
     * Delete a cookie.
     * @param name {string} Cookie’s name.
     * @param options {{path: string, domain: string?}?} Options.
     */
    deleteCookie: function (name, options) {
      Cookies.remove(name, options);
    },
  }

  for (const langData of window.OTTM_CONFIG.languages) {
    // noinspection JSUnresolvedVariable
    ottm.languages.push(new Language(
      langData.code,
      langData.name,
      langData.writingDirection,
      langData.comma,
      langData.and,
      langData.dayNames,
      langData.abbrDayNames,
      langData.monthNames,
      langData.abbrMonthNames,
      langData.ampm,
      langData.decimalSep,
      langData.thousandsSep,
    ));
  }
  delete window.OTTM_CONFIG;
  $("#ottm-config-script").remove();
  ottm.setReferer();
  ottm.setAccessKeys();

  function hookSettingsDropdownBehavior() {
    const $button = $("#navbar-logged-out-settings");
    if ($button.length) {
      const $parent = $button.parent();
      const $menu = $parent.find(".dropdown-menu");
      $button.on("click", e => {
        $parent.toggleClass("show");
        $menu.toggleClass("show");
        e.preventDefault();
      });
      $("body").on("click", e => {
        // noinspection JSCheckFunctionSignatures
        if (!$.contains($parent[0], e.target)) {
          $parent.removeClass("show");
          $menu.removeClass("show");
        }
      });
    }
  }

  function hookDarkModeCallback() {
    $("#dark-mode-checkbox").on("click", e => {
      const checked = $(e.target).prop("checked");
      Cookies.set('dark_mode', checked);
      location.reload();
    });
  }

  function hookLanguageSelectorCallback() {
    $("#nav-language-select").on("change", e => {
      const langCode = $(e.target).val();
      Cookies.set('language', langCode);
      location.reload();
    });
  }

  hookSettingsDropdownBehavior();
  hookDarkModeCallback();
  hookLanguageSelectorCallback();
})();
