/**
 * Base script for the whole site.
 */
"use strict";

/**
 * Immutable object that maps keys to values.
 */
class Config {
  /** @type {Object<string, *>} */
  #mappings;

  /**
   * Internal data is queried from the global `WIKI_CONFIG` object generated by the server.
   * The object and associated `<script>` tag are deleted once this object is initialized.
   */
  constructor() {
    this.#mappings = window.OTTM_CONFIG;
    delete window.OTTM_CONFIG;
    $("#ottm-config-script").remove();
  }

  /**
   * Return the value for the given key.
   * @param key {string} The key.
   * @return {*} The corresponding value or undefined if the key is absent.
   */
  get(key) {
    return this.#mappings[key];
  }

  /**
   * Check whether this object contains the given key.
   * @param key {string} The key to check.
   * @return {boolean} True if the key is present, false otherwise.
   */
  containsKey(key) {
    return this.get(key) !== undefined;
  }

  /**
   * @return {string[]} An array of all keys of this object.
   */
  keys() {
    return Object.keys(this.#mappings);
  }

  /**
   *
   * @return {*[]} An array of all values of this object.
   */
  values() {
    return Object.values(this.#mappings);
  }

  /**
   * @return {[string, *][]} An array of all key-value entries of this object.
   */
  entries() {
    return Object.entries(this.#mappings);
  }

  /**
   * @return {{next: (function(): {value: string, done: boolean})}} An iterator over the key of this object.
   */
  [Symbol.iterator]() {
    const keys = this.keys();
    let i = -1;
    return {
      next: () => ({value: keys[++i], done: !(i in keys)}),
    };
  }
}

/**
 * Class that manages all JS interactions.
 */
class OTTM {
  #config;

  constructor() {
    this.#config = new Config();
    this.#hookSettingsDropdownBehavior();
    this.#hookDarkModeCallback();
    this.#hookLanguageSelectorCallback();
    this.setReferer();
    this.setAccessKeys();
  }

  /**
   * @returns {Config} The config object.
   */
  get config() {
    return this.#config;
  }

  /**
   * Convert a date to the given timezone.
   * @param date {Date} Date to convert.
   * @param timezone {string} Target timezone.
   * @returns {Date} Converted date.
   */
  convertDateTimezone(date, timezone) {
    return new Date(date.toLocaleString("en-US", {timeZone: timezone}));
  }

  /**
   * Format a date as "HH:MM".
   * @param date {Date} Date to format.
   * @returns {string} Formatted time.
   */
  formatTime(date) {
    // Append 0s if necessary
    const hours = date.getHours().toLocaleString("en-US", {minimumIntegerDigits: 2});
    const minutes = date.getMinutes().toLocaleString("en-US", {minimumIntegerDigits: 2});
    return `${hours}:${minutes}`;
  }

  #hookSettingsDropdownBehavior() {
    const $button = $("#navbar-logged-out-settings");
    if ($button.length) {
      const $parent = $button.parent();
      const $menu = $parent.find(".dropdown-menu");
      $button.on("click", e => {
        $parent.toggleClass("show");
        $menu.toggleClass("show");
        e.preventDefault();
      });
      $("body").on("click", e => {
        // noinspection JSCheckFunctionSignatures
        if (!$.contains($parent[0], e.target)) {
          $parent.removeClass("show");
          $menu.removeClass("show");
        }
      });
    }
  }

  #hookDarkModeCallback() {
    $("#dark-mode-checkbox").on("click", e => {
      const checked = $(e.target).prop("checked");
      Cookies.set('dark_mode', checked);
      location.reload();
    });
  }

  #hookLanguageSelectorCallback() {
    $("#nav-language-select").on("change", e => {
      const langCode = $(e.target).val();
      Cookies.set('language', langCode);
      location.reload();
    });
  }

  /**
   * Add the shortcut to the title attribute of any element that has an access key.
   */
  setAccessKeys() {
    $("*[accesskey]").each((_, element) => {
      const $element = $(element);
      const accessKey = $element.attr("accesskey");
      if (accessKey) {
        const title = $element.attr("title");
        const shortcut = `[Alt+Shift+${accessKey}]`;
        $element.attr("title", (title ? title + " " : "") + shortcut);
      }
    });
  }

  /**
   * Set referer URL to login-related links.
   */
  setReferer() {
    const path = window.location.pathname + window.location.hash;
    const linkSelectors = [
      "#nav-login-link",
      "#nav-logout-link",
    ];
    for (const linkSelector of linkSelectors) {
      const $link = $(linkSelector);
      if ($link.length) {
        OTTM.setReturnTo($link, path);
      }
    }
  }

  /**
   * Add "return_to" argument to the given linkâ€™s href attribute.
   * @param $link Link element to modify.
   * @param path {string} Path to pass to "return_to" argument.
   * @param args {Object<string, *>?} Additional arguments to append to URL.
   */
  static setReturnTo($link, path, args) {
    const url = new URL($link.prop("href"));
    // TODO use URLSearchParams
    url.search = "return_to=" + encodeURIComponent(path);
    if (args) {
      url.search += "&" + $.map(Object.entries(args), e => `${e[0]}=${e[1]}`).join("&");
    }
    $link.attr("href", url.href);
  }
}

// Expose instance to global scope
window.ottm = new OTTM();
