{"version":3,"mappings":"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","names":["code","__publicField","__privateAdd","_code","__privateSet","__privateGet","_WikiGadgetManager_instances","_gadgets","_gadgetsQueueSize","_finishedRegistration","_locked","__privateWrapper","e","__privateMethod","lock_fn","name","_title","_transformer","_includeHidden","_prefix","_content","darkMode","_","hljs","action","staticPath","pageName","specialPageBaseUrl","userPage","pageTitle","urlBase","title","url","css","$style","gadget_names","gadgetName"],"ignoreList":[],"sources":["../../../../js-sources/src/wiki/index.ts"],"sourcesContent":["import $ from \"jquery\";\nimport hljs from \"highlight.js\";\n\nimport \"./style.css\";\n\ninterface GadgetCode {\n  name: string;\n  version?: string;\n  init: () => void;\n  run: () => void;\n}\n\n/**\n * Base class for wiki gadgets.\n */\nexport class WikiGadget {\n  /** This gadget’s name. */\n  readonly name: string;\n  /** This gadget’s version. */\n  readonly version: string | undefined;\n  /** The actual gadget object. */\n  readonly #code: GadgetCode;\n\n  /**\n   * Create a new gadget.\n   * @param code The actual gadget object.\n   * @throws Error If the passed object is malformed or the object’s init() function threw an error.\n   */\n  constructor(code: GadgetCode) {\n    if (!(\"name\" in code)) throw new Error('Missing \"name\" property in gadget');\n    this.name = code.name;\n    this.version = code.version;\n    this.#code = code;\n    this.#code.init();\n  }\n\n  /**\n   * Called when this gadget has been initialized and the manager is ready.\n   * @returns True if the gadget was run successfully, false if any error occurred.\n   */\n  run(): boolean {\n    try {\n      this.#code.run();\n    } catch (e) {\n      console.error(e);\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * This class manages wiki gadgets.\n */\nexport class WikiGadgetManager {\n  /** Mapping of all successfully loaded gadgets. */\n  readonly #gadgets = new Map<string, WikiGadget>();\n  /** Number of gadgets still loading. */\n  #gadgetsQueueSize = 0;\n  /** Whether all gadgets have been registered. */\n  #finishedRegistration = false;\n  /** Whether this manager is locked. Once locked, no more gadgets can be registered. */\n  #locked = false;\n\n  /**\n   * Register a gadget to be loaded asynchronously.\n   * @param gadgetName The gadget’s name.\n   * @throws Error If this manager is locked.\n   */\n  async registerGadget(gadgetName: string): Promise<void> {\n    if (this.#locked)\n      throw new Error(\"Cannot register gadgets when manager is locked\");\n\n    console.log(`Registering gadget \"${gadgetName}\"…`);\n    this.#gadgetsQueueSize++;\n    await $.get(window.ottm.config.get(\"wApiPath\") as string, {\n      action: \"query\",\n      query: \"gadget\",\n      title: gadgetName,\n    })\n      .then((data: string) => {\n        try {\n          const gadget = new WikiGadget(eval(data) as GadgetCode);\n          this.#gadgets.set(gadget.name, gadget);\n        } catch (e) {\n          console.error(`Error while loading gadget \"${gadgetName}\":\\n${e}`);\n        }\n        this.#gadgetsQueueSize--;\n        if (this.#gadgetsQueueSize === 0 && this.#finishedRegistration)\n          this.#lock();\n      })\n      .catch(() => {\n        console.error(`Could not load gadget \"${gadgetName}\"`);\n      });\n  }\n\n  /**\n   * Indicate that gadgets registration is finished.\n   * If the loading queue is already empty, lock this manager immediately.\n   */\n  finishRegistration(): void {\n    this.#finishedRegistration = true;\n    if (this.#gadgetsQueueSize === 0) this.#lock();\n  }\n\n  /**\n   * Lock this manager after all gadgets have been loaded.\n   */\n  #lock(): void {\n    this.#locked = true;\n  }\n\n  /**\n   * Return the gadget with the given name.\n   * @param name Gadget’s name.\n   * @return The gadget or undefined if none matched.\n   */\n  getGadget(name: string): WikiGadget | undefined {\n    return this.#gadgets.get(name);\n  }\n\n  /**\n   * Check whether the given gadget is registered.\n   * @param name Gadget name to check.\n   * @return True if a gadget with the specified name is registered, false otherwise.\n   */\n  isGadgetRegistered(name: string): boolean {\n    return this.#gadgets.get(name) !== undefined;\n  }\n}\n\n/**\n * @param content Current page content.\n * @return The new content or an object with additional parameters.\n */\nexport type PageContentTransformer = (content: string) =>\n  | string\n  | {\n      content: string;\n      summary?: string;\n      minor?: boolean;\n      hidden?: boolean;\n      follow?: boolean;\n    };\n\n/**\n * An object returned by the {@link WikiAPI.editPage} method.\n */\nexport interface PageEditResponse {\n  success: boolean;\n  errorMessage?: string;\n}\n\n/**\n * This class provides methods to interact with the wiki’s HTTP API.\n */\nexport class WikiAPI {\n  /**\n   * Edit a wiki page.\n   * @param _title Page’s title.\n   * @param _transformer Function to apply to the page’s current content.\n   * @return A promise returning the server’s response as a {@link PageEditResponse} object.\n   */\n  editPage(\n    _title: string,\n    _transformer: PageContentTransformer,\n  ): Promise<PageEditResponse> {\n    // TODO\n    return Promise.reject(new Error(\"Not implemented\"));\n  }\n\n  /**\n   * Get the content of the given page.\n   * @param _title Page’s title.\n   * @return A promise returning the page’s wikicode.\n   */\n  getPage(_title: string): Promise<string> {\n    // TODO\n    return Promise.reject(new Error(\"Not implemented\"));\n  }\n\n  /**\n   * Get the list of categories of the given page.\n   * @param _title Page’s title.\n   * @param _includeHidden Whether to include hidden categories.\n   * @return A promise returning the titles of the page’s categories.\n   */\n  getPageCategories(_title: string, _includeHidden = false): Promise<string[]> {\n    // TODO\n    return Promise.reject(new Error(\"Not implemented\"));\n  }\n\n  /**\n   * Get the list of categories that match the given prefix.\n   * @param _prefix Categories’ prefix.\n   * @return A promise returning the category titles.\n   */\n  getCategories(_prefix: string): Promise<string[]> {\n    // TODO\n    return Promise.reject(new Error(\"Not implemented\"));\n  }\n\n  /**\n   * Parse the given wikicode.\n   * @param _content The content to parse.\n   * @return A promise returning the generated HTML code.\n   */\n  parseWikicode(_content: string): Promise<string> {\n    // TODO\n    return Promise.reject(new Error(\"Not implemented\"));\n  }\n\n  /**\n   * Make the current user follow the given page.\n   * @param _title Page’s title.\n   * @return A promise.\n   */\n  followPage(_title: string): Promise<void> {\n    // TODO\n    return Promise.reject(new Error(\"Not implemented\"));\n  }\n\n  /**\n   * Make the current user unfollow the given page.\n   * @param _title Page’s title.\n   * @return A promise.\n   */\n  unfollowPage(_title: string): Promise<void> {\n    // TODO\n    return Promise.reject(new Error(\"Not implemented\"));\n  }\n}\n\ndeclare global {\n  interface Window {\n    wiki: {\n      gadgetsManager: WikiGadgetManager;\n      api: WikiAPI;\n      editor: unknown;\n    };\n  }\n}\n\nexport default async function initWiki(): Promise<void> {\n  window.wiki = {\n    gadgetsManager: new WikiGadgetManager(),\n    api: new WikiAPI(),\n    editor: null,\n  };\n\n  const darkMode = window.ottm.page.get(\"darkMode\");\n\n  if (darkMode) await import(\"highlight.js/styles/monokai.css\");\n  else await import(\"highlight.js/styles/vs.css\");\n  // Apply highlight.js to all tagged elements\n  $(\".hljs\").each((_, e) => {\n    hljs.highlightElement(e);\n  });\n\n  const action = window.ottm.page.get(\"wAction\");\n  if (action === \"edit\" || action === \"submit\") {\n    const editorModule = await import(\"./_editor\");\n    editorModule.default();\n  } else if (action === \"talk\") {\n    // TODO load discussions module\n  }\n\n  const staticPath = window.ottm.config.get(\"staticPath\");\n  const pageName = encodeURIComponent(\n    window.ottm.page.get(\"wFullTitleURL\") as string,\n  );\n  const specialPageBaseUrl = `${staticPath}ottm/wiki/special_pages/${pageName}/`;\n  const userPage = `User:${window.ottm.user.get(\"username\")}`;\n\n  if ($(\"#special-page-css\").length)\n    await loadStyles(`${specialPageBaseUrl}style.min.css`);\n  if ($(\"#special-page-js\").length)\n    await loadScript(`${specialPageBaseUrl}script.min.js`);\n  await loadPageStatics(\"Interface:Common\");\n  await loadPageStatics(`${userPage}/Common`);\n  if (darkMode) await loadPageStatics(`${userPage}/Common-dark`);\n  else await loadPageStatics(`${userPage}/Common-light`);\n  await loadGadgets();\n}\n\nasync function loadPageStatics(pageTitle: string): Promise<void> {\n  const urlBase = `${window.ottm.config.get(\"wApiPath\")}?action=query&query=static&title=`;\n  const title = encodeURIComponent(pageTitle);\n  await loadStyles(`${urlBase}${title}.css`);\n  await loadScript(`${urlBase}${title}.js`);\n}\n\nasync function loadStyles(url: string): Promise<void> {\n  await $.get(url)\n    .then((css: string) => {\n      const $style = $(\"<style>\");\n      $style.text(css);\n      $(\"head\").append($style);\n    })\n    .catch(() => {\n      // Ignore\n    });\n}\n\nasync function loadScript(url: string): Promise<void> {\n  await $.getScript(url).catch(() => {\n    // Ignore\n  });\n}\n\nasync function loadGadgets(): Promise<void> {\n  await $.get(window.ottm.config.get(\"wApiPath\") as string, {\n    action: \"query\",\n    query: \"gadgets\",\n    username: window.ottm.user.get(\"username\"),\n  })\n    .then(async ({ gadget_names }: { gadget_names: string[] }) => {\n      for (const gadgetName of gadget_names)\n        await window.wiki.gadgetsManager.registerGadget(gadgetName);\n      window.wiki.gadgetsManager.finishRegistration();\n    })\n    .catch(() => {\n      console.error(\"Could not load gadgets\");\n    });\n}\n"],"file":"dep-index2.js"}