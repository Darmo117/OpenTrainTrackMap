{"version":3,"mappings":"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","names":["OttmMap","Map","__privateAdd","_textFieldHasFocus","__privateGet","$textInputs","$","__privateSet","createControlContainer","className","container","createControlButton","options","button","onClick","createMdiIcon","name","lineIcon","parseSVG","string","ICON","CompassControl","_CompassControl_instances","_map","_options","_container","_button","_icon","__privateMethod","onControlButtonClick_fn","map","onRotate_fn","_a","angle","capitalize","s","_GeocoderControl","_GeocoderControl_instances","_marker","_textField","_eraseButton","_searchButton","_resultsPanel","e","onInputSubmit_fn","hideResultsPanel_fn","onErase_fn","inputContainer","_BASE_URL","query","url","data","onResult_fn","onFailure_fn","results","list","noTranslationsMark","result","type","category","prefixName","level","item","emNode","link","boundingBox","bb","onResultClick_fn","showResultsPanel_fn","lat","lng","marker","Marker","GeocoderControl","earthRadius","factors","feature","geom","properties","feat","point","coordinates","isNumber","polygon","ring","j","lineString","featureCollection","features","fc","multiLineString","multiPolygon","radiansToLength","radians","units","factor","lengthToRadians","distance","bearingToAzimuth","bearing","radiansToDegrees","degreesToRadians","degrees","num","isObject","input","coordEach","geojson","callback","excludeWrapCoord","k","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","geomEach","i","g","featureProperties","featureBBox","featureId","geomReduce","initialValue","previousValue","currentGeometry","flattenEach","bbox","id","coordinate","segmentEach","feature2","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","__generator","thisArg","body","_","t","f","y","verb","n","v","step","op","Node","key","DEFAULT_COMPARE","a","b","splay","comparator","N","r","cmp","insert","node","split","left","right","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","x","current","compare","visitor","ctx","Q","done","low","high","fn","keys","values","index","d","successor","predecessor","toList","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","newKey","newData","start","end","middle","head","p","l1","l2","p1","p2","pivot","tmp","epsilon","splitter","resulterrbound","sum","elen","flen","h","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","isInBbox","getBboxOverlap","b1","b2","lowerX","upperX","lowerY","upperY","EPSILON_SQ","ab","PtRounder","CoordRounder","SplayTree","coord","prevNode","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","res","length","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection$1","pt1","v1","pt2","v2","kross","ve","d1","d2","x1","x2","y1","y2","SweepEvent","ptCmp","Segment","aPt","bPt","isLeft","other","otherEvents","iMax","evt","numEvents","evt1","evt2","events","baseEvent","cache","fillCache","linkedEvent","nextEvent","asine","acosine","bsine","bcosine","segmentId","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","bCmpARight","bCmpALeft","aCmpBRight","leftSE","rightSE","rings","windings","leftPt","rightPt","winding","cmpPts","newRightSE","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","tmpEvt","consumer","consumee","seg","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","mp","mpsBefore","operation","noBefores","noAfters","least","most","diff","isJustSubject","mps","RingIn","geomRing","isExterior","firstPoint","prevPoint","sweepEvents","segment","PolyIn","geomPoly","multiPoly","ringSweepEvents","jMax","MultiPolyIn","isSubject","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","prevPt","points","nextPt","iStart","iEnd","orderedPoints","enclosing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","exteriorRing","ringGeom","MultiPolyOut","polyGeom","polys","enclosingRing","SweepLine","queue","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","nextMySplitter","nextInter","mySplitter","inter","POLYGON_CLIPPING_MAX_QUEUE_SIZE","define_process_env_default","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","moreGeoms","multipolys","subject","mpA","sweepLine","prevQueueSize","union","_len","_key","intersection","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4","intersect","geoms","polygonClipping","categoryOrder","TilesSourcesControl","_TilesSourcesControl_instances","_title","_bestIconTitle","_sourcesByCategory","_visibleSources","_editMode","_$inputsContainer","source","setup_fn","entries","e1","e2","collator","sources","s2","$listContainer","categoryTitle","$inputsList","sourceId","getSourceInputId_fn","$input","changeTilesSource_fn","findTilesSourceById_fn","$item","$label","icon","resourceType","transformRequest_fn","filterSources_fn","tilesSource","layerId","zoom","bounds","count","sourceBounds","hide","intersects_fn","$listItem","$categoryDiv","viewportBounds","LngLatBounds","sourceBoundsPolygon","viewportBoundsPolygon","shapeToPolygon","shape","shape_","match","parts","escapeCssSelector","OpenExternalMapControl","_OpenExternalMapControl_instances","_urlPattern","_zoomTransformer","onButtonClick_fn","PLUS_ICON","MINUS_ICON","ZoomControl","_buttonIn","_buttonOut","disable","ImageryDateControl","_ImageryDateControl_instances","_$container","_$innerContainer","onTilesSourceChanged_fn","date","loadTilesSources","tilesSources","sourceDef","tileSourcesDefs","getCategory","jsonCategory","sourceSpec","attrib","initMap","editMode","ScaleControl","defaultValue","zoomControl","staticPath","GeolocateControl","centerViewFromUrl","updateUrlHash","element","onTilesSourceChanged","updatingView","updatingHash","getPositionFromURL","minZoom","maxZoom","centerPos","hash","mapNavLinks","linkId","$navLink","found"],"ignoreList":[5,6,7,8,9,10,11],"sources":["../../../../js-sources/src/map/map.ts","../../../../js-sources/src/map/controls/helpers.ts","../../../../js-sources/src/map/controls/compass/index.ts","../../../../js-sources/src/utils.ts","../../../../js-sources/src/map/controls/geocoder/index.ts","../../../../js-sources/node_modules/@turf/helpers/dist/esm/index.js","../../../../js-sources/node_modules/@turf/meta/dist/esm/index.js","../../../../js-sources/node_modules/splaytree/dist/splay.esm.js","../../../../js-sources/node_modules/polygon-clipping/node_modules/robust-predicates/esm/util.js","../../../../js-sources/node_modules/polygon-clipping/node_modules/robust-predicates/esm/orient2d.js","../../../../js-sources/node_modules/polygon-clipping/dist/polygon-clipping.esm.js","../../../../js-sources/node_modules/@turf/intersect/dist/esm/index.js","../../../../js-sources/src/map/controls/tiles-sources/index.ts","../../../../js-sources/src/map/controls/open-external-map/index.ts","../../../../js-sources/src/map/controls/zoom/index.ts","../../../../js-sources/src/map/controls/imagery-date/index.ts","../../../../js-sources/src/map/tiles-sources.ts","../../../../js-sources/src/map/index.ts"],"sourcesContent":["import { Map } from \"maplibre-gl\";\nimport $ from \"jquery\";\n\n/**\n * Custom subclass of {@link Map}.\n *\n * It adds a field that indicates whether a text field has the focus at any time.\n * If true, all map keyboard events should be disabled to prevent unwanted actions when the user is typing text.\n */\nexport default class OttmMap extends Map {\n  #textFieldHasFocus = false;\n\n  /**\n   * Indicate whether a text field currently has the focus.\n   */\n  get textFieldHasFocus(): boolean {\n    return this.#textFieldHasFocus;\n  }\n\n  /**\n   * Hook events that listen to focus updates on text fields,\n   * in order to update the {@link textFieldHasFocus} property.\n   */\n  hookTextFieldsFocusEvents(): void {\n    const $textInputs = $(\"input[type='text'], textarea\");\n    $textInputs.on(\"focusin\", () => {\n      this.#textFieldHasFocus = true;\n    });\n    $textInputs.on(\"focusout\", () => {\n      this.#textFieldHasFocus = false;\n    });\n  }\n}\n","import MDIcon from \"./mdi\";\n\n/**\n * Options for the {@link createControlButton} function.\n */\nexport interface ButtonOptions {\n  /**\n   * Optional. The buttons title.\n   */\n  title?: string;\n  /**\n   * Optional. The buttons icon element.\n   */\n  icon?: Node;\n  /**\n   * Optional. The buttons text content.\n   */\n  textContent?: string;\n  /**\n   * Optional. Whether to disable the button.\n   */\n  disabled?: boolean;\n  /**\n   * Optional. Whether to hide the button.\n   */\n  hidden?: boolean;\n  /**\n   * Optional. Name of a CSS class to add to the button.\n   */\n  className?: string;\n  /**\n   * Optional. A callback to invoke whenever the button is clicked.\n   */\n  onClick?: (button: HTMLButtonElement) => void;\n  /**\n   * Optional. The list of key names for the buttons shortcut.\n   */\n  shortcut?: string[];\n}\n\n/**\n * Create MapLibre control container.\n * @param className Additional class name for the container.\n * @returns A HTMLDivElement.\n */\nexport function createControlContainer(className: string): HTMLDivElement {\n  const container = document.createElement(\"div\");\n  container.classList.add(\n    \"maplibregl-ctrl\",\n    \"maplibregl-ctrl-group\",\n    className,\n  );\n  return container;\n}\n\n/**\n * Create a MapLibre control button.\n * @param options Buttons options.\n * @returns A HTMLButtonElement.\n */\nexport function createControlButton(\n  options: ButtonOptions = {},\n): HTMLButtonElement {\n  const button = document.createElement(\"button\");\n  if (options.title) button.title = options.title;\n  if (options.shortcut)\n    button.title +=\n      \" [\" + window.ottm.formatShortcut(...options.shortcut) + \"]\";\n  if (options.icon) button.appendChild(options.icon);\n  if (options.textContent) button.textContent = options.textContent;\n  if (options.disabled) button.disabled = true;\n  if (options.hidden) button.hidden = true;\n  if (options.className) button.classList.add(options.className);\n  if (options.onClick) {\n    const onClick = options.onClick; // Avoids options.onClick being modified by the caller\n    button.addEventListener(\"click\", () => {\n      onClick(button);\n    });\n  }\n  return button;\n}\n\n/**\n * Options that can be passed to {@link createMdiIcon}.\n */\nexport interface MdiOptions {\n  size?: 18 | 24 | 36 | 48;\n  rotate?: 45 | 90 | 135 | 180 | 225 | 270 | 315;\n  flip?: \"h\" | \"v\";\n  spin?: boolean;\n  color?: \"light\" | \"dark\";\n  inactive?: boolean;\n}\n\n/**\n * Create a span element displaying a MDI icon.\n * @param name Name of the icon without the \"mdi-\" prefix.\n * @param options Options to apply to the icon. Size defaults to 18px.\n */\nexport function createMdiIcon(\n  name: MDIcon,\n  options: MdiOptions = {},\n): HTMLElement {\n  const lineIcon = document.createElement(\"span\");\n  lineIcon.className = `mdi mdi-${name} mdi-${options.size ?? 18}px`;\n  if (options.rotate) lineIcon.classList.add(`mdi-rotate-${options.rotate}`);\n  if (options.flip) lineIcon.classList.add(`mdi-flip-${options.flip}`);\n  if (options.spin) lineIcon.classList.add(`mdi-spin`);\n  if (options.color) lineIcon.classList.add(`mdi-${options.color}`);\n  if (options.inactive) lineIcon.classList.add(`mdi-inactive`);\n  return lineIcon;\n}\n\n/**\n * Create SVG element from an XML string.\n * @param string SVG data.\n * @returns The SVG element.\n */\nexport function parseSVG(string: string): SVGElement {\n  return new DOMParser().parseFromString(string, \"image/svg+xml\")\n    .firstChild as SVGElement;\n}\n","import { IControl, Map } from \"maplibre-gl\";\n\nimport {\n  createControlButton,\n  createControlContainer,\n  parseSVG,\n} from \"../helpers\";\n\nconst ICON = parseSVG(`\n<svg viewBox=\"0 0 24 24\" width=\"22\" height=\"22\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g fill=\"none\" fill-rule=\"evenodd\">\n    <path d=\"M0 0h24v24H0z\"/>\n    <path fill=\"#f44336\" d=\"M12 3l4 8H8z\"/>\n    <path fill=\"#9E9E9E\" d=\"M12 21l-4-8h8z\"/>\n  </g>\n</svg>\n`);\n\n/**\n * Options for the {@link CompassControl} class.\n */\nexport interface CompassControlOptions {\n  /**\n   * The controls title.\n   */\n  title?: string;\n  /**\n   * If true, the bearing/pitch reset will be instantaneous and the controll will always be shown.\n   */\n  instant?: boolean;\n}\n\n/**\n * A control that indicates the current bearing when the map is rotated.\n * Clicking this control will reset both the bearing and pitch to 0.\n */\nexport default class CompassControl implements IControl {\n  #map: Map | undefined;\n  readonly #options: CompassControlOptions;\n  readonly #container: HTMLDivElement;\n  readonly #button: HTMLButtonElement;\n  readonly #icon: SVGElement;\n\n  constructor(options: CompassControlOptions = {}) {\n    this.#options = { ...options };\n    this.#container = createControlContainer(\"maplibregl-ctrl-compass\");\n    this.#icon = ICON;\n    this.#button = createControlButton({\n      title: this.#options.title ?? \"Compass\",\n      icon: ICON,\n      onClick: () => {\n        this.#onControlButtonClick();\n      },\n    });\n  }\n\n  #onControlButtonClick(): void {\n    this.#map?.easeTo({ bearing: 0, pitch: 0 });\n  }\n\n  #onRotate(): void {\n    if (!this.#map) return;\n    const angle = -this.#map.getBearing();\n    if (!this.#options.instant) this.#container.hidden = angle === 0;\n    this.#icon.style.transform = `rotate(${angle}deg)`;\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this.#map = map;\n    if (!this.#options.instant) this.#container.hidden = true;\n    this.#container.appendChild(this.#button);\n    this.#onRotate();\n    map.on(\"rotate\", () => {\n      this.#onRotate();\n    });\n    return this.#container;\n  }\n\n  onRemove(): void {\n    // Nothing to do\n  }\n}\n","/**\n * Put the first letter to upper case and all others to lower case.\n * @param s String to capitalize.\n * @returns The capitalized string.\n */\nexport function capitalize(s: string): string {\n  return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();\n}\n","import { IControl, LngLatBoundsLike, Map, Marker } from \"maplibre-gl\";\nimport $ from \"jquery\";\n\nimport { capitalize } from \"../../../utils\";\nimport {\n  createControlButton,\n  createControlContainer,\n  createMdiIcon,\n} from \"../helpers\";\nimport \"./_index.css\";\n\n/**\n * Options for the {@link GeocoderControl} class.\n */\nexport interface GeocoderControlOptions {\n  /**\n   * The code of the language to use for translating the search results.\n   */\n  language: string;\n  /**\n   * A function that translates the given key.\n   * The default value may be a string or a function that provides a string.\n   */\n  translator: (key: string, defaultValue?: string | (() => string)) => string;\n  /**\n   * Optional. Title of the search button.\n   */\n  searchButtonTitle?: string;\n  /**\n   * Optional. Title of the button to erase queries.\n   */\n  eraseButtonTitle?: string;\n  /**\n   * Optional. Placeholder for the search field.\n   */\n  placeholderText?: string;\n  /**\n   * Optional. Message to show when there are no search results.\n   */\n  noResultsMessage?: string;\n  /**\n   * Optional. Message to show when an error occurs.\n   */\n  errorMessage?: string;\n}\n\n/**\n * Structure of objects returned by Nominatim.\n */\ninterface SearchResult {\n  addresstype: string;\n  boundingbox: [number, number, number, number];\n  category: string;\n  display_name: string;\n  importance: number;\n  lat: number;\n  licence: string;\n  lon: number;\n  name: string;\n  osm_id: number;\n  osm_type: string;\n  place_id: number;\n  place_rank: number;\n  type: string;\n}\n\n/**\n * A control with a search bar that allows searching for a location.\n *\n * @see https://wiki.openstreetmap.org/wiki/Nominatim/FAQ#Where_are_the_translations_of_features%3f\n * @see https://github.com/openstreetmap/openstreetmap-website/tree/master/config/locales\n */\nexport default class GeocoderControl implements IControl {\n  static readonly #BASE_URL: string =\n    \"https://nominatim.openstreetmap.org/search?q={query}&format=jsonv2&accept-language={lang}\";\n\n  #map: Map | undefined;\n  #marker: Marker | undefined;\n  readonly #options: GeocoderControlOptions;\n  readonly #container: HTMLDivElement;\n  readonly #textField: HTMLInputElement;\n  readonly #eraseButton: HTMLButtonElement;\n  readonly #searchButton: HTMLButtonElement;\n  readonly #resultsPanel: HTMLDivElement;\n\n  constructor(options: GeocoderControlOptions) {\n    this.#options = { ...options };\n\n    this.#container = createControlContainer(\"maplibregl-ctrl-geocoder\");\n\n    this.#textField = document.createElement(\"input\");\n    this.#textField.type = \"text\";\n    this.#textField.placeholder = this.#options.placeholderText ?? \"Search\";\n    this.#textField.accessKey = \"f\";\n    // Submit on enter key pressed\n    this.#textField.onkeyup = (e) => {\n      if (e.key === \"Enter\") this.#onInputSubmit();\n    };\n    // Hide results when the text changes\n    this.#textField.oninput = () => {\n      this.#hideResultsPanel();\n    };\n\n    this.#eraseButton = createControlButton({\n      title: this.#options.eraseButtonTitle ?? \"Erase\",\n      icon: createMdiIcon(\"close\"),\n      onClick: () => {\n        this.#onErase();\n      },\n    });\n\n    this.#searchButton = createControlButton({\n      title: this.#options.searchButtonTitle ?? \"Go\",\n      icon: createMdiIcon(\"magnify\"),\n      onClick: () => {\n        this.#onInputSubmit();\n      },\n    });\n\n    this.#resultsPanel = document.createElement(\"div\");\n    this.#resultsPanel.className = \"maplibregl-ctrl-geocoder-results-panel\";\n    this.#resultsPanel.style.display = \"none\";\n  }\n\n  #onErase(): void {\n    this.#hideResultsPanel();\n    this.#textField.value = \"\";\n    this.#textField.focus();\n  }\n\n  #onInputSubmit(): void {\n    const query = this.#textField.value.trim();\n    if (query) {\n      const url = GeocoderControl.#BASE_URL\n        .replace(\"{query}\", encodeURIComponent(query))\n        .replace(\"{lang}\", encodeURIComponent(this.#options.language));\n      $.get(url)\n        .done((data: SearchResult[]) => {\n          this.#onResult(data);\n        })\n        .fail(() => {\n          this.#onFailure();\n        });\n    }\n  }\n\n  /**\n   * Called when a geocoding request succeeded.\n   * @param results The list of results.\n   */\n  #onResult(results: SearchResult[]): void {\n    this.#resultsPanel.replaceChildren(); // Clear\n    if (results.length === 0) {\n      this.#resultsPanel.textContent =\n        this.#options.noResultsMessage ?? \"No results.\";\n    } else {\n      const list = document.createElement(\"ul\");\n      const noTranslationsMark = \"```\";\n      for (const result of results) {\n        const type = result.type;\n        const category = result.category;\n        // Prefix name translation algorithm from\n        // https://github.com/openstreetmap/openstreetmap-website/blob/master/app/controllers/geocoder_controller.rb#L109\n        // Search for a translation for the category and type\n        let prefixName = this.#options.translator(\n          `osm_feature_type.prefix.${category}.${type}`,\n          // Fallback by formatting the untranslated value and mark it as such\n          () => noTranslationsMark + capitalize(type.replace(\"_\", \" \")),\n        );\n        if (category === \"boundary\" && type === \"administrative\") {\n          // Check if a more precise translation exists for the specific address type\n          prefixName = this.#options.translator(\n            `osm_feature_type.prefix.place.${result.addresstype}`,\n            // Fallback on a generic administrative name\n            () => {\n              const level = Math.floor((result.place_rank + 1) / 2);\n              return this.#options.translator(\n                `osm_feature_type.admin_levels.level${level}`,\n                // Fallback on the initial translation\n                prefixName,\n              );\n            },\n          );\n        }\n\n        const item = document.createElement(\"li\");\n        if (prefixName.includes(noTranslationsMark)) {\n          // Italicize if no translation\n          const emNode = document.createElement(\"em\");\n          emNode.appendChild(\n            document.createTextNode(\n              prefixName.slice(noTranslationsMark.length),\n            ),\n          );\n          item.appendChild(emNode);\n        } else {\n          item.appendChild(document.createTextNode(prefixName));\n        }\n        item.appendChild(document.createTextNode(\"  \"));\n        const link = document.createElement(\"a\");\n        link.textContent = result.display_name;\n        link.href = \"#\";\n        const boundingBox = result.boundingbox;\n        const bb: LngLatBoundsLike = [\n          {\n            lat: boundingBox[0],\n            lng: boundingBox[2],\n          },\n          {\n            lat: boundingBox[1],\n            lng: boundingBox[3],\n          },\n        ];\n        link.onclick = () => {\n          this.#onResultClick(result.lat, result.lon, bb);\n        };\n        item.appendChild(link);\n        list.appendChild(item);\n      }\n      this.#resultsPanel.appendChild(list);\n    }\n    this.#showResultsPanel();\n  }\n\n  /**\n   * Called when a geocoding request failed.\n   */\n  #onFailure(): void {\n    this.#resultsPanel.replaceChildren(); // Clear\n    this.#resultsPanel.textContent =\n      this.#options.errorMessage ?? \"An error occured.\";\n    this.#showResultsPanel();\n  }\n\n  /**\n   * Called when a search result is clicked.\n   * @param lat Results latitude.\n   * @param lng Results longitude.\n   * @param boundingBox Results bounding box.\n   */\n  #onResultClick(\n    lat: number,\n    lng: number,\n    boundingBox: LngLatBoundsLike,\n  ): void {\n    const map = this.#map;\n    if (!map) return;\n    this.#marker?.remove();\n    map.fitBounds(boundingBox);\n    const marker = new Marker({});\n    marker.setLngLat({ lat: lat, lng: lng });\n    marker.addTo(map);\n    this.#marker = marker;\n  }\n\n  #showResultsPanel(): void {\n    this.#resultsPanel.style.display = \"block\";\n  }\n\n  #hideResultsPanel(): void {\n    this.#marker?.remove();\n    this.#resultsPanel.style.display = \"none\";\n    this.#resultsPanel.replaceChildren(); // Clear\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this.#map = map;\n    const inputContainer = document.createElement(\"div\");\n    inputContainer.className = \"maplibregl-ctrl-geocoder-search-bar\";\n    inputContainer.appendChild(this.#searchButton);\n    inputContainer.appendChild(this.#textField);\n    inputContainer.appendChild(this.#eraseButton);\n    this.#container.appendChild(inputContainer);\n    this.#container.appendChild(this.#resultsPanel);\n    return this.#container;\n  }\n\n  onRemove(): void {\n    // Nothing to do\n  }\n}\n","// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 0)\n    return angle > 180 ? angle - 360 : angle;\n  return angle < -180 ? angle + 360 : angle;\n}\nfunction radiansToDegrees(radians) {\n  const degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null)\n    return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null)\n        continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\")\n              multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\")\n            multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\")\n              multiFeatureIndex++;\n            if (geomType === \"Polygon\")\n              geometryIndex++;\n          }\n          if (geomType === \"Polygon\")\n            multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false)\n          break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false)\n        break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else\n      previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry)\n      return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\")\n      return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson)\n    throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null)\n      return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0)\n        segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0)\n        coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","/**\n * splaytree v3.1.2\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? ' ' : ' ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var current, Q, done;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    current = this._root;\r\n                    Q = [];\r\n                    done = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!!done) return [3 /*break*/, 6];\r\n                    if (!(current !== null)) return [3 /*break*/, 2];\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                    return [3 /*break*/, 5];\r\n                case 2:\r\n                    if (!(Q.length !== 0)) return [3 /*break*/, 4];\r\n                    current = Q.pop();\r\n                    return [4 /*yield*/, current];\r\n                case 3:\r\n                    _a.sent();\r\n                    current = current.right;\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    done = true;\r\n                    _a.label = 5;\r\n                case 5: return [3 /*break*/, 1];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import SplayTree from 'splaytree';\nimport { orient2d } from 'robust-predicates';\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nconst isInBbox = (bbox, point) => {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nconst getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n  // put those middle values together to get the overlap\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON;\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nconst EPSILON_SQ = epsilon * epsilon;\n\n/* FLP comparator */\nconst cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  }\n\n  // check if they're flp equal\n  const ab = a - b;\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    this.xRounder = new CoordRounder();\n    this.yRounder = new CoordRounder();\n  }\n  round(x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y)\n    };\n  }\n}\nclass CoordRounder {\n  constructor() {\n    this.tree = new SplayTree();\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0);\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round(coord) {\n    const node = this.tree.add(coord);\n    const prevNode = this.tree.prev(node);\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord);\n      return prevNode.key;\n    }\n    const nextNode = this.tree.next(node);\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord);\n      return nextNode.key;\n    }\n    return coord;\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\nconst crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n/* Dot Product of two vectors with first point at origin */\nconst dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n/* Comparator for two vectors with same starting point */\nconst compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n  if (res > 0) return -1;\n  if (res < 0) return 1;\n  return 0;\n};\nconst length = v => Math.sqrt(dotProduct(v, v));\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst intersection$1 = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  const ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  const d1 = crossProduct(ve, v1) / kross;\n  const d2 = crossProduct(ve, v2) / kross;\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x,\n    x2 = pt2.x + d1 * v2.x;\n  const y1 = pt1.y + d2 * v1.y,\n    y2 = pt2.y + d1 * v2.y;\n  const x = (x1 + x2) / 2;\n  const y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nclass SweepEvent {\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b);\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment);\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x < bPt.x) return -1;\n    if (aPt.x > bPt.x) return 1;\n    if (aPt.y < bPt.y) return -1;\n    if (aPt.y > bPt.y) return 1;\n    return 0;\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n    // this.segment, this.otherSE set by factory\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== undefined) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== undefined) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    // point.events is always of length 2 or greater\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = new Map();\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const {\n        sine: asine,\n        cosine: acosine\n      } = cache.get(a);\n      const {\n        sine: bsine,\n        cosine: bcosine\n      } = cache.get(b);\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1;\n        if (acosine > bcosine) return -1;\n        return 0;\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1;\n        if (acosine > bcosine) return 1;\n        return 0;\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1;\n      if (bsine > asine) return 1;\n      return 0;\n    };\n  }\n}\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0;\nclass Segment {\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1;\n    if (arx < blx) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1;\n      if (bly > aly && bly > ary) return -1;\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1;\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1;\n      if (aly > bly && aly > bry) return 1;\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1;\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1;\n    if (aly > bly) return 1;\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (arx !== brx) {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly;\n      const ax = arx - alx;\n      const by = bry - bly;\n      const bx = brx - blx;\n      if (ay > ax && by < bx) return 1;\n      if (ay < ax && by > bx) return -1;\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1;\n    if (arx < brx) return -1;\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1;\n    if (ary > bry) return 1;\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n\n    // identical segment, ie a === b\n    return 0;\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new Segment(leftSE, rightSE, [ring], [winding]);\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: {\n        x: this.leftSE.point.x,\n        y: y1 < y2 ? y1 : y2\n      },\n      ur: {\n        x: this.rightSE.point.x,\n        y: y1 > y2 ? y1 : y2\n      }\n    };\n  }\n\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n  }\n\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    if (this.isAnEndpoint(point)) return 0;\n    const lPt = this.leftSE.point;\n    const rPt = this.rightSE.point;\n    const v = this.vector();\n\n    // Exactly vertical segments.\n    if (lPt.x === rPt.x) {\n      if (point.x === lPt.x) return 0;\n      return point.x < lPt.x ? 1 : -1;\n    }\n\n    // Nearly vertical segments with an intersection.\n    // Check to see where a point on the line with matching Y coordinate is.\n    const yDist = (point.y - lPt.y) / v.y;\n    const xFromYDist = lPt.x + yDist * v.x;\n    if (point.x === xFromYDist) return 0;\n\n    // General case.\n    // Check to see where a point on the line with matching X coordinate is.\n    const xDist = (point.x - lPt.x) / v.x;\n    const yFromXDist = lPt.y + xDist * v.y;\n    if (point.y === yFromXDist) return 0;\n    return point.y < yFromXDist ? -1 : 1;\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null;\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return tlp;\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return olp;\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null;\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null;\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null;\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y);\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== undefined;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = Segment.compare(consumer, consumee);\n    if (cmp === 0) return; // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== undefined) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState;\n    if (!this.prev) this._beforeState = {\n      rings: [],\n      windings: [],\n      multiPolys: []\n    };else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== undefined) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n\n    // calcualte polysAfter\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue; // non-zero rule\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult() {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false;\n    if (this._isInResult !== undefined) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation.type) {\n      case \"union\":\n        {\n          // UNION - included iff:\n          //  * On one side of us there is 0 poly interiors AND\n          //  * On the other side there is 1 or more.\n          const noBefores = mpsBefore.length === 0;\n          const noAfters = mpsAfter.length === 0;\n          this._isInResult = noBefores !== noAfters;\n          break;\n        }\n      case \"intersection\":\n        {\n          // INTERSECTION - included iff:\n          //  * on one side of us all multipolys are rep. with poly interiors AND\n          //  * on the other side of us, not all multipolys are repsented\n          //    with poly interiors\n          let least;\n          let most;\n          if (mpsBefore.length < mpsAfter.length) {\n            least = mpsBefore.length;\n            most = mpsAfter.length;\n          } else {\n            least = mpsAfter.length;\n            most = mpsBefore.length;\n          }\n          this._isInResult = most === operation.numMultiPolys && least < most;\n          break;\n        }\n      case \"xor\":\n        {\n          // XOR - included iff:\n          //  * the difference between the number of multipolys represented\n          //    with poly interiors on our two sides is an odd number\n          const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n          this._isInResult = diff % 2 === 1;\n          break;\n        }\n      case \"difference\":\n        {\n          // DIFFERENCE included iff:\n          //  * on exactly one side, we have just the subject\n          const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n          break;\n        }\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`);\n    }\n    return this._isInResult;\n  }\n}\n\nclass RingIn {\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n      // skip repeated points\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    // add segment from last to first if last is not the same as first\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n}\nclass PolyIn {\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    // copy by value\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\nclass MultiPolyIn {\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n      // The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\n\nclass RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n\n          /* Did we hit a dead end? This shouldn't happen.\n           * Indicates some earlier part of the algorithm malfunctioned. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new RingOut(ringEvents.reverse()));\n            continue;\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point;\n      const nextPt = this.events[i + 1].point;\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n      points.push(pt);\n      prevPt = pt;\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null;\n\n    // check if the starting point is necessary\n    const pt = points[0];\n    const nextPt = points[1];\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null;\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut;\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut.enclosingRing();\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n}\nclass PolyOut {\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom = [this.exteriorRing.getGeom()];\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null;\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n}\nclass MultiPolyOut {\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing.poly.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n}\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nclass SweepLine {\n  constructor(queue) {\n    let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n      return newEvents;\n    }\n    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n    if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n    let prevNode = node;\n    let nextNode = node;\n    let prevSeg = undefined;\n    let nextSeg = undefined;\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode);\n      if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode);\n      if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n    }\n    if (event.isLeft) {\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment);\n        newEvents.push(event);\n      } else {\n        // done with left event\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.remove(segment);\n    }\n    return newEvents;\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg);\n    const rightSE = seg.rightSE;\n    this.queue.remove(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.add(seg);\n    return newEvents;\n  }\n}\n\n// Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\nconst POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nconst POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nclass Operation {\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    rounder.reset();\n\n    /* Convert inputs to MultiPoly objects */\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === \"difference\") {\n      // in place removal\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === \"intersection\") {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j]);\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n        }\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue);\n    let prevQueueSize = queue.size;\n    let node = queue.pop();\n    while (node) {\n      const evt = node.key;\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment;\n        throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n      }\n      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n      }\n      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n      }\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i];\n        if (evt.consumedBy === undefined) queue.insert(evt);\n      }\n      prevQueueSize = queue.size;\n      node = queue.pop();\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset();\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n}\n\n// singleton available by import\nconst operation = new Operation();\n\nconst union = function (geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n  return operation.run(\"union\", geom, moreGeoms);\n};\nconst intersection = function (geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n  return operation.run(\"intersection\", geom, moreGeoms);\n};\nconst xor = function (geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n  return operation.run(\"xor\", geom, moreGeoms);\n};\nconst difference = function (subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n  return operation.run(\"difference\", subjectGeom, clippingGeoms);\n};\nvar index = {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference\n};\n\nexport { index as default };\n","// index.ts\nimport { multiPolygon, polygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nimport polygonClipping from \"polygon-clipping\";\nfunction intersect(features, options = {}) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must specify at least 2 geometries\");\n  }\n  const intersection = polygonClipping.intersection(\n    geoms[0],\n    ...geoms.slice(1)\n  );\n  if (intersection.length === 0)\n    return null;\n  if (intersection.length === 1)\n    return polygon(intersection[0], options.properties);\n  return multiPolygon(intersection, options.properties);\n}\nvar turf_intersect_default = intersect;\nexport {\n  turf_intersect_default as default,\n  intersect\n};\n//# sourceMappingURL=index.js.map","import $ from \"jquery\";\nimport {\n  IControl,\n  LngLatBounds,\n  Map as MglMap,\n  RasterSourceSpecification,\n  RequestParameters,\n  ResourceType,\n} from \"maplibre-gl\";\nimport { intersect } from \"@turf/intersect\";\nimport { featureCollection, polygon } from \"@turf/helpers\";\nimport { Feature, Polygon } from \"geojson\";\n\nimport {\n  createControlButton,\n  createControlContainer,\n  createMdiIcon,\n} from \"../helpers\";\nimport { Shape, TilesSourceBounds, TilesSourceDate } from \"../../tiles-sources\";\nimport \"./_index.css\";\n\n/**\n * Type of the event fired whenever the user selects a tiles source.\n */\nexport interface TilesSourceChangedEvent {\n  type: \"tiles\";\n  /**\n   * The selected tiles source.\n   */\n  source: TilesSource;\n  target: MglMap;\n}\n\n/**\n * This type adds an ID to MapLibres {@link RasterSourceSpecification} type.\n */\nexport type RasterSourceSpecificationWithId = RasterSourceSpecification & {\n  /**\n   * The internal ID of the tiles source.\n   */\n  id: string;\n};\n\n/**\n * The available tile source categories.\n */\nexport type TilesSourceCategory = \"photo\" | \"map\" | \"elevation\" | \"other\";\n\n/**\n * This type represents a tiles source.\n */\nexport interface TilesSource {\n  /**\n   * Display-name of the tiles source.\n   */\n  label: string;\n  /**\n   * The internal ID of the tiles source.\n   */\n  id: string;\n  category: TilesSourceCategory;\n  source: RasterSourceSpecificationWithId;\n  best?: boolean;\n  description?: string;\n  defaultForType?: boolean;\n  bounds?: TilesSourceBounds;\n  privacyPolicyUrl?: string;\n  permissionRef?: string;\n  icon?: string;\n  date?: TilesSourceDate;\n}\n\n/**\n * Options for the {@link TilesSourcesControl} class.\n */\nexport interface TilesSourcesControlOptions {\n  /**\n   * List of tile sources to show in the control.\n   */\n  sources: TilesSource[];\n  /**\n   * Whether the map is in edit mode.\n   */\n  editMode: boolean;\n  /**\n   * Optional. Title of the control.\n   */\n  title?: string;\n  /**\n   * Optional. Title of the Best imagery for this area icon.\n   */\n  bestIconTitle?: string;\n}\n\n/**\n * The order in which category lists should appear in the control.\n */\nconst categoryOrder: TilesSourceCategory[] = [\n  \"photo\",\n  \"map\",\n  \"elevation\",\n  \"other\",\n];\n\n/**\n * A control that allows switching between multiple tiles sources.\n */\nexport default class TilesSourcesControl implements IControl {\n  #map: MglMap | undefined;\n  readonly #title: string;\n  readonly #bestIconTitle: string;\n  readonly #sourcesByCategory = new Map<TilesSourceCategory, TilesSource[]>();\n  readonly #visibleSources = new Set<string>();\n  readonly #editMode: boolean;\n  readonly #container: HTMLDivElement;\n  readonly #$inputsContainer: JQuery;\n\n  constructor(options: TilesSourcesControlOptions) {\n    this.#title = options.title ?? \"Backgrounds\";\n    this.#bestIconTitle = options.bestIconTitle ?? \"Best imagery for this area\";\n    for (const source of options.sources) {\n      const category = source.category;\n      if (!this.#sourcesByCategory.has(category))\n        this.#sourcesByCategory.set(category, []);\n      this.#sourcesByCategory.get(category)?.push(source);\n    }\n    this.#editMode = options.editMode;\n    this.#container = createControlContainer(\"maplibregl-ctrl-tiles-sources\");\n    this.#$inputsContainer = $('<div class=\"sources-categories\">').hide();\n  }\n\n  /**\n   * Setup this control by creating lists of available tiles sources.\n   */\n  #setup(): void {\n    const map = this.#map;\n    if (!map) throw Error(\"Map is undefined\");\n\n    const button = createControlButton({\n      title: this.#title,\n      icon: createMdiIcon(\"layers-outline\"),\n      onClick: () => {\n        if (!this.#$inputsContainer.is(\":visible\"))\n          this.#$inputsContainer.show();\n        else this.#$inputsContainer.hide();\n      },\n    });\n\n    map.on(\"click\", () => {\n      this.#$inputsContainer.hide();\n    });\n    this.#container.appendChild(button);\n    this.#container.appendChild(this.#$inputsContainer[0]);\n\n    const entries = [...this.#sourcesByCategory.entries()];\n    entries.sort(\n      (e1, e2) => categoryOrder.indexOf(e1[0]) - categoryOrder.indexOf(e2[0]),\n    );\n\n    // Most source names are in English, use this locale for sorting\n    const collator = new Intl.Collator(\"en\", {\n      usage: \"sort\",\n      numeric: true, // Interpret numbers: e.g. 2 before 10\n      sensitivity: \"accent\", // Keep diacritics\n    });\n\n    for (const [category, sources] of entries) {\n      sources.sort((s1, s2) => {\n        // Put best sources first then sort by label\n        if (s1.best && !s2.best) return -1;\n        if (!s1.best && s2.best) return 1;\n        return collator.compare(s1.label, s2.label);\n      });\n\n      const $listContainer = $(\n        `<div class=\"sources-category-box\" id=\"category-${category}\">`,\n      );\n      this.#$inputsContainer.append($listContainer);\n      const categoryTitle = window.ottm.translate(\n        \"map.controls.layers.categories.\" + category,\n      );\n      $listContainer.append(\n        `<span class=\"sources-category-title\">${categoryTitle}</span>`,\n      );\n      const $inputsList = $(\"<ul>\");\n      $listContainer.append($inputsList);\n\n      for (const source of sources) {\n        const sourceId = this.#getSourceInputId(source.id);\n        const $input: JQuery<HTMLInputElement> = $(\n          `<input type=\"radio\" name=\"tiles-sources\" value=\"${source.id}\" id=\"${sourceId}\">`,\n        );\n        $input.on(\"change\", (e) => {\n          this.#changeTilesSource(this.#findTilesSourceById(e.target.value));\n        });\n        const $item = $(\"<li>\");\n        const $label = $(`<label for=\"${sourceId}\">${source.label}</label>`);\n        if (source.best) {\n          const icon = createMdiIcon(\"star\");\n          icon.title = this.#bestIconTitle;\n          $label.append(\" \").append(icon);\n        }\n        $item.append($input, \" \", $label);\n        $inputsList.append($item);\n      }\n    }\n\n    map.setTransformRequest((url, resourceType) =>\n      this.#transformRequest(url, resourceType),\n    );\n\n    map.on(\"zoomend\", () => {\n      this.#filterSources();\n    });\n    map.on(\"moveend\", () => {\n      this.#filterSources();\n    });\n    map.on(\"resize\", () => {\n      this.#filterSources();\n    });\n\n    map.on(\"load\", () => {\n      this.#filterSources();\n      // Select the best for area or default photo source if in edit mode, otherwise select best or default map source\n      const key: TilesSourceCategory = this.#editMode ? \"photo\" : \"map\";\n      const source = this.#sourcesByCategory\n        .get(key)\n        ?.find(\n          (s) =>\n            this.#visibleSources.has(s.id) && (!!s.best || !!s.defaultForType),\n        );\n      if (source) this.#changeTilesSource(source);\n    });\n  }\n\n  /**\n   * Find the {@link TilesSource} object with the given ID.\n   * @param id A {@link TilesSource} ID.\n   * @return The corresponding {@link TilesSource} object.\n   * @throws Error If no {@link TilesSource} has that ID.\n   */\n  #findTilesSourceById(id: string): TilesSource {\n    let tilesSource: TilesSource | undefined;\n    for (const sources of this.#sourcesByCategory.values()) {\n      for (const source of sources) {\n        if (source.id === id) {\n          tilesSource = source;\n          break;\n        }\n      }\n    }\n    if (!tilesSource) throw Error(`Cant find tiles source with ID ${id}`);\n    return tilesSource;\n  }\n\n  #changeTilesSource(source: TilesSource): void {\n    const map = this.#map;\n    if (!map) return;\n\n    const layerId = \"tiles\";\n    const sourceId = \"tiles\";\n    if (map.getLayer(layerId)) map.removeLayer(layerId);\n    if (map.getSource(sourceId)) map.removeSource(sourceId);\n    console.log(\"Selected source:\", source, source.source); // DEBUG\n    map.addSource(sourceId, source.source);\n    map.addLayer({\n      id: layerId,\n      type: \"raster\",\n      source: sourceId,\n    });\n    const event: TilesSourceChangedEvent = {\n      type: \"tiles\",\n      target: map,\n      source: source,\n    };\n    map.fire(\"controls.styles.tiles_changed\", event);\n\n    // Source may not have been changed by interacting with this control, select the corresponding radio button\n    const $input = $(\"#\" + this.#getSourceInputId(source.id, true));\n    if (!$input.prop(\"checked\")) $input.prop(\"checked\", true);\n  }\n\n  /**\n   * Filter which sources are shown in the control depending on the current map zoom and viewport bounds.\n   *\n   * Sources (that are not selected) that match any of the following criteria are hidden:\n   * * Its min zoom is less than the current zoom.\n   * * Its max zoom is greater than the current zoom.\n   * * It has bounds and it does not, nor any of its shapes, intersect the current map viewport bounds.\n   */\n  #filterSources(): void {\n    const map = this.#map;\n    if (!map) return;\n\n    const zoom = map.getZoom();\n    const bounds = map.getBounds();\n    this.#visibleSources.clear();\n\n    for (const [category, sources] of this.#sourcesByCategory.entries()) {\n      let count = 0;\n\n      for (const source of sources) {\n        const sourceId = this.#getSourceInputId(source.id, true);\n        const $input = $(\"#\" + sourceId);\n\n        const sourceBounds = source.bounds;\n        const hide =\n          !$input.prop(\"checked\") &&\n          ((!!source.source.minzoom && zoom < source.source.minzoom) ||\n            (!!source.source.maxzoom && zoom > source.source.maxzoom) ||\n            (!!sourceBounds && !this.#intersects(sourceBounds, bounds)));\n\n        const $listItem = $input.parent();\n        if (hide) $listItem.hide();\n        else {\n          this.#visibleSources.add(source.id);\n          count++;\n          $listItem.show();\n        }\n      }\n\n      const $categoryDiv = $(\"#category-\" + category);\n      if (count === 0) $categoryDiv.hide();\n      else $categoryDiv.show();\n    }\n  }\n\n  /**\n   * Check whether the given tiles source bounds intersect the given map viewport bounds.\n   * @param sourceBounds The bounds of a {@link TilesSource}.\n   * @param viewportBounds The viewport bounds of the map.\n   * @return True if the viewport bounds intersect the source bounds bbox *and* any of its shapes, false otherwise.\n   */\n  #intersects(\n    sourceBounds: TilesSourceBounds,\n    viewportBounds: LngLatBounds,\n  ): boolean {\n    const bounds = new LngLatBounds([\n      sourceBounds.bbox.minLon,\n      sourceBounds.bbox.minLat,\n      sourceBounds.bbox.maxLon,\n      sourceBounds.bbox.maxLat,\n    ]);\n    const sourceBoundsPolygon = polygon([\n      [\n        bounds.getNorthWest().toArray(),\n        bounds.getNorthEast().toArray(),\n        bounds.getSouthEast().toArray(),\n        bounds.getSouthWest().toArray(),\n        bounds.getNorthWest().toArray(), // GeoJSON expects the first vertex to also be the last\n      ],\n    ]);\n\n    const viewportBoundsPolygon = polygon([\n      [\n        viewportBounds.getNorthWest().toArray(),\n        viewportBounds.getNorthEast().toArray(),\n        viewportBounds.getSouthEast().toArray(),\n        viewportBounds.getSouthWest().toArray(),\n        viewportBounds.getNorthWest().toArray(),\n      ],\n    ]);\n\n    function shapeToPolygon(shape: Shape): Feature<Polygon> {\n      const shape_ = shape.map((point) => [point.lon, point.lat]);\n      return polygon([[...shape_, shape_[0]]]);\n    }\n\n    return (\n      intersect(\n        featureCollection([sourceBoundsPolygon, viewportBoundsPolygon]),\n      ) !== null &&\n      (sourceBounds.shapes.length === 0 ||\n        sourceBounds.shapes.some(\n          (shape) =>\n            intersect(\n              featureCollection([viewportBoundsPolygon, shapeToPolygon(shape)]),\n            ) !== null,\n        ))\n    );\n  }\n\n  #transformRequest(\n    url: string,\n    resourceType?: ResourceType,\n  ): RequestParameters | undefined {\n    if (!resourceType || resourceType.valueOf() !== \"Tile\") return { url };\n    const map = this.#map;\n    if (!map) return undefined;\n\n    // Evaluate any {switch:} placeholder.\n    const match = /{switch:(\\w*(?:,\\w*)*)}/.exec(url);\n    if (match) {\n      const parts = match[1].split(\",\");\n      const index = 0; // TODO select random value for each user?\n      url = url.replace(match[0], encodeURIComponent(parts[index]));\n    }\n    return { url };\n  }\n\n  /**\n   * Get the CSS ID for the given tiles source ID.\n   * @param sourceId A tiles source ID.\n   * @param escapeCssSelector If true, the returned ID will be escaped to be a valid CSS selector.\n   * @return The CSS ID.\n   */\n  #getSourceInputId(sourceId: string, escapeCssSelector?: boolean): string {\n    if (escapeCssSelector) sourceId = CSS.escape(sourceId);\n    return \"source-\" + sourceId;\n  }\n\n  onAdd(map: MglMap): HTMLElement {\n    this.#map = map;\n    this.#setup();\n    return this.#container;\n  }\n\n  onRemove(): void {\n    // Nothing to do\n  }\n}\n","import { IControl, Map } from \"maplibre-gl\";\n\nimport { createControlButton, createControlContainer } from \"../helpers\";\nimport \"./_index.css\";\n\n/**\n * Callback for transforming a zoom value.\n *\n * @param {number} zoom The zoom value.\n * @return {any} The transformed zoom value.\n */\nexport type ZoomTransformer = (zoom: number) => string;\n\n/**\n * Options for the {@link OpenExternalMapControl} class.\n */\nexport interface OpenExternalMapControlOptions {\n  /**\n   * Title of the controls button.\n   */\n  buttonTitle: string;\n  /**\n   * URL to the icon image to show.\n   */\n  iconUrl: string;\n  /**\n   * URL pattern for the target website.\n   */\n  urlPattern: string;\n  /**\n   * Optional. A function that transforms the current zoom level before it is passed to the URL pattern.\n   */\n  zoomMapping?: ZoomTransformer;\n}\n\n/**\n * A control that opens the maps current location in the specified external map.\n */\nexport default class OpenExternalMapControl implements IControl {\n  #map: Map | undefined;\n  readonly #container: HTMLElement;\n  readonly #urlPattern: string;\n  readonly #zoomTransformer: ZoomTransformer;\n  readonly #button: HTMLButtonElement;\n\n  constructor(options: OpenExternalMapControlOptions) {\n    this.#container = createControlContainer(\"maplibregl-ctrl-open-location\");\n    this.#urlPattern = options.urlPattern;\n    this.#zoomTransformer = options.zoomMapping ?? Number.toString;\n    const icon = document.createElement(\"img\");\n    icon.src = options.iconUrl;\n    this.#button = createControlButton({\n      title: options.buttonTitle,\n      icon: icon,\n      onClick: () => {\n        this.#onButtonClick();\n      },\n    });\n  }\n\n  #onButtonClick(): void {\n    if (!this.#map) return;\n    const { lat, lng } = this.#map.getCenter();\n    const zoom = this.#map.getZoom();\n    window.open(\n      this.#urlPattern\n        .replace(\"{lat}\", lat.toFixed(5))\n        .replace(\"{lng}\", lng.toFixed(5))\n        .replace(\"{zoom}\", this.#zoomTransformer(zoom)),\n    );\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this.#map = map;\n    this.#container.appendChild(this.#button);\n    return this.#container;\n  }\n\n  onRemove(): void {\n    // Nothing to do\n  }\n}\n","import { IControl, Map } from \"maplibre-gl\";\n\nimport OttmMap from \"../../map\";\nimport {\n  createControlButton,\n  createControlContainer,\n  parseSVG,\n} from \"../helpers\";\nimport $ from \"jquery\";\n\nconst PLUS_ICON = parseSVG(`\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"22\" height=\"22\" fill=\"currentColor\">\n  <rect fill=\"none\" height=\"24\" width=\"24\"/>\n  <path d=\"M18,13h-5v5c0,0.55-0.45,1-1,1l0,0c-0.55,0-1-0.45-1-1v-5H6c-0.55,0-1-0.45-1-1l0,0c0-0.55,0.45-1,1-1h5V6 c0-0.55,0.45-1,1-1l0,0c0.55,0,1,0.45,1,1v5h5c0.55,0,1,0.45,1,1l0,0C19,12.55,18.55,13,18,13z\"/>\n</svg>\n`);\nconst MINUS_ICON = parseSVG(`\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"22\" height=\"22\" fill=\"currentColor\">\n  <rect fill=\"none\" height=\"24\" width=\"24\"/>\n  <path d=\"M18,13H6c-0.55,0-1-0.45-1-1l0,0c0-0.55,0.45-1,1-1h12c0.55,0,1,0.45,1,1l0,0C19,12.55,18.55,13,18,13z\"/>\n</svg>\n`);\n\n/**\n * Options for the {@link ZoomControl} class.\n */\nexport interface ZoomControlOptions {\n  /**\n   * Optional. Title of the \"Zoom In\" button.\n   */\n  zoomInTitle?: string;\n  /**\n   * Optional. Title of the \"Zoom Out\" button.\n   */\n  zoomOutTitle?: string;\n}\n\n/**\n * A control that adds a button to zoom in and another to zoom out the map.\n */\nexport default class ZoomControl implements IControl {\n  #map: Map | undefined;\n  readonly #container: HTMLDivElement;\n  readonly #buttonIn: HTMLButtonElement;\n  readonly #buttonOut: HTMLButtonElement;\n\n  constructor(options: ZoomControlOptions = {}) {\n    this.#container = createControlContainer(\"maplibregl-ctrl-zoom\");\n    this.#buttonIn = createControlButton({\n      title: options.zoomInTitle ?? \"Zoom In\",\n      icon: PLUS_ICON,\n      onClick: () => {\n        this.#map?.zoomIn();\n      },\n      shortcut: [\"+\"],\n    });\n    this.#buttonOut = createControlButton({\n      title: options.zoomOutTitle ?? \"Zoom Out\",\n      icon: MINUS_ICON,\n      onClick: () => {\n        this.#map?.zoomOut();\n      },\n      shortcut: [\"-\"],\n    });\n  }\n\n  /**\n   * Set whether the \"Zoom In\" button should be disabled.\n   * @param disable True to disable, false to enable.\n   */\n  setZoomInButtonDisabled(disable: boolean): void {\n    this.#buttonIn.disabled = disable;\n  }\n\n  /**\n   * Set whether the \"Zoom Out\" button should be disabled.\n   * @param disable True to disable, false to enable.\n   */\n  setZoomOutButtonDisabled(disable: boolean): void {\n    this.#buttonOut.disabled = disable;\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this.#map = map;\n    this.#container.appendChild(this.#buttonIn);\n    this.#container.appendChild(this.#buttonOut);\n    $(map.getContainer()).on(\"keydown\", (e) => {\n      if (map instanceof OttmMap && map.textFieldHasFocus) return;\n      switch (e.key) {\n        case \"+\":\n          map.zoomIn();\n          break;\n        case \"-\":\n          map.zoomOut();\n          break;\n      }\n    });\n    return this.#container;\n  }\n\n  onRemove(): void {\n    // Nothing to do\n  }\n}\n","import $ from \"jquery\";\nimport { IControl, Map } from \"maplibre-gl\";\n\nimport { TilesSource, TilesSourceChangedEvent } from \"../tiles-sources\";\nimport \"./_index.css\";\n\n/**\n * Options for the {@link ImageryDateControl} class.\n */\nexport interface ImageryDateControlOptions {\n  /**\n   * Text to show for a single date. Should contain a {} placeholder for the date.\n   */\n  singleDateText?: string;\n  /**\n   * Text to show when only the start date is available. Should contain a {} placeholder for the date.\n   */\n  onlyStartDateText?: string;\n  /**\n   * Text to show when only the end date is available. Should contain a {} placeholder for the date.\n   */\n  onlyEndDateText?: string;\n  /**\n   * Text to show when only both start and end date are available.\n   * Should contain {0} and {1} placeholders for the start and end dates respectively.\n   */\n  twoDatesText?: string;\n}\n\n/**\n * A control that indicates the date(s) of the current imagery.\n */\nexport default class ImageryDateControl implements IControl {\n  readonly #options: ImageryDateControlOptions;\n  readonly #$container: JQuery;\n  readonly #$innerContainer: JQuery;\n\n  constructor(options: ImageryDateControlOptions) {\n    this.#options = { ...options };\n    this.#$container = $('<div class=\"maplibregl-ctrl-imagery-date\">');\n    this.#$innerContainer = $(\"<span>\");\n    this.#$container.append(this.#$innerContainer);\n  }\n\n  #onTilesSourceChanged(source: TilesSource): void {\n    const options = this.#options;\n    const date = source.date;\n\n    if (!date) this.#$container.hide();\n    else {\n      this.#$container.show();\n      if (date.type === \"date\")\n        this.#$innerContainer.text(\n          (options.singleDateText ?? \"Image date: {}\").replace(\"{}\", date.date),\n        );\n      else if (\"start\" in date && !(\"end\" in date)) {\n        this.#$innerContainer.text(\n          (options.onlyStartDateText ?? \"Image date: {} and after\").replace(\n            \"{}\",\n            date.start,\n          ),\n        );\n      } else if (\"end\" in date && !(\"start\" in date)) {\n        this.#$innerContainer.text(\n          (options.onlyEndDateText ?? \"Image date: {} and before\").replace(\n            \"{}\",\n            date.end,\n          ),\n        );\n      } else {\n        this.#$innerContainer.text(\n          (options.twoDatesText ?? \"Image dates: {0} to {1}\")\n            .replace(\"{0}\", date.start)\n            .replace(\"{1}\", date.end),\n        );\n      }\n    }\n  }\n\n  onAdd(map: Map): HTMLElement {\n    map.on(\"controls.styles.tiles_changed\", (e: TilesSourceChangedEvent) => {\n      this.#onTilesSourceChanged(e.source);\n    });\n    return this.#$container[0];\n  }\n\n  onRemove(): void {\n    // Nothing to do\n  }\n}\n","import {\n  RasterSourceSpecificationWithId,\n  TilesSource,\n  TilesSourceCategory,\n} from \"./controls/tiles-sources\";\nimport tileSourcesDefs from \"./imagery_sources.json\";\n\n/**\n * This interface represents the bounds of a {@link TilesSourceDefinition}.\n */\nexport interface TilesSourceBounds {\n  /**\n   * The bounding box of these bounds.\n   */\n  bbox: {\n    minLat: number;\n    maxLat: number;\n    minLon: number;\n    maxLon: number;\n  };\n  /**\n   * The list of shapes contained in these bounds.\n   */\n  shapes: Shape[];\n}\n\n/**\n * A shape is simply a list of points.\n */\nexport type Shape = Point[];\n\n/**\n * A point represents a latitude and longitude coordinate.\n */\nexport interface Point {\n  lat: number;\n  lon: number;\n}\n\n/**\n * The available tile source categories as extracted from the JSON file.\n */\ntype JsonTilesSourceCategory =\n  | \"photo\"\n  | \"elevation\"\n  | \"map\"\n  | \"historicmap\"\n  | \"osmbasedmap\"\n  | \"historicphoto\"\n  | \"other\";\n\n/**\n * This interface represents a single date.\n */\nexport interface SingleDate {\n  type: \"date\";\n  date: string;\n}\n\n/**\n * Base interface for date intervals.\n */\nexport interface DateIntervalBase {\n  type: \"interval\";\n}\n\n/**\n * A date interval with only a start date.\n */\nexport interface StartDateInterval extends DateIntervalBase {\n  start: string;\n}\n\n/**\n * A date interval with only an end date.\n */\nexport interface EndDateInterval extends DateIntervalBase {\n  end: string;\n}\n\n/**\n * A date interval with both a start and an end date.\n */\nexport type FullDateInterval = StartDateInterval & EndDateInterval;\n\n/**\n * This type represents an interval between two dates (inclusive).\n * Either the start or end date may be absent, but not both at the same time.\n */\nexport type DateInterval =\n  | StartDateInterval\n  | EndDateInterval\n  | FullDateInterval;\n\n/**\n * This type represents the date of a tile source.\n * It is either a single date or an interval.\n */\nexport type TilesSourceDate = SingleDate | DateInterval;\n\n/**\n * This interface defines the structure of a tile source definition as found in the generated JSON file.\n */\nexport interface TilesSourceDefinition {\n  name: string;\n  id: string;\n  url: string;\n  category: JsonTilesSourceCategory;\n  eliBest?: boolean;\n  description?: string;\n  defaultForType?: boolean;\n  minZoom?: number;\n  maxZoom?: number;\n  bounds?: TilesSourceBounds;\n  privacyPolicyUrl?: string;\n  permissionRef?: string;\n  attributionText?: string;\n  attributionUrl?: string;\n  icon?: string;\n  date?: TilesSourceDate;\n  tileSize?: number;\n}\n\nexport default function loadTilesSources(): TilesSource[] {\n  const tilesSources: TilesSource[] = [];\n\n  for (const sourceDef of tileSourcesDefs as TilesSourceDefinition[]) {\n    const sourceSpec: RasterSourceSpecificationWithId = {\n      id: sourceDef.id,\n      type: \"raster\",\n      tiles: [sourceDef.url],\n      tileSize: sourceDef.tileSize ?? 256,\n    };\n\n    let attrib = \"\";\n    if (sourceDef.icon)\n      attrib = `<img style=\"max-height: 2em\" alt=\"Logo\" src=\"${sourceDef.icon}\"> `;\n    if (sourceDef.attributionText) {\n      attrib += sourceDef.attributionText;\n      if (sourceDef.attributionUrl)\n        attrib = `<a href=\"${sourceDef.attributionUrl}\" target=\"_blank\">${attrib}</a>`;\n    } else if (sourceDef.attributionUrl)\n      attrib = `<a href=\"${sourceDef.attributionUrl}\" target=\"_blank\">${attrib}${sourceDef.attributionUrl}</a>`;\n    if (attrib !== \"\") sourceSpec.attribution = attrib;\n\n    if (sourceDef.minZoom) sourceSpec.minzoom = sourceDef.minZoom;\n    if (sourceDef.maxZoom) sourceSpec.maxzoom = sourceDef.maxZoom;\n\n    const source: TilesSource = {\n      label: sourceDef.name,\n      id: sourceDef.id,\n      category: getCategory(sourceDef.category),\n      source: sourceSpec,\n    };\n\n    if (sourceDef.eliBest) source.best = true;\n    if (sourceDef.description) source.description = sourceDef.description;\n    if (sourceDef.defaultForType)\n      source.defaultForType = sourceDef.defaultForType;\n    if (sourceDef.bounds) source.bounds = sourceDef.bounds;\n    if (sourceDef.privacyPolicyUrl)\n      source.privacyPolicyUrl = sourceDef.privacyPolicyUrl;\n    if (sourceDef.permissionRef) source.permissionRef = sourceDef.permissionRef;\n    if (sourceDef.icon) source.icon = sourceDef.icon;\n    if (sourceDef.date) source.date = sourceDef.date;\n\n    tilesSources.push(source);\n\n    function getCategory(\n      jsonCategory: JsonTilesSourceCategory,\n    ): TilesSourceCategory {\n      if (jsonCategory === \"photo\" || jsonCategory === \"historicphoto\")\n        return \"photo\";\n      if (\n        jsonCategory === \"map\" ||\n        jsonCategory === \"historicmap\" ||\n        jsonCategory === \"osmbasedmap\"\n      )\n        return \"map\";\n      return jsonCategory;\n    }\n  }\n\n  return tilesSources;\n}\n","import { GeolocateControl, ScaleControl } from \"maplibre-gl\";\nimport \"maplibre-gl/dist/maplibre-gl.css\";\nimport $ from \"jquery\";\n\nimport \"./style.css\";\n\nimport OttmMap from \"./map\";\nimport CompassControl from \"./controls/compass\";\nimport GeocoderControl from \"./controls/geocoder\";\nimport TilesSourcesControl, {\n  TilesSource,\n  TilesSourceChangedEvent,\n} from \"./controls/tiles-sources\";\nimport OpenExternalMapControl from \"./controls/open-external-map\";\nimport ZoomControl from \"./controls/zoom\";\nimport ImageryDateControl from \"./controls/imagery-date\";\nimport loadTilesSources from \"./tiles-sources\";\nimport { parseSVG } from \"./controls/helpers\";\n\ndeclare global {\n  interface Window {\n    // Inject global properties\n    // Cf. MapPageHandler class in ottm/page_handlers/_map_handler.py for values\n    OTTM_MAP_CONFIG?: {\n      edit: boolean;\n    };\n  }\n}\n\n/**\n * Initalize the map view.\n */\nexport default async function initMap(): Promise<void> {\n  if (!window.OTTM_MAP_CONFIG)\n    throw new Error(\"Missing global OTTM_MAP_CONFIG object\");\n\n  const editMode = window.OTTM_MAP_CONFIG.edit;\n  const map = new OttmMap({\n    container: \"map\",\n    antialias: true,\n    locale: {\n      \"AttributionControl.ToggleAttribution\": window.ottm.translate(\n        \"map.controls.toggle_attribution.tooltip\",\n      ),\n      \"GeolocateControl.FindMyLocation\": window.ottm.translate(\n        \"map.controls.geolocation.find_my_location\",\n      ),\n      \"GeolocateControl.LocationNotAvailable\": window.ottm.translate(\n        \"map.controls.geolocation.location_unavailable\",\n      ),\n    },\n    style: {\n      name: \"base\",\n      version: 8,\n      sources: {},\n      layers: [],\n      transition: {\n        duration: 0,\n      },\n      // Custom fonts: https://maplibre.org/maplibre-style-spec/glyphs/\n      // Custom fonts generator: https://maplibre.org/font-maker/\n    },\n  });\n  map.keyboard.disable(); // Disable default keyboard actions\n\n  /*\n   * Add controls\n   */\n\n  map.addControl(\n    new ScaleControl({\n      maxWidth: 100,\n      unit: \"imperial\",\n    }),\n  );\n  map.addControl(\n    new ScaleControl({\n      maxWidth: 100,\n      unit: \"metric\",\n    }),\n  );\n\n  if (editMode) {\n    const editorModule = await import(\"./editor/index\");\n    editorModule.default(map);\n  } else {\n    map.addControl(\n      new GeocoderControl({\n        language: window.ottm.getPageLanguage().code,\n        translator: (key, defaultValue) =>\n          window.ottm.translate(key, defaultValue),\n        searchButtonTitle: window.ottm.translate(\n          \"map.controls.search.search_button.title\",\n        ),\n        eraseButtonTitle: window.ottm.translate(\n          \"map.controls.search.erase_button.title\",\n        ),\n        placeholderText: window.ottm.translate(\n          \"map.controls.search.placeholder\",\n        ),\n        noResultsMessage: window.ottm.translate(\n          \"map.controls.search.no_results\",\n        ),\n        errorMessage: window.ottm.translate(\"map.controls.search.error\"),\n      }),\n      \"top-left\",\n    );\n  }\n\n  map.addControl(\n    new TilesSourcesControl({\n      title: window.ottm.translate(\"map.controls.layers.tooltip\"),\n      bestIconTitle: window.ottm.translate(\n        \"map.controls.layers.best_imagery_source.tooltip\",\n      ),\n      sources: loadTilesSources(),\n      editMode: editMode,\n    }),\n    \"top-left\",\n  );\n\n  const zoomControl = new ZoomControl({\n    zoomInTitle: window.ottm.translate(\"map.controls.zoom_in.tooltip\"),\n    zoomOutTitle: window.ottm.translate(\"map.controls.zoom_out.tooltip\"),\n  });\n  map.addControl(zoomControl, \"top-right\");\n  map.boxZoom.disable();\n  map.doubleClickZoom.disable();\n\n  const staticPath = window.ottm.config.get(\"staticPath\");\n\n  map.addControl(\n    new OpenExternalMapControl({\n      buttonTitle: window.ottm.translate(\n        \"map.controls.google_maps_button.tooltip\",\n      ),\n      iconUrl: `${staticPath}ottm/images/icons/GoogleMaps.png`,\n      urlPattern: \"https://www.google.com/maps/@{lat},{lng},{zoom}z\",\n      zoomMapping: (zoom) => (zoom + 1).toFixed(2),\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new OpenExternalMapControl({\n      buttonTitle: window.ottm.translate(\n        \"map.controls.bing_maps_button.tooltip\",\n      ),\n      iconUrl: `${staticPath}ottm/images/icons/Bing.ico`,\n      urlPattern: \"https://www.bing.com/maps/?cp={lat}~{lng}&lvl={zoom}\",\n      zoomMapping: (zoom) => (zoom + 1).toFixed(1),\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new OpenExternalMapControl({\n      buttonTitle: window.ottm.translate(\"map.controls.osm_button.tooltip\"),\n      iconUrl: `${staticPath}ottm/images/icons/OSM.png`,\n      urlPattern: \"https://www.openstreetmap.org/#map={zoom}/{lat}/{lng}\",\n      zoomMapping: (zoom) => (Math.round(zoom) + 1).toString(),\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new OpenExternalMapControl({\n      buttonTitle: window.ottm.translate(\"map.controls.ohm_button.tooltip\"),\n      iconUrl: `${staticPath}ottm/images/icons/OHM.ico`,\n      urlPattern: \"https://www.openhistoricalmap.org/#map={zoom}/{lat}/{lng}\",\n      zoomMapping: (zoom) => (Math.round(zoom) + 1).toString(),\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new OpenExternalMapControl({\n      buttonTitle: window.ottm.translate(\n        \"map.controls.ign_compare_button.tooltip\",\n      ),\n      iconUrl: `${staticPath}ottm/images/icons/IGN.ico`,\n      urlPattern:\n        \"https://remonterletemps.ign.fr/comparer/basic?x={lng}&y={lat}&z={zoom}\",\n      zoomMapping: (zoom) => (Math.round(zoom) + 1).toString(),\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new OpenExternalMapControl({\n      buttonTitle: window.ottm.translate(\"map.controls.geohack_button.tooltip\"),\n      iconUrl: `${staticPath}ottm/images/icons/WikimediaCloudServices.svg`,\n      urlPattern:\n        \"https://geohack.toolforge.org/geohack.php?params={lat}_N_{lng}_E_scale:{zoom}\",\n      // Function extrapolated by an exponential trend line in LibreOffice Calc, using the values at:\n      // https://wiki.openstreetmap.org/w/index.php?title=Zoom_levels&oldid=2553097\n      zoomMapping: (zoom) =>\n        (1080657321.02457 * Math.exp(-0.693992077826686 * (zoom + 2))).toFixed(\n          5,\n        ),\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new GeolocateControl({\n      positionOptions: {\n        enableHighAccuracy: true,\n      },\n      showUserLocation: false,\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new CompassControl({\n      title: window.ottm.translate(\"map.controls.compass.tooltip\"),\n    }),\n    \"top-right\",\n  );\n\n  map.addControl(\n    new ImageryDateControl({\n      singleDateText: window.ottm.translate(\n        \"map.controls.imagery_date.single_date\",\n      ),\n      onlyStartDateText: window.ottm.translate(\n        \"map.controls.imagery_date.only_start_date\",\n      ),\n      onlyEndDateText: window.ottm.translate(\n        \"map.controls.imagery_date.only_end_date\",\n      ),\n      twoDatesText: window.ottm.translate(\n        \"map.controls.imagery_date.two_dates\",\n      ),\n    }),\n    \"bottom-right\",\n  );\n\n  /*\n   * Hook events\n   */\n\n  window.onhashchange = () => {\n    centerViewFromUrl();\n  };\n  map.on(\"zoomend\", () => {\n    updateUrlHash();\n    const zoom = map.getZoom();\n    zoomControl.setZoomOutButtonDisabled(zoom === map.getMinZoom());\n    zoomControl.setZoomInButtonDisabled(zoom === map.getMaxZoom());\n  });\n  map.on(\"moveend\", () => {\n    updateUrlHash();\n  });\n  map.on(\"resize\", () => {\n    updateUrlHash();\n  });\n  map.on(\"load\", () => {\n    // Delete config object and script tag\n    delete window.OTTM_MAP_CONFIG;\n    $(\"#ottm-map-config-script\").remove();\n\n    // Replace the default icon by one that uses the current font color.\n    $(\".maplibregl-ctrl-geolocate .maplibregl-ctrl-icon\").each((_, element) => {\n      element.append(\n        parseSVG(\n          \"<svg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='currentColor' viewBox='0 0 20 20'><path d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/><circle cx='10' cy='10' r='2'/></svg>\",\n        ),\n      );\n    });\n  });\n  map.on(\"controls.styles.tiles_changed\", (e: TilesSourceChangedEvent) => {\n    onTilesSourceChanged(e.source);\n  });\n\n  $(\"body\").on(\"keydown\", (e) => {\n    if (map.textFieldHasFocus) return;\n    switch (e.key) {\n      case \"ArrowUp\":\n        map.panBy([0, -100]);\n        break;\n      case \"ArrowDown\":\n        map.panBy([0, 100]);\n        break;\n      case \"ArrowLeft\":\n        map.panBy([-100, 0]);\n        break;\n      case \"ArrowRight\":\n        map.panBy([100, 0]);\n        break;\n    }\n  });\n\n  map.hookTextFieldsFocusEvents();\n\n  /**\n   * Indicates whether the maps view is being updated from the pages URL hash.\n   */\n  let updatingView = false;\n  /**\n   * Indicates whether the pages URL hash is being updated from the maps view.\n   */\n  let updatingHash = false;\n\n  if (getPositionFromURL().found) centerViewFromUrl();\n\n  /*\n   * Functions\n   */\n\n  /**\n   * Called when the map tiles source has changed.\n   * @param source The new tiles source.\n   */\n  function onTilesSourceChanged(source: TilesSource): void {\n    map.setMaxZoom(source.source.maxzoom);\n    updateUrlHash(); // In case the new max zoom is less than the current one\n  }\n\n  /**\n   * Return a map position from the current URL.\n   *\n   * @return An array containing the latitude, longitude and zoom,\n   *  and a boolean indicating whether values could be extracted from the URL.\n   */\n  function getPositionFromURL(): {\n    pos: [number, number, number];\n    found: boolean;\n  } {\n    const match = /^#map=(\\d+\\.?\\d*)\\/(-?\\d+\\.?\\d*)\\/(-?\\d+\\.?\\d*)$/.exec(\n      window.location.hash,\n    );\n    if (match) {\n      const minZoom = map.getMinZoom();\n      const maxZoom = map.getMaxZoom();\n      const zoom = Math.max(minZoom, Math.min(maxZoom, parseFloat(match[1])));\n      const lat = parseFloat(match[2]);\n      const lng = parseFloat(match[3]);\n      return { pos: [lat, lng, zoom], found: true };\n    }\n    return { pos: [0, 0, 15], found: false };\n  }\n\n  /**\n   * Update pages URL hash from the current map view position.\n   */\n  function updateUrlHash(): void {\n    if (updatingView) {\n      updatingView = false;\n    } else {\n      updatingHash = true;\n      const centerPos = map.getCenter();\n      const lat = centerPos.lat.toFixed(5);\n      const lng = centerPos.lng.toFixed(5);\n      const zoom = map.getZoom().toFixed(5);\n      const hash = `#map=${zoom}/${lat}/${lng}`;\n      window.location.hash = hash;\n      const mapNavLinks = [\n        \"#nav-main-link\",\n        \"#nav-edit-link\",\n        \"#nav-history-link\",\n      ];\n      for (const linkId of mapNavLinks) {\n        const $navLink = $(linkId);\n        if (!$navLink.length) continue;\n        const url = new URL($navLink.prop(\"href\") as string);\n        url.hash = hash;\n        $navLink.attr(\"href\", url.href);\n      }\n      window.ottm.setReferrer();\n    }\n  }\n\n  /**\n   * Center the view from the URLs hash.\n   */\n  function centerViewFromUrl(): void {\n    if (updatingHash) {\n      updatingHash = false;\n    } else {\n      const {\n        pos: [lat, lng, zoom],\n        found,\n      } = getPositionFromURL();\n      if (found) {\n        updatingView = true;\n        map.setZoom(zoom);\n        map.setCenter({ lat, lng });\n      } else {\n        updateUrlHash();\n      }\n    }\n  }\n}\n"],"file":"dep-index.js"}