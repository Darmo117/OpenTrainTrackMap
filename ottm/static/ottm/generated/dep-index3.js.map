{"version":3,"file":"dep-index3.js","sources":["../../../../js-sources/node_modules/split.js/dist/split.es.js","../../../../js-sources/node_modules/@turf/area/dist/esm/index.js","../../../../js-sources/node_modules/@turf/invariant/dist/esm/index.js","../../../../js-sources/node_modules/@turf/bearing/dist/esm/index.js","../../../../js-sources/node_modules/@turf/rhumb-bearing/dist/esm/index.js","../../../../js-sources/node_modules/@turf/angle/dist/esm/index.js","../../../../js-sources/node_modules/@turf/distance/dist/esm/index.js","../../../../js-sources/node_modules/@turf/length/dist/esm/index.js","../../../../js-sources/src/map/utils.ts","../../../../js-sources/src/map/model/geometry.ts","../../../../js-sources/src/map/model/types.ts","../../../../js-sources/src/map/editor/_events.ts","../../../../js-sources/node_modules/@turf/polygon-to-line/dist/esm/index.js","../../../../js-sources/node_modules/@turf/destination/dist/esm/index.js","../../../../js-sources/node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js","../../../../js-sources/node_modules/@turf/line-intersect/dist/esm/index.js","../../../../js-sources/node_modules/@turf/nearest-point-on-line/dist/esm/index.js","../../../../js-sources/src/map/editor/_snap.ts","../../../../js-sources/src/map/editor/_controls.ts","../../../../js-sources/src/map/editor/_side-panel/_component.ts","../../../../js-sources/src/map/editor/_side-panel/_feature-type-button.ts","../../../../js-sources/src/map/editor/_side-panel/index.ts","../../../../js-sources/src/map/editor/_context-menu.ts","../../../../js-sources/src/map/editor/index.ts"],"sourcesContent":["// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () { return snapOffset; });\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            snapOffset: snapOffsets[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\nexport default Split;\n","// index.ts\nimport { earthRadius } from \"@turf/helpers\";\nimport { geomReduce } from \"@turf/meta\";\nfunction area(geojson) {\n  return geomReduce(\n    geojson,\n    (value, geom) => {\n      return value + calculateArea(geom);\n    },\n    0\n  );\n}\nfunction calculateArea(geom) {\n  let total = 0;\n  let i;\n  switch (geom.type) {\n    case \"Polygon\":\n      return polygonArea(geom.coordinates);\n    case \"MultiPolygon\":\n      for (i = 0; i < geom.coordinates.length; i++) {\n        total += polygonArea(geom.coordinates[i]);\n      }\n      return total;\n    case \"Point\":\n    case \"MultiPoint\":\n    case \"LineString\":\n    case \"MultiLineString\":\n      return 0;\n  }\n  return 0;\n}\nfunction polygonArea(coords) {\n  let total = 0;\n  if (coords && coords.length > 0) {\n    total += Math.abs(ringArea(coords[0]));\n    for (let i = 1; i < coords.length; i++) {\n      total -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return total;\n}\nvar FACTOR = earthRadius * earthRadius / 2;\nvar PI_OVER_180 = Math.PI / 180;\nfunction ringArea(coords) {\n  const coordsLength = coords.length - 1;\n  if (coordsLength <= 2)\n    return 0;\n  let total = 0;\n  let i = 0;\n  while (i < coordsLength) {\n    const lower = coords[i];\n    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n    const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n    const lowerX = lower[0] * PI_OVER_180;\n    const middleY = middle[1] * PI_OVER_180;\n    const upperX = upper[0] * PI_OVER_180;\n    total += (upperX - lowerX) * Math.sin(middleY);\n    i++;\n  }\n  return total * FACTOR;\n}\nvar turf_area_default = area;\nexport {\n  area,\n  turf_area_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction bearing(start, end, options = {}) {\n  if (options.final === true) {\n    return calculateFinalBearing(start, end);\n  }\n  const coordinates1 = getCoord(start);\n  const coordinates2 = getCoord(end);\n  const lon1 = degreesToRadians(coordinates1[0]);\n  const lon2 = degreesToRadians(coordinates2[0]);\n  const lat1 = degreesToRadians(coordinates1[1]);\n  const lat2 = degreesToRadians(coordinates2[1]);\n  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return radiansToDegrees(Math.atan2(a, b));\n}\nfunction calculateFinalBearing(start, end) {\n  let bear = bearing(end, start);\n  bear = (bear + 180) % 360;\n  return bear;\n}\nvar turf_bearing_default = bearing;\nexport {\n  bearing,\n  turf_bearing_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction rhumbBearing(start, end, options = {}) {\n  let bear360;\n  if (options.final) {\n    bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));\n  } else {\n    bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));\n  }\n  const bear180 = bear360 > 180 ? -(360 - bear360) : bear360;\n  return bear180;\n}\nfunction calculateRhumbBearing(from, to) {\n  const phi1 = degreesToRadians(from[1]);\n  const phi2 = degreesToRadians(to[1]);\n  let deltaLambda = degreesToRadians(to[0] - from[0]);\n  if (deltaLambda > Math.PI) {\n    deltaLambda -= 2 * Math.PI;\n  }\n  if (deltaLambda < -Math.PI) {\n    deltaLambda += 2 * Math.PI;\n  }\n  const deltaPsi = Math.log(\n    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)\n  );\n  const theta = Math.atan2(deltaLambda, deltaPsi);\n  return (radiansToDegrees(theta) + 360) % 360;\n}\nvar turf_rhumb_bearing_default = rhumbBearing;\nexport {\n  turf_rhumb_bearing_default as default,\n  rhumbBearing\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nfunction angle(startPoint, midPoint, endPoint, options = {}) {\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n  const A = startPoint;\n  const O = midPoint;\n  const B = endPoint;\n  const azimuthAO = bearingToAzimuth(\n    options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O)\n  );\n  const azimuthBO = bearingToAzimuth(\n    options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O)\n  );\n  const angleAO = Math.abs(azimuthAO - azimuthBO);\n  if (options.explementary === true) {\n    return 360 - angleAO;\n  }\n  return angleAO;\n}\nvar turf_angle_default = angle;\nexport {\n  angle,\n  turf_angle_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\nfunction distance(from, to, options = {}) {\n  var coordinates1 = getCoord(from);\n  var coordinates2 = getCoord(to);\n  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n  return radiansToLength(\n    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),\n    options.units\n  );\n}\nvar turf_distance_default = distance;\nexport {\n  turf_distance_default as default,\n  distance\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { distance } from \"@turf/distance\";\nimport { segmentReduce } from \"@turf/meta\";\nfunction length(geojson, options = {}) {\n  return segmentReduce(\n    geojson,\n    (previousValue, segment) => {\n      const coords = segment.geometry.coordinates;\n      return previousValue + distance(coords[0], coords[1], options);\n    },\n    0\n  );\n}\nvar turf_length_default = length;\nexport {\n  turf_length_default as default,\n  length\n};\n//# sourceMappingURL=index.js.map","import { LngLat } from \"maplibre-gl\";\n\n/**\n * Return a copy of the given LngLat object.\n * @param lngLat The object to copy.\n */\nexport function copyLngLat(lngLat: LngLat): LngLat {\n  return LngLat.convert(lngLat.toArray());\n}\n\n/**\n * Check if the given mouse event was triggered by the mouse’s secondary button (usually the right button).\n * @param e The event to check.\n */\nexport function isSecondaryClick(e: MouseEvent): boolean {\n  return e.button === 2;\n}\n","import { LngLat } from \"maplibre-gl\";\nimport {\n  Feature,\n  LineString as GeoLineString,\n  Point as GeoPoint,\n  Polygon as GeoPolygon,\n} from \"geojson\";\nimport { area } from \"@turf/area\";\nimport { angle as turfAngle } from \"@turf/angle\";\nimport { length } from \"@turf/length\";\nimport { polygon } from \"@turf/helpers\";\n\nimport { copyLngLat } from \"../utils\";\nimport { Enum, ObjectInstance, ObjectType, UnitType } from \"./types\";\n\nexport type Geometry = GeoPoint | GeoLineString | GeoPolygon;\n\nexport interface MapFeatureProperties {\n  color: string;\n  layer: number;\n  selectionMode: SelectionMode;\n}\n\nexport type PointProperties = MapFeatureProperties & {\n  radius: number;\n};\nexport type LinearProperties = MapFeatureProperties;\nexport type LineStringProperties = LinearProperties & {\n  width: number;\n  dash: number[] | null;\n  fgColor: string;\n  fgWidth: number;\n  fgDash: number[] | null;\n};\nexport type PolygonProperties = LinearProperties;\n\nexport interface DataTypes {\n  UnitType: UnitType;\n  Enum: Enum;\n  ObjectType: ObjectType;\n}\n\n/**\n * A function that provides the given data type for a name and type string.\n */\nexport type DataTypeProvider = <K extends keyof DataTypes>(\n  typeName: string,\n  metaType: K,\n) => DataTypes[K];\n\n/**\n * This class represents a longitude/latitude offset on the map.\n */\nexport class LngLatVector {\n  /**\n   * The zero vector.\n   */\n  static readonly ZERO: LngLatVector = new LngLatVector(0, 0);\n\n  /**\n   * Get the vector of the difference between the two given positions.\n   * @param ll1 The first position.\n   * @param ll2 The position to substract from the first one.\n   * @returns The distance vector `ll1 - ll2`.\n   */\n  static sub(ll1: LngLat, ll2: LngLat): LngLatVector {\n    return new LngLatVector(ll1.lng - ll2.lng, ll1.lat - ll2.lat);\n  }\n\n  /**\n   * The longitude offset.\n   */\n  readonly lng: number;\n  /**\n   * The latitude offset.\n   */\n  readonly lat: number;\n\n  /**\n   * Create a new vector.\n   * @param lng The longitude offset.\n   * @param lat The latitude offset.\n   */\n  constructor(lng: number, lat: number) {\n    this.lng = lng;\n    this.lat = lat;\n  }\n\n  /**\n   * Add this vector to the given LngLat object.\n   * @param lngLat The LngLat to offset.\n   * @returns A new LngLat object.\n   */\n  addTo(lngLat: LngLat): LngLat {\n    return new LngLat(lngLat.lng + this.lng, lngLat.lat + this.lat);\n  }\n}\n\n/**\n * Enumeration of all possible selection states.\n */\nexport enum SelectionMode {\n  NONE,\n  SELECTED,\n  HOVERED,\n}\n\n/**\n * A map feature is a geometry object that can be shown and manipulated in a Map.\n * It implements GeoJSON’s Feature structure.\n *\n * The `geometry` field implements GeoJSON’s GeoJsonObject structure.\n *\n * All map features have the following entries in their `properties` field:\n * * `color: string`: the feature’s color.\n * * `layer: number`: the feature’s layer.\n *\n * The `geometry` and `properties` fields ***should NOT*** be modified manually.\n * Their publicly visible to respect the Feature structure.\n * Map features should always be modified through relevant accessors and methods.\n *\n * Subclasses may define additional properties.\n *\n * @see Geometry\n * @see MapFeatureProperties\n */\nexport abstract class MapFeature<\n  G extends Geometry = Geometry,\n  P extends MapFeatureProperties = MapFeatureProperties,\n> implements Feature<G, P>\n{\n  // Fields required by geojson.Feature\n  readonly type = \"Feature\";\n  readonly geometry: G;\n  readonly properties: P;\n  id: string;\n\n  /**\n   * This feature’s database ID. Null if this feature does not exist in the database yet.\n   */\n  readonly dbId: number | null;\n  // Using # seems to mess up things\n  private dataObject_: ObjectInstance | null = null;\n  protected readonly dataTypesProvider: DataTypeProvider;\n\n  /**\n   * Create a new map feature.\n   * @param id The ID for the map the feature belongs to.\n   * @param dataTypesProvider A function that provides the given data type for a name and type string.\n   * @param geometry The feature’s geometry object.\n   * @param dbId The feature’s database ID.\n   * @param layer The z-order layer index.\n   * @param dataObject The attached object containing data. May be null.\n   * @throws {TypeError} If the data object’s geometry type is incompatible with this geometry.\n   */\n  protected constructor(\n    id: string,\n    dataTypesProvider: DataTypeProvider,\n    geometry: G,\n    dbId?: number,\n    layer?: number,\n    dataObject?: ObjectInstance,\n  ) {\n    this.id = id;\n    this.dbId = dbId ?? null;\n    this.geometry = geometry;\n    this.properties = {\n      color: \"#ffffff\",\n      layer: 0,\n      selectionMode: SelectionMode.NONE,\n    } as P;\n    this.dataTypesProvider = dataTypesProvider;\n    if (dataObject) {\n      const expectedGeomType = this.geometry.type;\n      const actualGeomType = dataObject.type.getGeometryType();\n      if (actualGeomType !== expectedGeomType) {\n        throw new TypeError(\n          `Invalid data object geometry type: expected \"${expectedGeomType}\", got \"${actualGeomType}\"`,\n        );\n      }\n      this.dataObject_ = dataObject;\n    }\n    this.layer = layer ?? 0;\n  }\n\n  get dataObject(): ObjectInstance | null {\n    return this.dataObject_;\n  }\n\n  /**\n   * This feature’s color.\n   */\n  get color(): string {\n    return this.properties.color;\n  }\n\n  /**\n   * This feature’s layer.\n   */\n  get layer(): number {\n    return this.properties.layer;\n  }\n\n  /**\n   * Set this feature’s layer.\n   * @param layer The new layer.\n   */\n  set layer(layer: number) {\n    this.properties.layer = layer;\n  }\n\n  /**\n   * This feature’s selection mode.\n   */\n  get selectionMode(): SelectionMode {\n    return this.properties.selectionMode;\n  }\n\n  /**\n   * Set this feature’s selection mode.\n   * @param mode The new mode.\n   */\n  set selectionMode(mode: SelectionMode) {\n    this.properties.selectionMode = mode;\n  }\n\n  /**\n   * Copy the data of the given feature.\n   * If the feature does not have a data object, nothing happens.\n   * @param feature The feature to copy the data of.\n   */\n  copyDataOf(feature: MapFeature<G, P>): void {\n    if (!feature.dataObject) {\n      return;\n    }\n    const expectedGeomType = this.geometry.type;\n    const actualGeomType = feature.dataObject.type.getGeometryType();\n    if (expectedGeomType !== actualGeomType) {\n      throw new TypeError(\n        `Invalid geometry type: expected \"${expectedGeomType}\", got \"${actualGeomType}\"`,\n      );\n    }\n    this.dataObject_ = feature.dataObject;\n    this.updateProperties();\n  }\n\n  /**\n   * Update this feature’s `properties` field.\n   */\n  abstract updateProperties(): void;\n}\n\n/**\n * A point feature represents a single point in space.\n *\n * Points may be isolated or bound to one or more {@link LinearFeature}s.\n * In the latter case, anytime a point is moved all its bound features are notified.\n */\nexport class Point extends MapFeature<GeoPoint, PointProperties> {\n  // @ts-expect-error Initialized in constructor through property setter\n  #lngLat: LngLat;\n  #boundFeatures = new Set<LinearFeature>();\n\n  /**\n   * Create a new point.\n   * @param id The ID for the map the point belongs to.\n   * @param dataTypesProvider A function that provides the given data type for a name and type string.\n   * @param coords The point’s coordinates.\n   * @param dbId The feature’s database ID.\n   * @param layer The z-order layer index.\n   * @param dataObject The attached object containing data.\n   */\n  constructor(\n    id: string,\n    dataTypesProvider: DataTypeProvider,\n    coords: LngLat,\n    dbId?: number,\n    layer?: number,\n    dataObject?: ObjectInstance,\n  ) {\n    super(\n      id,\n      dataTypesProvider,\n      {\n        type: \"Point\",\n        coordinates: [], // Updated immediately by this.lngLat()\n      },\n      dbId,\n      layer,\n      dataObject,\n    );\n    this.lngLat = coords;\n    this.updateProperties();\n  }\n\n  /**\n   * This point’s location.\n   * @returns A copy of the internal {@link LngLat} object.\n   */\n  get lngLat(): LngLat {\n    return copyLngLat(this.#lngLat);\n  }\n\n  /**\n   * Set this point’s location.\n   * @param lngLat This point’s new position.\n   */\n  set lngLat(lngLat: LngLat) {\n    this.#lngLat = copyLngLat(lngLat);\n    this.updateGeometry();\n  }\n\n  /**\n   * This point’s radius in pixels.\n   */\n  get radius(): number {\n    return this.properties.radius;\n  }\n\n  /**\n   * Set this point’s radius in pixel.s\n   * @param radius The new radius.\n   * @throws {Error} If the radius is less than 1.\n   */\n  set radius(radius: number) {\n    if (radius < 1) {\n      throw new Error(`Point radius is too small: ${radius}`);\n    }\n    this.properties.radius = radius;\n  }\n\n  /**\n   * A Set of all features this point is bound to.\n   */\n  get boundFeatures(): LinearFeature[] {\n    return [...this.#boundFeatures];\n  }\n\n  /**\n   * Bind this point to the given feature.\n   * @param feature The feature to bind this point to.\n   */\n  bindFeature(feature: LinearFeature) {\n    this.#boundFeatures.add(feature);\n    this.updateProperties();\n  }\n\n  /**\n   * Unbind this point from the given feature.\n   * @param feature The feature to unbind this point from.\n   */\n  unbindFeature(feature: LinearFeature) {\n    this.#boundFeatures.delete(feature);\n    this.updateProperties();\n  }\n\n  /**\n   * Called when this point is dragged on the map.\n   * @param mousePos The mouse location.\n   * @param offset The offset between the mouse position and this point’s current position.\n   */\n  onDrag(mousePos: LngLat, offset: LngLatVector = LngLatVector.ZERO): void {\n    this.#lngLat = offset.addTo(mousePos);\n    this.updateGeometry();\n  }\n\n  /**\n   * Update this point’s `geometry.coordinates` and `geometry.bbox` properties.\n   * Also calls the {@link LinearFeature.onVertexDrag} method on all bound features.\n   */\n  protected updateGeometry(): void {\n    this.geometry.coordinates = this.#lngLat.toArray();\n    const { lng, lat } = this.#lngLat;\n    this.geometry.bbox = [lng, lat, lng, lat];\n    this.#boundFeatures.forEach((f) => {\n      f.onVertexDrag(this);\n    });\n  }\n\n  updateProperties() {\n    this.properties.color =\n      this.#boundFeatures.size > 1 ? \"#bbbbbb\" : \"#ffffff\";\n    if (this.dataObject) {\n      this.properties.radius = 6;\n    } else if (\n      this.#boundFeatures.size === 0 ||\n      (this.#boundFeatures.size === 1 &&\n        [...this.boundFeatures].every(\n          (f) => f instanceof LineString && f.isEndVertex(this),\n        ))\n    ) {\n      this.properties.radius = 5;\n    } else {\n      this.properties.radius = 3.5;\n    }\n    // TODO set icon depending on objectData’s type\n  }\n}\n\nexport type LinearGeometry = GeoLineString | GeoPolygon;\n\nexport type Action = DoNothingAction | DeleteFeatureAction | DeleteRingAction;\n\nexport interface DoNothingAction {\n  type: \"do_nothing\";\n}\n\nexport interface DeleteFeatureAction {\n  type: \"delete_feature\";\n}\n\nexport interface DeleteRingAction {\n  type: \"delete_ring\";\n  ringIndex: number;\n  points: Point[];\n}\n\n/**\n * A linear feature is such that it is composed of one or more lines of {@link Point}s.\n *\n * Vertices can be interacted with through what are called **paths**.\n * A path is a string that represents successive indices through this feature’s lines to a specific vertex.\n * For more details see subclasses.\n * @see LineString\n * @see Polygon\n */\nexport abstract class LinearFeature<\n  G extends LinearGeometry = LinearGeometry,\n  P extends LinearProperties = LinearProperties,\n> extends MapFeature<G, P> {\n  /**\n   * Indicate whether this feature has any points.\n   * @returns True if this feature has no points, false otherwise.\n   */\n  abstract isEmpty(): boolean;\n\n  /**\n   * Check whether the given vertex can be appended in this feature at the given path.\n   * @param vertex The vertex to check.\n   * @param path The path.\n   * @returns True if the vertex can be appended at the given path, false otherwise.\n   */\n  abstract canAppendVertex(vertex: Point, path: string): boolean;\n\n  /**\n   * Append a vertex to this feature at the given path.\n   * @param vertex The vertex to append.\n   * @param path The path.\n   */\n  abstract appendVertex(vertex: Point, path: string): void;\n\n  /**\n   * Check whether this feature can accept the given vertex anywhere or at the given path.\n   * @param vertex The vertex to check.\n   * @param at The path where the vertex may be accepted, or null to check if the vertex may be accepted anywhere.\n   * @returns True if this feature is accepted, false otherwise.\n   */\n  abstract canAcceptVertex(vertex: Point, at?: string): boolean;\n\n  /**\n   * Replace a vertex of this feature by the specified one.\n   * @param newVertex The vertex to put in place of the second one.\n   * @param oldVertex The vertex to replace.\n   * @returns True if the vertex was replaced, false if it could not.\n   */\n  abstract replaceVertex(newVertex: Point, oldVertex: Point): void;\n\n  /**\n   * Check whether the given vertex can be inserted in this feature at the given path.\n   * @param vertex The vertex to check.\n   * @param path The path.\n   * @returns True if the vertex can be inserted at the given path, false otherwise.\n   */\n  abstract canInsertVertex(vertex: Point, path: string): boolean;\n\n  /**\n   * Insert the given vertex after the specified path.\n   * @param vertex The vertex to insert.\n   * @param path The path to insert the vertex after.\n   */\n  abstract insertVertexAfter(vertex: Point, path: string): void;\n\n  /**\n   * Remove the given vertex from this feature.\n   * @param vertex The vertex to remove.\n   * @returns The action to perform.\n   */\n  abstract removeVertex(vertex: Point): Action;\n\n  /**\n   * Get the vertex at the given path.\n   * @param path The path to the point.\n   * @returns The vertex for the path or null if none matched.\n   */\n  abstract getVertex(path: string): Point | null;\n\n  /**\n   * Get the vertices of the segment at the given path.\n   * @param path The path to the segment.\n   * @returns The vertices for the path or null if none matched.\n   */\n  abstract getSegmentVertices(path: string): [Point, Point] | null;\n\n  /**\n   * Increment the point index in the given path.\n   * @param path The path.\n   * @returns The incremented path or null if the given path is invalid.\n   */\n  abstract incrementPath(path: string): string | null;\n\n  /**\n   * Return the path of the segment formed by the two given points.\n   * @param v1 One vertex of the segment.\n   * @param v2 The other vertex of the segment.\n   * @returns The segment’s path or null if there is no segment for the two points.\n   */\n  abstract getSegmentPath(v1: Point, v2: Point): string | null;\n\n  /**\n   * Return the path of the given vertex.\n   * @param v The vertex to get the path of.\n   * @returns The path for the vertex or null if it is not present in this feature.\n   */\n  abstract getVertexPath(v: Point): string | null;\n\n  /**\n   * Return the path to the next possible vertex position on this feature’s outer line.\n   */\n  abstract getNextVertexPath(): string;\n\n  /**\n   * Called when one of the vertices of this feature is being dragged.\n   * @param draggedVertex The vertex being dragged.\n   */\n  onVertexDrag(draggedVertex: Point): void {\n    this.updateGeometry(draggedVertex);\n  }\n\n  static readonly CIRCULARITY_THRESHOLD: number = 0.6;\n\n  /**\n   * Indicate whether a ring of this feature is nearly circular.\n   *\n   * The circularity coefficient is derived from the formula by Cox (1927).\n   * @param ringIndex The index of the ring.\n   * @returns True if the circularity coefficient of the ring is greater than or equal to 0.6, false otherwise.\n   * @see Cox, E. P. (1927). A Method of Assigning Numerical and Percentage Values to the Degree\n   *  of Roundness of Sand Grains. Journal of Paleontology, 1(3), 179–183. http://www.jstor.org/stable/1298056\n   * @throws {Error} If the index is invalid.\n   */\n  isNearlyCircular(ringIndex: number): boolean {\n    return (\n      (4 * Math.PI * this.getArea(ringIndex)) /\n        this.getPerimeter(ringIndex) ** 2 >=\n      LinearFeature.CIRCULARITY_THRESHOLD\n    );\n  }\n\n  /**\n   * Calculate the area of the region enclosed by the given closed ring.\n   * @param ringIndex The index of the ring.\n   * @returns The area of the region.\n   * @throws {Error} If the index is invalid.\n   */\n  getArea(ringIndex: number): number {\n    return getPolygonArea(this.getRing(ringIndex));\n  }\n\n  /**\n   * Calculate the perimeter of the given closed ring.\n   * @param ringIndex The index of the ring.\n   * @returns The perimeter of the ring.\n   * @throws {Error} If the index is invalid.\n   */\n  getPerimeter(ringIndex: number): number {\n    return getPolygonPerimeter(this.getRing(ringIndex));\n  }\n\n  static readonly RIGHT_ANGLE_THRESHOLD: number = 5;\n\n  /**\n   * Indicate whether the given ring of this feature is nearly square,\n   * i.e. all its angles are nearly a multiple of 90°.\n   * @param ringIndex The index of the ring.\n   * @returns True if all angles at each vertex is a multiple of 90° ± 5°, false otherwise.\n   * @throws {Error} If the index is invalid.\n   */\n  isNearlySquare(ringIndex: number): boolean {\n    const ring = this.getRing(ringIndex);\n    for (let i = 0; i < ring.length; i++) {\n      const vPrev = i == 0 ? ring[ring.length - 1] : ring[i - 1];\n      const vCurr = ring[i];\n      const vNext = i == ring.length - 1 ? ring[0] : ring[i + 1];\n      const angle = turfAngle(vPrev, vCurr, vNext, { mercator: true }) % 90;\n      const t = LinearFeature.RIGHT_ANGLE_THRESHOLD;\n      if (angle > t && angle < 90 - t) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return the vertices of the ring at the given index.\n   * @param index The index of the ring.\n   * @returns The vertices of the given ring.\n   * @throws {Error} If the index is invalid.\n   */\n  protected abstract getRing(index: number): Point[];\n\n  /**\n   * Update this feature’s `geometry.coordinates` and `geometry.bbox` properties.\n   * @param draggedVertex If specified, the dragged vertex that induced this operation.\n   */\n  protected abstract updateGeometry(draggedVertex?: Point): void;\n}\n\nexport enum PolylineDirection {\n  FORWARD = 1,\n  BACKWARD = -1,\n}\n\n/**\n * A line string is a feature that is composed of segments represented by a list of {@link Point}s.\n *\n * A line string has a direction that is either:\n * * {@link PolylineDirection.FORWARD}: the line starts at vertex 0 towards the last one.\n * * {@link PolylineDirection.BACKWARD}: the line starts at its last vertex towards the first one.\n *\n * As a line string only contains a single vertex list, paths must respect the following format:\n * * `\"<nb>\"`, where `<nb>` is the index of the vertex/segment to target.\n */\nexport class LineString extends LinearFeature<\n  GeoLineString,\n  LineStringProperties\n> {\n  static readonly #PATH_PATTERN = /^(\\d+)$/;\n\n  readonly #vertices: Point[] = [];\n  #direction: PolylineDirection = PolylineDirection.FORWARD;\n\n  /**\n   * Create a line string.\n   * @param id The ID for the map the line belongs to.\n   * @param dataTypesProvider A function that provides the given data type for a name and type string.\n   * @param vertices Optional. A list of (at least 2) points. It must not contain any duplicates.\n   * @param dbId The feature’s database ID.\n   * @param layer The z-order layer index.\n   * @param dataObject The attached object containing data.\n   * @throws {Error} If a point is present multiple times in the list of points or the list contains less than 2 points.\n   */\n  constructor(\n    id: string,\n    dataTypesProvider: DataTypeProvider,\n    vertices?: Point[],\n    dbId?: number,\n    layer?: number,\n    dataObject?: ObjectInstance,\n  ) {\n    super(\n      id,\n      dataTypesProvider,\n      {\n        type: \"LineString\",\n        coordinates: [],\n      },\n      dbId,\n      layer,\n      dataObject,\n    );\n    if (vertices) {\n      if (vertices.length < 2)\n        throw new Error(\n          `Expected at least 2 points, got ${vertices.length} in linestring ${dbId}`,\n        );\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i];\n        const path = i.toString();\n        if (!this.canAppendVertex(vertex, path))\n          throw new Error(`Cannot append vertex ${vertex.id} at ${path}`);\n        this.appendVertex(vertex, path);\n      }\n    }\n    this.updateProperties();\n  }\n\n  /**\n   * An array containing this line’s vertices.\n   */\n  get vertices(): Point[] {\n    return [...this.#vertices];\n  }\n\n  /**\n   * This line’s width in pixels.\n   */\n  get width(): number {\n    return this.properties.width;\n  }\n\n  /**\n   * This line’s direction.\n   */\n  get direction(): PolylineDirection {\n    return this.#direction;\n  }\n\n  /**\n   * Set this line’s direction.\n   * @param d The new direction.\n   */\n  set direction(d: PolylineDirection) {\n    this.#direction = d;\n  }\n\n  isEmpty(): boolean {\n    return this.#vertices.length === 0;\n  }\n\n  canAppendVertex(vertex: Point, path: string): boolean {\n    if (!this.canAcceptVertex(vertex)) {\n      return false;\n    }\n    const i = this.#getVertexIndex(path);\n    return i !== null && (i === 0 || i === this.#vertices.length);\n  }\n\n  appendVertex(vertex: Point, path: string): void {\n    if (!this.canAppendVertex(vertex, path)) {\n      return;\n    }\n    if (this.#getVertexIndex(path) === 0) {\n      this.#vertices.unshift(vertex);\n    } else {\n      this.#vertices.push(vertex);\n    }\n    vertex.bindFeature(this);\n    this.updateGeometry();\n  }\n\n  canAcceptVertex(vertex: Point, at?: string | null): boolean {\n    const i = this.#vertices.indexOf(vertex);\n    if (i === -1) {\n      return true;\n    }\n    if (!at || this.isLoop()) {\n      return false;\n    }\n    const atI = this.#getVertexIndex(at);\n    if (atI === null || Math.abs(i - atI) <= 2) {\n      // Cannot accept if vertices have not at least two other vertices in-between\n      return false;\n    }\n    const lastI = this.#vertices.length - 1;\n    // Allow first vertex to snap to last vertex and vice-versa\n    return (i === 0 && atI === lastI) || (i === lastI && atI === 0);\n  }\n\n  replaceVertex(newVertex: Point, oldVertex: Point): void {\n    if (!this.canAcceptVertex(newVertex, this.getVertexPath(oldVertex))) {\n      return;\n    }\n    // Replace everywhere\n    let i = this.#vertices.indexOf(oldVertex);\n    do {\n      this.#vertices[i] = newVertex;\n      i = this.#vertices.indexOf(oldVertex);\n    } while (i !== -1);\n    newVertex.bindFeature(this);\n    oldVertex.unbindFeature(this);\n    this.updateGeometry();\n  }\n\n  canInsertVertex(vertex: Point, path: string): boolean {\n    if (!this.canAcceptVertex(vertex)) return false;\n    const i = this.#getVertexIndex(path);\n    // Cannot insert after last vertex\n    return i !== null && i < this.#vertices.length - 1;\n  }\n\n  insertVertexAfter(vertex: Point, path: string): void {\n    if (!this.canInsertVertex(vertex, path)) return;\n    const i = this.#getVertexIndex(path);\n    if (i === null) return;\n    this.#vertices.splice(i + 1, 0, vertex);\n    vertex.bindFeature(this);\n    this.updateGeometry();\n  }\n\n  removeVertex(vertex: Point): Action {\n    let i = this.#vertices.indexOf(vertex);\n    if (i !== -1) {\n      if (\n        this.#vertices.length <= 2 ||\n        (this.isLoop() && this.#vertices.length === 3)\n      ) {\n        return { type: \"delete_feature\" };\n      }\n      // Vertex may be present twice if this is a loop\n      do {\n        this.#vertices.splice(i, 1);\n        i = this.#vertices.indexOf(vertex);\n      } while (i !== -1);\n      vertex.unbindFeature(this);\n      this.updateGeometry();\n    }\n    return { type: \"do_nothing\" };\n  }\n\n  getVertex(path: string): Point | null {\n    const index = this.#getVertexIndex(path);\n    if (index !== null && index < this.#vertices.length) {\n      return this.#vertices[index];\n    } else {\n      return null;\n    }\n  }\n\n  getSegmentVertices(path: string): [Point, Point] | null {\n    const index = this.#getVertexIndex(path);\n    if (index !== null && index < this.#vertices.length - 1) {\n      return [this.#vertices[index], this.#vertices[index + 1]];\n    } else {\n      return null;\n    }\n  }\n\n  incrementPath(path: string): string | null {\n    const index = this.#getVertexIndex(path);\n    if (index !== null) {\n      return ((index + 1) % this.#vertices.length).toString();\n    } else {\n      return null;\n    }\n  }\n\n  getSegmentPath(v1: Point, v2: Point): string | null {\n    const i1 = this.#vertices.indexOf(v1);\n    const i2 = this.#vertices.indexOf(v2);\n    if (i1 !== -1 && i2 !== -1) {\n      if (i1 === i2 - 1) return i1.toString();\n      else if (i2 === i1 - 1) return i2.toString();\n    }\n    return null;\n  }\n\n  getVertexPath(v: Point): string | null {\n    const i = this.#vertices.indexOf(v);\n    return i !== -1 ? i.toString() : null;\n  }\n\n  getNextVertexPath(): string {\n    return this.#vertices.length.toString();\n  }\n\n  /**\n   * Check whether the given vertex is at one of the two ends of this line.\n   * @param v The vertex to check.\n   * @returns True if the vertex is the first or last one, false otherwise.\n   */\n  isEndVertex(v: Point): boolean {\n    if (this.isLoop()) {\n      return false;\n    }\n    const i = this.#vertices.indexOf(v);\n    return i === 0 || i === this.#vertices.length - 1;\n  }\n\n  /**\n   * Indicate whether this line forms a loop, i.e. it has more than one vertex\n   * and its first and last vertex are the same.\n   */\n  isLoop(): boolean {\n    return (\n      this.#vertices.length > 1 &&\n      this.#vertices[0] === this.#vertices[this.#vertices.length - 1]\n    );\n  }\n\n  isNearlyCircular(ringIndex: number): boolean {\n    return this.isLoop() && super.isNearlyCircular(ringIndex);\n  }\n\n  getArea(ringIndex: number): number {\n    if (!this.isLoop()) {\n      throw new Error(\"LineString is not a loop\");\n    }\n    return super.getArea(ringIndex);\n  }\n\n  getPerimeter(ringIndex: number): number {\n    if (!this.isLoop()) {\n      throw new Error(\"LineString is not a loop\");\n    }\n    return super.getPerimeter(ringIndex);\n  }\n\n  isNearlySquare(ringIndex: number): boolean {\n    return this.isLoop() && super.isNearlySquare(ringIndex);\n  }\n\n  protected getRing(index: number): Point[] {\n    if (index !== 0) {\n      throw new Error(`Invalid ring index: ${index}`);\n    }\n    // Discard last vertex\n    return this.#vertices.slice(0, this.#vertices.length - 1);\n  }\n\n  /**\n   * Indicate whether this line is nearly straight.\n   */ // TODO what does that mean?\n  isNearlyStraight(): boolean {\n    return false; // TODO\n  }\n\n  protected updateGeometry(draggedVertex?: Point): void {\n    this.geometry.coordinates = [];\n    let west = Infinity,\n      south = Infinity,\n      east = -Infinity,\n      north = -Infinity;\n    for (const vertex of this.#vertices) {\n      const { lng, lat } = vertex.lngLat;\n      this.geometry.coordinates.push([lng, lat]);\n      west = Math.min(lng, west);\n      south = Math.min(lat, south);\n      east = Math.max(lng, east);\n      north = Math.max(lat, north);\n    }\n    this.geometry.bbox = [west, south, east, north];\n    if (draggedVertex) {\n      draggedVertex.updateProperties();\n    } else {\n      this.#vertices.forEach((v) => {\n        v.updateProperties();\n      });\n    }\n  }\n\n  updateProperties() {\n    if (!this.dataObject) {\n      this.properties.width = 2;\n      this.properties.color = \"#ffffff\";\n      this.properties.dash = null;\n      this.properties.fgColor = \"#ffffff\";\n      this.properties.fgWidth = 0;\n      this.properties.fgDash = null;\n    } else {\n      if (\n        this.dataObject.isInstanceOf(\n          this.dataTypesProvider(\"track_section\", \"ObjectType\"),\n        )\n      ) {\n        this.properties.width = 6;\n        if (\n          this.dataObject.isInstanceOf(\n            this.dataTypesProvider(\"conventional_track_section\", \"ObjectType\"),\n          )\n        ) {\n          const gauges = this.dataObject.getPropertyValues(\n            \"gauges\",\n          ) as number[];\n          const normalOrBroadGauge = gauges.some((g) => g >= 1435);\n          if (normalOrBroadGauge) {\n            this.properties.width = 8;\n          }\n        }\n        this.properties.dash = null;\n        this.properties.fgWidth = 2;\n        this.properties.fgDash = [4, 4];\n        let color: string;\n        switch (this.dataObject.getPropertyValue(\"level\")) {\n          case \"bridge\":\n            color = \"#131313\";\n            break;\n          case \"tunnel\":\n            color = \"#9b9b9b\";\n            break;\n          case \"surface\":\n          default:\n            color = \"#3d3d3d\";\n            break;\n        }\n        this.properties.color = color;\n        this.properties.fgColor = \"#ffffff\";\n      }\n    }\n  }\n\n  /**\n   * Convert a path to a vertex index.\n   * @param path The path to convert.\n   * @returns The corresponding index or null if the path is malformed.\n   */\n  #getVertexIndex(path: string): number | null {\n    const m = LineString.#PATH_PATTERN.exec(path);\n    return m ? +m[1] : null;\n  }\n}\n\n/**\n * A polygon is a feature that is composed of closed lines (rings), each represented by a list of {@link Point}s.\n * The ring with index 0 represents the outside perimeter of the polygon while all others represent holes.\n *\n * As such, paths must respect the following format:\n * * `\"<ring>.<vertex>\"`, where `<ring>` is the index of a ring\n *   and `<vertex>` is the index of the vertex/segment to target in that ring.\n *\n * Unlike {@link LineString}s, vertices cannot be added to a polygon’s rings after they have been locked.\n * A ring usually becomes locked whenever a user finished drawing it.\n */\nexport class Polygon extends LinearFeature<GeoPolygon> {\n  static readonly #PATH_PATTERN = /^(\\d+)\\.(\\d+)$/;\n\n  readonly #vertices: Point[][] = [];\n  /**\n   * Indicates for each ring whether it is locked (true) or not (false).\n   */\n  readonly #lockStatus: boolean[] = [];\n\n  /**\n   * Create a polygon.\n   * @param id The ID for the map the polygon belongs to.\n   * @param dataTypesProvider A function that provides the given data type for a name and type string.\n   * @param vertices Optional. A list of point lists that should each contain at least 3 points.\n   * It must not contain any duplicates. Each sublist represents a ring.\n   * @param dbId The feature’s database ID.\n   * @param layer The z-order layer index.\n   * @param dataObject The attached object containing data.\n   * @throws {Error} If a point is present multiple times in the lists or a list contains less than 3 points.\n   */\n  constructor(\n    id: string,\n    dataTypesProvider: DataTypeProvider,\n    vertices?: Point[][],\n    dbId?: number,\n    layer?: number,\n    dataObject?: ObjectInstance,\n  ) {\n    super(\n      id,\n      dataTypesProvider,\n      {\n        type: \"Polygon\",\n        coordinates: [[]],\n      },\n      dbId,\n      layer,\n      dataObject,\n    );\n    if (vertices) {\n      // Separate loop to avoid binding vertices unnecessarily\n      for (let i = 0; i < vertices.length; i++) {\n        const ring = vertices[i];\n        if (ring.length < 3) {\n          throw new Error(\n            `Expected at least 3 points, got ${ring.length} in ring ${i} of polygon ${dbId}`,\n          );\n        }\n      }\n      for (let ringI = 0; ringI < vertices.length; ringI++) {\n        const ring = vertices[ringI];\n        for (let vertexI = 0; vertexI < ring.length; vertexI++) {\n          const vertex = ring[vertexI];\n          const path = `${ringI}.${vertexI}`;\n          if (!this.canAppendVertex(vertex, path)) {\n            throw new Error(`Cannot append vertex ${vertex.id} at ${path}`);\n          }\n          this.appendVertex(vertex, path);\n        }\n        this.lockRing(ringI);\n        ring.forEach((v) => {\n          v.updateProperties();\n        }); // Refresh properties of all vertices\n      }\n    } else {\n      // Unlock exterior ring for later drawing\n      this.#lockStatus.push(false);\n    }\n    this.updateProperties();\n  }\n\n  /**\n   * This polygon’s vertices as a two-dimensional array. Each sub-array corresponds to a ring.\n   * The first ring is always the outermost one.\n   */\n  get vertices(): Point[][] {\n    const rings: Point[][] = [];\n    for (const ring of this.#vertices) rings.push([...ring]);\n    return rings;\n  }\n\n  /**\n   * Indicate whether the given ring is locked.\n   * @param index Index of the ring to check.\n   * @returns True if the ring can no longer be modified, false if it still can or does not exist.\n   */\n  isRingLocked(index: number): boolean {\n    return this.#lockStatus[index] ?? false;\n  }\n\n  /**\n   * Lock the ring at the given index, rendering it permanently non-editable.\n   * Does nothing if the ring does not exist.\n   * @param index Index of the ring to lock.\n   */\n  lockRing(index: number): void {\n    if (typeof this.#lockStatus[index] !== \"undefined\") {\n      this.#lockStatus[index] = true;\n    }\n  }\n\n  isEmpty(): boolean {\n    return !this.#vertices[0] || this.#vertices[0].length === 0;\n  }\n\n  canAppendVertex(vertex: Point, path: string): boolean {\n    const indices = this.#getVertexIndex(path);\n    if (\n      !this.canAcceptVertex(vertex) ||\n      indices === null ||\n      this.isRingLocked(indices[0])\n    )\n      return false;\n    return (\n      (indices[0] < this.#vertices.length &&\n        (indices[1] === 0 ||\n          indices[1] === this.#vertices[indices[0]].length)) ||\n      (indices[0] === this.#vertices.length && indices[1] === 0)\n    );\n  }\n\n  appendVertex(vertex: Point, path: string): void {\n    if (!this.canAppendVertex(vertex, path)) return;\n    const i = this.#getVertexIndex(path);\n    if (i === null) return;\n    const [ringI, vertexI] = i;\n    let ring: Point[];\n    if (ringI === this.#vertices.length) {\n      this.#vertices.push((ring = []));\n      this.#lockStatus.push(false); // Make new ring drawable\n    } else {\n      ring = this.#vertices[ringI];\n    }\n    if (vertexI === 0) {\n      ring.unshift(vertex);\n    } else {\n      ring.push(vertex);\n    }\n    vertex.bindFeature(this);\n    this.updateGeometry();\n  }\n\n  canAcceptVertex(vertex: Point): boolean {\n    return !this.#vertices.some((ring) => ring.includes(vertex));\n  }\n\n  replaceVertex(newVertex: Point, oldVertex: Point): void {\n    if (!this.canAcceptVertex(newVertex)) return;\n    for (const ring of this.#vertices) {\n      const i = ring.indexOf(oldVertex);\n      if (i !== -1) {\n        ring[i] = newVertex;\n        newVertex.bindFeature(this);\n        oldVertex.unbindFeature(this);\n        this.updateGeometry();\n        return;\n      }\n    }\n  }\n\n  canInsertVertex(vertex: Point, path: string): boolean {\n    if (!this.canAcceptVertex(vertex)) {\n      return false;\n    }\n    const indices = this.#getVertexIndex(path);\n    return (\n      indices !== null &&\n      indices[0] < this.#vertices.length &&\n      indices[1] < this.#vertices[indices[0]].length\n    );\n  }\n\n  insertVertexAfter(vertex: Point, path: string): void {\n    if (!this.canInsertVertex(vertex, path)) return;\n    const i = this.#getVertexIndex(path);\n    if (i === null) return;\n    const [ringI, vertexI] = i;\n    vertex.bindFeature(this);\n    const ring = this.#vertices[ringI];\n    if (vertexI === ring.length - 1) {\n      ring.push(vertex);\n    } else {\n      ring.splice(vertexI + 1, 0, vertex);\n    }\n    this.updateGeometry();\n  }\n\n  removeVertex(vertex: Point): Action {\n    for (let ringI = 0; ringI < this.#vertices.length; ringI++) {\n      const ring = this.#vertices[ringI];\n      const i = ring.indexOf(vertex);\n      if (i !== -1) {\n        if (ring.length <= 3) {\n          if (ringI === 0) {\n            return { type: \"delete_feature\" };\n          }\n          return { type: \"delete_ring\", ringIndex: ringI, points: ring };\n        }\n        ring.splice(i, 1);\n        vertex.unbindFeature(this);\n        this.updateGeometry();\n        return { type: \"do_nothing\" };\n      }\n    }\n    return { type: \"do_nothing\" };\n  }\n\n  getVertex(path: string): Point | null {\n    const indices = this.#getVertexIndex(path);\n    if (\n      indices !== null &&\n      indices[0] < this.#vertices.length &&\n      indices[1] < this.#vertices[indices[0]].length\n    ) {\n      return this.#vertices[indices[0]][indices[1]];\n    } else {\n      return null;\n    }\n  }\n\n  getSegmentVertices(path: string): [Point, Point] | null {\n    const indices = this.#getVertexIndex(path);\n    if (\n      indices !== null &&\n      indices[0] < this.#vertices.length &&\n      indices[1] < this.#vertices[indices[0]].length\n    ) {\n      const ring = this.#vertices[indices[0]];\n      return [ring[indices[1]], ring[(indices[1] + 1) % ring.length]];\n    } else {\n      return null;\n    }\n  }\n\n  incrementPath(path: string): string | null {\n    const indices = this.#getVertexIndex(path);\n    if (indices !== null && indices[0] < this.#vertices.length) {\n      return `${indices[0]}.${(indices[1] + 1) % this.#vertices[indices[0]].length}`;\n    } else {\n      return null;\n    }\n  }\n\n  getSegmentPath(v1: Point, v2: Point): string | null {\n    for (const ring of this.#vertices) {\n      const i1 = ring.indexOf(v1);\n      const i2 = ring.indexOf(v2);\n      if (i1 !== -1 && i2 !== -1) {\n        if (i1 === i2 - 1) {\n          return i1.toString();\n        } else if (i2 === i1 - 1) {\n          return i2.toString();\n        }\n        break;\n      } else if ((i1 === -1 && i2 !== -1) || (i1 !== -1 && i2 === -1)) {\n        // Vertices are not on the same ring, no need to search further\n        break;\n      }\n    }\n    return null;\n  }\n\n  getVertexPath(v: Point): string | null {\n    for (let ringI = 0; ringI < this.#vertices.length; ringI++) {\n      const i = this.#vertices[ringI].indexOf(v);\n      if (i !== -1) {\n        return `${ringI}.${i}`;\n      }\n    }\n    return null;\n  }\n\n  getNextVertexPath(): string {\n    return `0.${this.#vertices[0]?.length ?? 0}`;\n  }\n\n  /**\n   * Delete the ring with the given index.\n   * All points of the specified rings will be unbound from this feature.\n   * If the index is 0 or ≥ to the number of rings, nothing happens.\n   * @param index The index of the ring to delete.\n   */\n  deleteRing(index: number): void {\n    if (0 < index && index < this.#vertices.length) {\n      this.#vertices[index].forEach((v) => {\n        v.unbindFeature(this);\n      });\n      this.#vertices.splice(index, 1);\n      this.updateGeometry();\n    }\n  }\n\n  protected getRing(index: number): Point[] {\n    const ring = this.#vertices[index];\n    if (typeof ring !== \"undefined\")\n      throw new Error(`Invalid ring index: ${index}`);\n    return [...ring];\n  }\n\n  protected updateGeometry(draggedVertex?: Point): void {\n    this.geometry.coordinates = [];\n    let west = Infinity,\n      south = Infinity,\n      east = -Infinity,\n      north = -Infinity;\n    for (const ring of this.#vertices) {\n      const points: [number, number][] = [];\n      for (const vertex of ring) {\n        const { lng, lat } = vertex.lngLat;\n        points.push([lng, lat]);\n        west = Math.min(lng, west);\n        south = Math.min(lat, south);\n        east = Math.max(lng, east);\n        north = Math.max(lat, north);\n      }\n      // Add first point at the end as GeoJSON requires\n      points.push(ring[0].lngLat.toArray());\n      this.geometry.coordinates.push(points);\n    }\n    this.geometry.bbox = [west, south, east, north];\n    if (draggedVertex) {\n      draggedVertex.updateProperties();\n    } else {\n      this.#vertices.forEach((ring) => {\n        ring.forEach((v) => {\n          v.updateProperties();\n        });\n      });\n    }\n  }\n\n  updateProperties() {\n    // TODO\n  }\n\n  /**\n   * Convert a path to ring and vertex indices.\n   * @param path The path to convert.\n   * @returns The corresponding ring and vertex indices or null if the path is malformed.\n   */\n  #getVertexIndex(path: string): [number, number] | null {\n    const m = Polygon.#PATH_PATTERN.exec(path);\n    return m ? [+m[1], +m[2]] : null;\n  }\n}\n\n/**\n * Notes are used to leave comments on geometries.\n */\nexport class Note {\n  readonly #date: Date;\n  /**\n   * The username of the author that wrote this note.\n   */\n  readonly authorName: string;\n  /**\n   * This note’s text.\n   */\n  readonly text: string;\n  readonly #geometries = new Set<MapFeature>();\n\n  /**\n   * Create a new note.\n   * @param date The date the note was published on.\n   * @param authorName The username of the author that wrote the note.\n   * @param text The note’s text.\n   * @param geometries The geometries the note is linked to.\n   */\n  constructor(\n    date: Date,\n    authorName: string,\n    text: string,\n    geometries: Iterable<MapFeature>,\n  ) {\n    this.#date = date;\n    this.authorName = authorName;\n    this.text = text;\n    this.#geometries = new Set(geometries);\n  }\n\n  /**\n   * The date this note was published on.\n   */\n  get date(): Date {\n    return new Date(this.#date.getTime());\n  }\n\n  /**\n   * The geometries this note is linked to.\n   * @returns An array of all geometries this note is linked to.\n   */\n  get geometries(): MapFeature[] {\n    return [...this.#geometries];\n  }\n}\n\n/**\n * Calculate the area of the polygon formed by the given array of {@link Point}s.\n * @param vertices The array of vertices, without repeating the first one at the end.\n * @returns The area of the polygon.\n */\nexport function getPolygonArea(vertices: Point[]): number {\n  return area(toPolygon(vertices));\n}\n\n/**\n * Calculate the perimeter of the polygon formed by the given array of {@link Point}s.\n * @param vertices The array of vertices, without repeating the first one at the end.\n * @returns The perimeter of the polygon.\n */\nexport function getPolygonPerimeter(vertices: Point[]): number {\n  return length(toPolygon(vertices), { units: \"meters\" });\n}\n\n/**\n * Convert an array of {@link Point}s to a Turf polygon feature.\n * @param vertices The array of vertices, without repeating the first one at the end.\n * @returns A Turf polygon feature.\n */\nfunction toPolygon(vertices: Point[]): Feature<GeoPolygon> {\n  return polygon([[...vertices, vertices[0]].map((v) => v.lngLat.toArray())]);\n}\n","import { DateInterval } from \"./date-interval\";\n\n/**\n * This class represents a unit type (e.g. length, speed, etc.).\n */\nexport class UnitType {\n  /**\n   * This unit type’s internal label.\n   */\n  readonly label: string;\n  /**\n   * This unit type’s localized label.\n   */\n  readonly localizedName: string;\n\n  readonly #units = new Set<Unit>();\n\n  /**\n   * Create a new enum type.\n   * @param label The enum’s label.\n   * @param localizedName The enum’s localized label.\n   */\n  constructor(label: string, localizedName: string) {\n    this.label = label;\n    this.localizedName = localizedName;\n  }\n\n  /**\n   * This type’s units.\n   * @returns A Set of this type’s units.\n   */\n  get units(): Set<Unit> {\n    return new Set(this.#units);\n  }\n\n  /**\n   * Add a {@link Unit} to this type.\n   * @param unit The unit to add.\n   * @throws {TypeError} If the type of the given unit is not this type.\n   */\n  addUnit(unit: Unit): void {\n    if (unit.type !== this)\n      throw new TypeError(\n        `Invalid unit type: expected \"${this.label}\", got \"${unit.type.label}\"`,\n      );\n    this.#units.add(unit);\n  }\n}\n\n/**\n * This class represents a specific unit of a certain type (e.g. km for length, km/h for speed, etc.).\n */\nexport class Unit {\n  /**\n   * This unit’s type.\n   */\n  readonly type: UnitType;\n  /**\n   * This unit’s symbol.\n   */\n  readonly symbol: string;\n  /**\n   * Whether this unit is the default one for its type.\n   */\n  readonly isDefault: boolean;\n\n  /**\n   * Create a new unit.\n   * @param type The unit’s type.\n   * @param symbol The unit’s symbol.\n   * @param isDefault Whether the unit is the default one for its type.\n   */\n  constructor(type: UnitType, symbol: string, isDefault: boolean) {\n    this.type = type;\n    this.symbol = symbol;\n    this.isDefault = isDefault;\n  }\n}\n\n/**\n * Enum values are objects that map each value to its translation in the page’s current language.\n */\nexport type EnumValues = Record<string, string>;\n\n/**\n * This class represents an enumeration with its label and values.\n */\nexport class Enum {\n  /**\n   * This enum’s internal label.\n   */\n  readonly label: string;\n  /**\n   * This enum’s localized label.\n   */\n  readonly localizedName: string;\n\n  readonly #values: EnumValues;\n\n  /**\n   * Create a new enum type.\n   * @param label The enum’s label.\n   * @param localizedName The enum’s localized label.\n   * @param values The enum’s values with their translations. Must contain at least one value.\n   * @throws {Error} If no values were provided.\n   */\n  constructor(label: string, localizedName: string, values: EnumValues) {\n    this.label = label;\n    this.localizedName = localizedName;\n    this.#values = { ...values };\n    if (this.values.length === 0)\n      throw new Error(`Empty enumeration \"${label}\"`);\n  }\n\n  /**\n   * An array of this enum’s values, in no particular order.\n   */\n  get values(): string[] {\n    return Object.keys(this.#values);\n  }\n\n  /**\n   * An array of this enum’s values and their translations.\n   * @returns An array of string pairs, each containing a value and its translation in this order.\n   */\n  get valuesTranslations(): [string, string][] {\n    return Object.entries(this.#values);\n  }\n}\n\ntype GeometryType = \"Point\" | \"LineString\" | \"Polygon\" | null;\n\n/**\n * This class represents the type of an object.\n *\n * An `ObjectType` may inherit from another if its `parentType` property is not `null`.\n * In that case, it inherits all properties of this parent type and all of the latter’s parents’.\n */\nexport class ObjectType {\n  /**\n   * This type’s internal label.\n   */\n  readonly label: string;\n  /**\n   * This type’s localized label.\n   */\n  readonly localizedName: string;\n  /**\n   * The type this one inherits from. May be null.\n   */\n  readonly parentType: ObjectType | null;\n  /**\n   * Whether this type is deprecated, i.e. whether it should no longer be used.\n   */\n  readonly isDeprecated: boolean;\n  /**\n   * Whether this type may be the target of a {@link TemporalProperty}.\n   */\n  readonly isTemporal: boolean;\n\n  readonly #geometryType: GeometryType | null;\n  readonly #properties = new Map<string, ObjectProperty<unknown>>();\n\n  /**\n   * Create a new object type.\n   * @param label The type’s internal label.\n   * @param localizedName The type’s localized label.\n   * @param parentType The type’s parent type. May be null.\n   * @param geometryType The type of geometry the object may be associated to.\n   *  May be null for types that should not be associated to geometries (e.g. relations, operators, etc.).\n   * @param temporal Whether this type may be the target of a {@link TemporalProperty}.\n   * @param deprecated Whether this type is deprecated, i.e. whether it should no longer be used.\n   */\n  constructor(\n    label: string,\n    localizedName: string,\n    parentType: ObjectType | null = null,\n    geometryType: GeometryType = null,\n    temporal = false,\n    deprecated = false,\n  ) {\n    this.label = label;\n    this.localizedName = localizedName;\n    this.parentType = parentType;\n    this.isTemporal = temporal;\n    this.isDeprecated = deprecated;\n    this.#geometryType = geometryType;\n  }\n\n  /**\n   * The properties of this object type and its parents’.\n   * @returns An array of this type’s properties.\n   */\n  get properties(): ObjectProperty<unknown>[] {\n    const properties: ObjectProperty<unknown>[] = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let type: ObjectType | null = this;\n    do {\n      properties.splice(0, 0, ...type.#properties.values()); // Insert first\n      type = type.parentType;\n    } while (type);\n    return properties;\n  }\n\n  /**\n   * Get the {@link ObjectProperty} object for the given name.\n   * If this object does not possess a property with that name,\n   * it is looked for in this object’s parent type hierarchy.\n   * @param name The property’s name.\n   * @returns {} The {@link ObjectProperty} object for that name\n   *  or null if neither this type nor any of its parents\n   *  possess a property for that name.\n   */\n  getProperty(name: string): ObjectProperty<unknown> | null {\n    const property = this.#properties.get(name);\n    if (!property && this.parentType) return this.parentType.getProperty(name);\n    return property ?? null;\n  }\n\n  /**\n   * Add the given {@link ObjectProperty} to this object type.\n   * @param p The property to add.\n   * @throws {TypeError} If the `objectType` property of the given property is not this type.\n   * @throws {Error} If this object or any of its parents already possesses a property with the exact same `label`.\n   */\n  addProperty(p: ObjectProperty<unknown>): void {\n    if (p.objectType !== this)\n      throw new TypeError(\n        `Expected type \"${this.label}\", got \"${p.objectType.label}\"`,\n      );\n    if (this.getProperty(p.label))\n      throw new Error(\n        `Object type ${this.label} already has a property named \"${p.label}\"`,\n      );\n    this.#properties.set(p.label, p);\n  }\n\n  /**\n   * Check whether this object type is the same as the given one or a sub-type.\n   * @param other The type to check.\n   * @returns True if this type or any of its parent types is the same (according to `===`) as the given one.\n   */\n  isSameOrSubtypeOf(other: ObjectType): boolean {\n    return (\n      this === other || (this.parentType?.isSameOrSubtypeOf(other) ?? false)\n    );\n  }\n\n  /**\n   * The type of geometry this object type may be associated to.\n   */\n  getGeometryType(): GeometryType {\n    return this.#geometryType ?? this.parentType?.getGeometryType() ?? null;\n  }\n}\n\n/**\n * This class represents the definition of a property that can be attached to an {@link ObjectType}.\n *\n * `ObjectProperty`s know which {@link ObjectType} they are attached to.\n */\nexport abstract class ObjectProperty<T> {\n  /**\n   * The {@link ObjectType} this property is attached to.\n   */\n  readonly objectType: ObjectType;\n  /**\n   * This property’s name prefixed with the object type it is bound to.\n   */\n  readonly fullName: string;\n  /**\n   * This property’s label.\n   */\n  readonly label: string;\n  /**\n   * This property’s localized label.\n   */\n  readonly localizedName: string;\n  /**\n   * Indicates whether this property may have a single value (`true`) or several (`false`).\n   */\n  readonly isUnique: boolean;\n  /**\n   * Indicates whether this property is deprecated, i.e. whether it should no longer be used.\n   */\n  readonly isDeprecated: boolean;\n\n  /**\n   * Create an new object property.\n   * @param objectType The {@link ObjectType} the property should be attached to.\n   * @param label The property’s label.\n   * @param localizedName The property’s localized label.\n   * @param unique Whether this property may have a single value (`true`) or several (`false`).\n   * @param deprecated Whether this property is deprecated, i.e. whether it should no longer be used.\n   */\n  constructor(\n    objectType: ObjectType,\n    label: string,\n    localizedName: string,\n    unique: boolean,\n    deprecated: boolean,\n  ) {\n    this.objectType = objectType;\n    this.fullName = `${objectType.label}.${label}`;\n    this.label = label;\n    this.localizedName = localizedName;\n    this.isUnique = unique;\n    this.isDeprecated = deprecated;\n  }\n\n  /**\n   * Check whether the given property value(s) is(are) compatible with this object property.\n   *\n   * A value is considered compatible if it is bound to a property with the same label,\n   * this property’s unicity matches the given property’s unicity, and all values’ types are compatible.\n   * @param propertyValue The property value(s) to check.\n   * @returns True if the given value(s) is(are) compatible, false otherwise.\n   */\n  isValueCompatible(\n    propertyValue: PropertyValue<unknown, ObjectProperty<unknown>>,\n  ): boolean {\n    return (\n      this.label === propertyValue.propertyType.label &&\n      this.isUnique === propertyValue.propertyType.isUnique &&\n      ((!propertyValue.propertyType.isUnique &&\n        propertyValue.values.every((v) => this.isValueValid(v))) ||\n        (propertyValue.propertyType.isUnique &&\n          this.isValueValid(propertyValue.value)))\n    );\n  }\n\n  /**\n   * Check whether the given value is valid for this property.\n   * @param v The value to check.\n   * @returns True if the given value is valid, false otherwise.\n   * @apiNotes Implementations should check the actual type of the passed value\n   *  as at runtime it may not always match the argument’s declared type.\n   */\n  abstract isValueValid(v: unknown): boolean;\n\n  /**\n   * Create a new {@link PropertyValue} for this property.\n   * @param value The initial value.\n   * @returns A new {@link PropertyValue}.\n   */\n  abstract newValue(value: T): PropertyValue<T, ObjectProperty<T>>;\n}\n\n/**\n * This class represents a value or set of values bound to an {@link ObjectProperty} definition.\n */\nexport abstract class PropertyValue<T, OP extends ObjectProperty<T>> {\n  /**\n   * The {@link ObjectProperty} definition for this value.\n   */\n  readonly propertyType: OP;\n  readonly #values: T[] = [];\n\n  constructor(propertyType: OP, ...values: T[]) {\n    this.propertyType = propertyType;\n    if (values.length === 0)\n      throw new Error(\n        `Missing value for property ${this.propertyType.fullName}`,\n      );\n    if (propertyType.isUnique) {\n      if (values.length !== 1)\n        throw new Error(\n          `Property ${this.propertyType.fullName} expected 1 value, got ${values.length}`,\n        );\n      this.value = values[0];\n    } else this.values = values;\n  }\n\n  /**\n   * The value bound to this property.\n   * @throws {TypeError} If the property is not unique.\n   */\n  get value(): T {\n    this.#ensureUnique();\n    return this.#values[0];\n  }\n\n  /**\n   * Set the value bound to this property.\n   * @param value The value to bind.\n   * @throws {Error} If the value is invalid for the property.\n   * @throws {TypeError} If the property is not unique.\n   */\n  set value(value: T) {\n    this.#ensureUnique();\n    this.#ensureValid(value);\n    this.#values[0] = value;\n  }\n\n  /**\n   * The values bound to this property.\n   * @throws {TypeError} If the property is unique.\n   */\n  get values(): T[] {\n    this.#ensureNotUnique();\n    return [...this.#values];\n  }\n\n  /**\n   * Set the values bound to this property.\n   * @throws {TypeError} If the property is unique.\n   */\n  set values(values: T[]) {\n    this.#ensureNotUnique();\n    values.forEach((v) => {\n      this.#ensureValid(v);\n    });\n    this.#values.splice(0, this.#values.length, ...values);\n  }\n\n  /**\n   * Bind a value to the property.\n   * @param value The value to bind.\n   * @throws {Error} If the value is invalid for the property.\n   * @throws {TypeError} If the property is unique.\n   */\n  addValue(value: T): void {\n    this.#ensureNotUnique();\n    this.#ensureValid(value);\n    this.#values.push(value);\n  }\n\n  /**\n   * Unbind the given value from the property.\n   * Does nothing if the value is not bound to the property.\n   * @param value The value to unbind.\n   * @throws {Error} If the value is invalid for the property.\n   * @throws {TypeError} If the property is unique.\n   */\n  removeValue(value: T): void {\n    this.#ensureNotUnique();\n    this.#ensureValid(value);\n    const i = this.#values.indexOf(value);\n    if (i !== -1) this.#values.splice(i, 1);\n  }\n\n  #ensureValid(value: T): void {\n    if (!this.propertyType.isValueValid(value))\n      throw new Error(\n        `Invalid value for property \"${this.propertyType.fullName}\"`,\n      );\n  }\n\n  #ensureNotUnique(): void {\n    if (this.propertyType.isUnique)\n      throw new TypeError(`Property \"${this.propertyType.fullName}\" is unique`);\n  }\n\n  #ensureUnique(): void {\n    if (!this.propertyType.isUnique)\n      throw new TypeError(\n        `Property \"${this.propertyType.fullName}\" is not unique`,\n      );\n  }\n}\n\n/**\n * This class represents a property that accepts only boolean values.\n */\nexport class BoolProperty extends ObjectProperty<boolean> {\n  isValueValid(v: unknown): boolean {\n    return typeof v === \"boolean\";\n  }\n\n  newValue(value: boolean): BoolPropertyValue {\n    return new BoolPropertyValue(this, value);\n  }\n}\n\n/**\n * This class represents a property that accepts only number values.\n */\nexport abstract class NumberProperty extends ObjectProperty<number> {\n  /**\n   * If not `null`, the lowest allowed value.\n   */\n  readonly min: number | null;\n  /**\n   * If not `null`, the lowest highest value.\n   */\n  readonly max: number | null;\n  /**\n   * The type of unit the values represent.\n   */\n  readonly unitType: UnitType | null;\n\n  /**\n   * Create an new number object property.\n   * @param objectType The {@link ObjectType} the property should be attached to.\n   * @param label The property’s label.\n   * @param localizedName The property’s localized label.\n   * @param unique Whether this property may have a single value (`true`) or several (`false`).\n   * @param deprecated Whether this property is deprecated, i.e. whether it should no longer be used.\n   * @param min If specified, the lowest allowed value.\n   * @param max If specified, the highest allowed value.\n   * @param unitType The type of unit the values represent.\n   * @throws {Error} If `min` > `max`.\n   */\n  constructor(\n    objectType: ObjectType,\n    label: string,\n    localizedName: string,\n    unique: boolean,\n    deprecated: boolean,\n    min?: number,\n    max?: number,\n    unitType?: UnitType,\n  ) {\n    super(objectType, label, localizedName, unique, deprecated);\n    if (typeof min === \"number\" && typeof max === \"number\" && min > max)\n      throw new Error(\"min > max\");\n    this.min = min ?? null;\n    this.max = max ?? null;\n    this.unitType = unitType ?? null;\n  }\n\n  isValueValid(v: unknown): boolean {\n    return (\n      typeof v === \"number\" &&\n      (this.min === null || v >= this.min) &&\n      (this.max === null || v <= this.max)\n    );\n  }\n\n  abstract newValue(\n    value: number,\n    unit?: Unit,\n  ): NumberPropertyValue<NumberProperty>;\n}\n\n/**\n * This class represents a property that accepts only integer values.\n */\nexport class IntProperty extends NumberProperty {\n  /**\n   * Create an new integer object property.\n   * @param objectType The {@link ObjectType} the property should be attached to.\n   * @param label The property’s label.\n   * @param localizedName The property’s localized label.\n   * @param unique Whether this property may have a single value (`true`) or several (`false`).\n   * @param deprecated Whether this property is deprecated, i.e. whether it should no longer be used.\n   * @param min If specified, the lowest allowed value.\n   * @param max If specified, the highest allowed value.\n   * @param unitType The type of unit the values represent.\n   * @throws {Error} If `min` > `max` or any of the two is not an integer.\n   */\n  constructor(\n    objectType: ObjectType,\n    label: string,\n    localizedName: string,\n    unique: boolean,\n    deprecated: boolean,\n    min?: number,\n    max?: number,\n    unitType?: UnitType,\n  ) {\n    super(\n      objectType,\n      label,\n      localizedName,\n      unique,\n      deprecated,\n      min,\n      max,\n      unitType,\n    );\n    if (min && !Number.isInteger(min))\n      throw new Error(\"min should be an integer\");\n    if (max && !Number.isInteger(max))\n      throw new Error(\"max should be an integer\");\n  }\n\n  isValueValid(v: unknown): boolean {\n    return super.isValueValid(v) && Number.isInteger(v);\n  }\n\n  newValue(value: number, unit?: Unit): IntPropertyValue {\n    return new IntPropertyValue(this, unit, value);\n  }\n}\n\n/**\n * This class represents a property that accepts only floating point numbers values.\n */\nexport class FloatProperty extends NumberProperty {\n  newValue(value: number, unit?: Unit): FloatPropertyValue {\n    return new FloatPropertyValue(this, unit, value);\n  }\n}\n\n/**\n * This class represents a property that accepts only string values.\n */\nexport class StringProperty extends ObjectProperty<string> {\n  /**\n   * Indicates whether this property may accept multiple lines of text.\n   */\n  readonly isMultiline: boolean;\n  /**\n   * Indicates whether this property may have translations.\n   */\n  readonly isTranslatable: boolean;\n\n  /**\n   * Create an new integer object property.\n   * @param objectType The {@link ObjectType} the property should be attached to.\n   * @param label The property’s label.\n   * @param localizedName The property’s localized label.\n   * @param unique Whether this property may have a single value (`true`) or several (`false`).\n   * @param deprecated Whether this property is deprecated, i.e. whether it should no longer be used.\n   * @param multiline Whether this property may accept multiple lines of text.\n   * @param translatable Whether this property may have translations.\n   */\n  constructor(\n    objectType: ObjectType,\n    label: string,\n    localizedName: string,\n    unique: boolean,\n    deprecated: boolean,\n    multiline: boolean,\n    translatable: boolean,\n  ) {\n    super(objectType, label, localizedName, unique, deprecated);\n    this.isMultiline = multiline;\n    this.isTranslatable = translatable;\n  }\n\n  isValueValid(v: unknown): boolean {\n    return (\n      typeof v === \"string\" &&\n      (this.isMultiline || (!v.includes(\"\\n\") && !v.includes(\"\\r\")))\n    );\n  }\n\n  newValue(\n    value: string,\n    translations?: Record<string, string>,\n  ): StringPropertyValue {\n    return new StringPropertyValue(\n      this,\n      translations ? [translations] : [],\n      value,\n    );\n  }\n}\n\n/**\n * This class represents a property that accepts only {@link DateInterval} values.\n */\nexport class DateIntervalProperty extends ObjectProperty<DateInterval> {\n  isValueValid(v: unknown): boolean {\n    return v instanceof DateInterval;\n  }\n\n  newValue(value: DateInterval): DateIntervalPropertyValue {\n    return new DateIntervalPropertyValue(this, value);\n  }\n}\n\n/**\n * This class represents a property that accepts only {@link ObjectInstance} values.\n */\nexport class TypeProperty extends ObjectProperty<ObjectInstance> {\n  /**\n   * The type of the objects this property can point to.\n   */\n  readonly targetType: ObjectType;\n\n  /**\n   * Create an new integer object property.\n   * @param objectType The {@link ObjectType} the property should be attached to.\n   * @param label The property’s label.\n   * @param localizedName The property’s localized label.\n   * @param unique Whether this property may have a single value (`true`) or several (`false`).\n   * @param deprecated Whether this property is deprecated, i.e. whether it should no longer be used.\n   * @param targetType The type of the objects the property can point to.\n   */\n  constructor(\n    objectType: ObjectType,\n    label: string,\n    localizedName: string,\n    unique: boolean,\n    deprecated: boolean,\n    targetType: ObjectType,\n  ) {\n    super(objectType, label, localizedName, unique, deprecated);\n    this.targetType = targetType;\n  }\n\n  isValueValid(v: unknown): boolean {\n    return v instanceof ObjectInstance && v.isInstanceOf(this.targetType);\n  }\n\n  newValue(value: ObjectInstance): TypePropertyValue {\n    return new TypePropertyValue(this, value);\n  }\n}\n\n/**\n * This class represents a property that accepts only temporal {@link ObjectInstance} values.\n */\nexport class TemporalProperty extends TypeProperty {\n  /**\n   * Whether this property allows date interval overlaps among its target values.\n   */\n  readonly allowsOverlaps: boolean;\n\n  /**\n   * Create an new integer object property.\n   * @param objectType The {@link ObjectType} the property should be attached to.\n   * @param label The property’s label.\n   * @param localizedName The property’s localized label.\n   * @param deprecated Whether this property is deprecated, i.e. whether it should no longer be used.\n   * @param targetType The type of the objects the property can point to.\n   * @param allowsOverlaps Whether the property allows date interval overlaps amongs its target values.\n   * @throws {TypeError} If the targetType value is not a temporal object.\n   */\n  constructor(\n    objectType: ObjectType,\n    label: string,\n    localizedName: string,\n    deprecated: boolean,\n    targetType: ObjectType,\n    allowsOverlaps: boolean,\n  ) {\n    super(objectType, label, localizedName, false, deprecated, targetType);\n    if (!targetType.isTemporal)\n      throw new TypeError(\"Target type is not temporal\");\n    this.allowsOverlaps = allowsOverlaps;\n  }\n\n  isValueValid(v: unknown): boolean {\n    // FIXME check overlaps\n    return super.isValueValid(v) && (v as ObjectInstance).type.isTemporal;\n  }\n\n  newValue(value: ObjectInstance): TemporalObjectPropertyValue {\n    return new TemporalObjectPropertyValue(this, value);\n  }\n}\n\n/**\n * This class represents a property that accepts only {@link Enum} values,\n * i.e. only values from the specified {@link Enum} will be accepted.\n */\nexport class EnumProperty extends ObjectProperty<string> {\n  /**\n   * The enumeration this property accepts values from.\n   */\n  readonly enumType: Enum;\n\n  /**\n   * Create an new integer object property.\n   * @param objectType The {@link ObjectType} the property should be attached to.\n   * @param label The property’s label.\n   * @param localizedName The property’s localized label.\n   * @param unique Whether this property may have a single value (`true`) or several (`false`).\n   * @param deprecated Whether this property is deprecated, i.e. whether it should no longer be used.\n   * @param enumType The {@link Enum} whose values this property may only accept.\n   */\n  constructor(\n    objectType: ObjectType,\n    label: string,\n    localizedName: string,\n    unique: boolean,\n    deprecated: boolean,\n    enumType: Enum,\n  ) {\n    super(objectType, label, localizedName, unique, deprecated);\n    this.enumType = enumType;\n  }\n\n  isValueValid(v: unknown): boolean {\n    return (\n      typeof v === \"string\" && this.enumType.values.some((value) => value === v)\n    );\n  }\n\n  newValue(value: string): EnumPropertyValue {\n    return new EnumPropertyValue(this, value);\n  }\n}\n\n/*\n * Instances\n */\n\n/**\n * This class represents an instance of an {@link ObjectType}.\n */\nexport class ObjectInstance {\n  /**\n   * This object’s database ID or null if it does not exist in it yet.\n   */\n  readonly id: number | null;\n  #type: ObjectType;\n  #existenceInterval: DateInterval | null = null;\n  readonly #properties = new Map<\n    string,\n    PropertyValue<unknown, ObjectProperty<unknown>>\n  >();\n\n  /**\n   * Create a new object instance of the given type.\n   * @param type The object’s type.\n   * @param existenceInterval The object’s existence inverval if it is temporal.\n   * @param id This object’s database ID. Leave empty for new objects.\n   * @throws {Error} If `existenceInterval` is not null and this object is not temporal,\n   *  or `existenceInterval` is null and this object is temporal.\n   */\n  constructor(\n    type: ObjectType,\n    existenceInterval?: DateInterval | null,\n    id?: number,\n  ) {\n    this.#type = type;\n    this.id = id ?? null;\n    this.existenceInterval = existenceInterval ?? null;\n  }\n\n  /**\n   * This object’s type.\n   */\n  get type(): ObjectType {\n    return this.#type;\n  }\n\n  /**\n   * Set the type of this object. All property values compatible with the new type will be kept,\n   * incompatible ones will be discarded.\n   *\n   * A value is considered compatible if it is bound to a property with the same label,\n   * the unicity of the current type’s property matches that of the given type’s equivalent property,\n   * and all values’ types are compatible.\n   * @param newType The new type.\n   * @throws {TypeError} If the new type’s `geometryType` is different from this one’s.\n   */\n  set type(newType: ObjectType) {\n    if (newType !== this.#type) {\n      const expectedGeomType = this.#type.getGeometryType();\n      const actualGeomType = newType.getGeometryType();\n      if (expectedGeomType !== actualGeomType)\n        throw new TypeError(\n          `Incompatible geometry type, expected \"${expectedGeomType}\", got \"${actualGeomType}\"`,\n        );\n\n      const toKeep: Record<\n        string,\n        PropertyValue<unknown, ObjectProperty<unknown>>\n      > = {};\n      // Store values that are compatible with the new type\n      for (const [name, value] of this.#properties) {\n        if (newType.getProperty(name)?.isValueCompatible(value))\n          toKeep[name] = value;\n      }\n      this.#properties.clear();\n      // Add back the compatible values\n      for (const [name, value] of Object.entries(toKeep)) {\n        if (value.propertyType.isUnique)\n          this.setPropertyValue(name, value.value);\n        else for (const v of value.values) this.addValueToProperty(name, v);\n      }\n\n      this.#type = newType;\n    }\n  }\n\n  /**\n   * This object’s existence interval if it is temporal, null otherwise.\n   */\n  get existenceInterval(): DateInterval | null {\n    return this.#existenceInterval;\n  }\n\n  /**\n   * Set this object’s existence interval.\n   * @param interval The new interval.\n   * @throws {Error} If the value is not null and this object is not temporal,\n   *  or the value is null and this object is temporal.\n   */\n  set existenceInterval(interval: DateInterval | null) {\n    if (!this.type.isTemporal && interval)\n      throw new Error(\"Object is not temporal\");\n    if (this.type.isTemporal && !interval)\n      throw new Error(\"Missing existence interval for temporal object\");\n    this.#existenceInterval = interval;\n  }\n\n  /**\n   * Get the value for the given property.\n   * @param name The property’s name.\n   * @returns The property’s value, or undefined if no value is bound to it.\n   * @throws {TypeError} If the property does not exist for this object’s type or it is not unique.\n   */\n  getPropertyValue(name: string): unknown {\n    const { value } = this.#getPropertyOrThrow(name);\n    return value?.value;\n  }\n\n  /**\n   * Set the value of the given property.\n   * @param name The property’s name.\n   * @param value The property’s value.\n   * @throws {TypeError} If the property does not exist for this object’s type or it is not unique.\n   * @throws {Error} If the provided value’s type does not match the property’s type.\n   */\n  setPropertyValue(name: string, value: unknown): void {\n    const { property, value: pValue } = this.#getPropertyOrThrow(name);\n    if (pValue) pValue.value = value;\n    else this.#createPropertyBinding(property, value);\n  }\n\n  /**\n   * Get the values for the given property.\n   * @param name The property’s name.\n   * @returns The property’s values as an array, or an empty array if no value is bound to it.\n   * @throws {TypeError} If the property does not exist for this object’s type or it is unique.\n   */\n  getPropertyValues(name: string): unknown[] {\n    const { value } = this.#getPropertyOrThrow(name);\n    return value?.values ?? [];\n  }\n\n  /**\n   * Add a value to the given property.\n   * @param name The property’s name.\n   * @param value The value to add to this property.\n   * @throws {TypeError} If the property does not exist for this object’s type or is unique.\n   */\n  addValueToProperty(name: string, value: unknown): void {\n    const { property, value: pValue } = this.#getPropertyOrThrow(name);\n    if (pValue) pValue.addValue(value);\n    else this.#createPropertyBinding(property, value);\n  }\n\n  /**\n   * Remove a value from the given property.\n   * If the removed value was the only one, the property is unbound from this object.\n   * @param name The property’s name.\n   * @param value The value to remove from the property.\n   * @throws {TypeError} If the property does not exist for this object’s type or it is unique.\n   */\n  removeValueFromProperty(name: string, value: unknown): void {\n    const { value: pValue } = this.#getPropertyOrThrow(name);\n    if (pValue) {\n      pValue.removeValue(value);\n      if (pValue.values.length === 0) this.#properties.delete(name);\n    }\n  }\n\n  /**\n   * Delete the given property binding.\n   * @param name The property’s name.\n   * @throws {TypeError} If the property does not exist for this object’s type.\n   */\n  deleteProperty(name: string): void {\n    const { value } = this.#getPropertyOrThrow(name);\n    if (value) this.#properties.delete(name);\n  }\n\n  /**\n   * Fetch the property with the given name in this object or throw an error if it does not exist.\n   * @param name The name of the property to fetch.\n   * @return An object containing the property definition and its value if any.\n   * @throws TypeError If the property is not defined in this object’s type.\n   */\n  #getPropertyOrThrow(name: string): {\n    property: ObjectProperty<unknown>;\n    value: PropertyValue<unknown, ObjectProperty<unknown>> | undefined;\n  } {\n    const property = this.#type.getProperty(name);\n    if (!property)\n      throw new TypeError(\n        `Undefined property \"${name}\" for object of type \"${this.#type.label}\"`,\n      );\n    return { property, value: this.#properties.get(name) };\n  }\n\n  #createPropertyBinding(\n    property: ObjectProperty<unknown> | NumberProperty,\n    value: unknown,\n  ) {\n    const name = property.label;\n    if (property instanceof NumberProperty) {\n      if (typeof value !== \"number\")\n        throw new TypeError(`Expected number, got ${typeof value}`);\n      this.#properties.set(\n        name,\n        property.newValue(\n          value,\n          property.unitType\n            ? [...property.unitType.units].find((unit) => unit.isDefault)\n            : undefined,\n        ),\n      );\n    } else this.#properties.set(name, property.newValue(value));\n  }\n\n  /**\n   * Get the currently selected unit of the given property.\n   * @param name The name of the property to get the unit of.\n   * @returns The property’s current unit or null if the property has no bound value.\n   * @throws {TypeError} If the property does not exist or it does not have a unit.\n   */\n  getPropertyUnit(name: string): Unit | null {\n    const { property, value } = this.#getPropertyOrThrow(name);\n    if (\n      !(property instanceof NumberProperty) ||\n      (value && !ObjectInstance.#isNumberProperty(value)) ||\n      !property.unitType\n    )\n      throw new TypeError(\n        `Property \"${property.fullName}\" does not have a unit`,\n      );\n    return value?.unit ?? null;\n  }\n\n  /**\n   * Set the unit of the given property.\n   * @param name The name of the property to set the unit of.\n   * @param unit The new unit.\n   * @throws {TypeError} If the property does not exist, it does not have a unit, it is not bound yet,\n   *  or the new unit’s type is incompatible.\n   */\n  setPropertyUnit(name: string, unit: Unit): void {\n    const { property, value } = this.#getPropertyOrThrow(name);\n    if (\n      !(property instanceof NumberProperty) ||\n      (value && !ObjectInstance.#isNumberProperty(value)) ||\n      !property.unitType\n    )\n      throw new TypeError(\n        `Property \"${property.fullName}\" does not have a unit`,\n      );\n    if (!value)\n      throw new Error(`Property \"${property.fullName}\" is not bound yet`);\n    value.unit = unit;\n  }\n\n  // FIXME This function exists because otherwise TS would put a warning on the instanceof check\n  static #isNumberProperty(\n    value: unknown,\n  ): value is NumberPropertyValue<NumberProperty> {\n    return value instanceof NumberPropertyValue;\n  }\n\n  /**\n   * Get the translations of the given string property value.\n   * @param name The name of the property to get the translations of.\n   * @param index If the property is not unique, the index of the value to get translations of.\n   * @returns A map of the value’s translations. The keys are language codes, the values are the associated translations.\n   * Null if no value is bound to the property or the index is invalid.\n   * @throws {TypeError} If the property does not exist, or it is not translatable.\n   */\n  getPropertyValueTranslations(\n    name: string,\n    index?: number,\n  ): TranslationMap | null {\n    const { property, value } = this.#getPropertyOrThrow(name);\n    if (\n      !(property instanceof StringProperty) ||\n      (value && !(value instanceof StringPropertyValue)) ||\n      !property.isTranslatable\n    )\n      throw new TypeError(\n        `Property \"${property.fullName}\" is not translatable`,\n      );\n    return value?.translations[index ?? 0] ?? null;\n  }\n\n  /**\n   * Set the translation of the given string property value for the given language.\n   * @param name The name of the property to get the translations of.\n   * @param langCode The language code of the translation.\n   * @param tr The translated text.\n   * @param index If the property is not unique, the index of the value to set the translation of.\n   * @throws {TypeError} If the property does not exist, or it is not translatable.\n   */\n  setPropertyValueTranslation(\n    name: string,\n    langCode: string,\n    tr: string,\n    index?: number,\n  ): void {\n    const { property, value } = this.#getPropertyOrThrow(name);\n    if (\n      !(property instanceof StringProperty) ||\n      (value && !(value instanceof StringPropertyValue)) ||\n      !property.isTranslatable\n    )\n      throw new TypeError(\n        `Property \"${property.fullName}\" is not translatable`,\n      );\n    value?.setTranslation(langCode, tr, index);\n  }\n\n  /**\n   * Remove the translation of the given string property value for the given language.\n   * @param name The name of the property to get the translations of.\n   * @param langCode The language code of the translation.\n   * @param index If the property is not unique, the index of the value to set remove the translation from.\n   * @throws {TypeError} If the property does not exist, or it is not translatable.\n   */\n  removePropertyValueTranslation(\n    name: string,\n    langCode: string,\n    index?: number,\n  ): void {\n    const { property, value } = this.#getPropertyOrThrow(name);\n    if (\n      !(property instanceof StringProperty) ||\n      (value && !(value instanceof StringPropertyValue)) ||\n      !property.isTranslatable\n    )\n      throw new TypeError(\n        `Property \"${property.fullName}\" is not translatable`,\n      );\n    value?.removeTranslation(langCode, index);\n  }\n\n  /**\n   * Check whether this object is an instance of the given {@link ObjectType}.\n   * @param t The type to check.\n   * @returns True if this object has the given type in its type hierarchy, false otherwise.\n   * @see ObjectType.isSameOrSubtypeOf\n   */\n  isInstanceOf(t: ObjectType): boolean {\n    return this.#type.isSameOrSubtypeOf(t);\n  }\n}\n\n/**\n * This class represents the single boolean value bound to an {@link BoolProperty} definition\n * with a `isUnique` field set to `true`.\n */\nexport class BoolPropertyValue extends PropertyValue<boolean, BoolProperty> {}\n\n/**\n * This class represents the number value(s) bound to a {@link NumberProperty} definition.\n */\nexport abstract class NumberPropertyValue<\n  OP extends NumberProperty,\n> extends PropertyValue<number, OP> {\n  #unit: Unit | null = null;\n\n  /**\n   * Create a new number property value.\n   * @param propertyType The property to bind the value to.\n   * @param unit Optional. The unit to attach to each value.\n   * @param values The values to bind to the property.\n   * @throws {TypeError} If the value is invalid for the property\n   *  or the unit’s type differs from the one defined by the property.\n   */\n  constructor(propertyType: OP, unit?: Unit, ...values: number[]) {\n    super(propertyType, ...values);\n    if (propertyType.unitType && !unit)\n      throw new Error(`Missing unit for property ${propertyType.fullName}`);\n    if (unit) this.unit = unit;\n  }\n\n  /**\n   * The unit attached to this value. May be null.\n   */\n  get unit(): Unit | null {\n    return this.#unit;\n  }\n\n  /**\n   * Set the unit attached to this value.\n   * @throws {TypeError} If the unit’s type differs from the one defined by the property.\n   * @throws {Error} If the unit is null but one is required.\n   */\n  set unit(unit: Unit) {\n    const expectedType = this.propertyType.unitType;\n    if (!expectedType)\n      throw new TypeError(\n        `Unexpected unit for property \"${this.propertyType.fullName}\"`,\n      );\n    const actualType = unit.type;\n    if (expectedType !== actualType)\n      throw new TypeError(\n        `Invalid unit type for property \"${this.propertyType.fullName}\": expected \"${expectedType.label}\", got \"${actualType}\"`,\n      );\n    this.#unit = unit;\n  }\n}\n\n/**\n * This class represents the int value(s) bound to an {@link IntProperty} definition.\n */\nexport class IntPropertyValue extends NumberPropertyValue<IntProperty> {}\n\n/**\n * This class represents the float value(s) bound to a {@link FloatProperty} definition.\n */\nexport class FloatPropertyValue extends NumberPropertyValue<FloatProperty> {}\n\n/**\n * A translation map associates language codes with a translation.\n */\nexport type TranslationMap = Map<string, string>;\n\n/**\n * This class represents the string value(s) bound to a {@link StringProperty} definition.\n */\nexport class StringPropertyValue extends PropertyValue<string, StringProperty> {\n  readonly #translations: TranslationMap[];\n\n  /**\n   * Create a new string property value.\n   * @param values The values to bind to the property.\n   * @param propertyType The property to bind the value to.\n   * @param translations Optional. The existing translations for this value.\n   * @throws {Error} If translations are provided but the property is not translatable.\n   */\n  constructor(\n    propertyType: StringProperty,\n    translations?: Record<string, string>[],\n    ...values: string[]\n  ) {\n    super(propertyType, ...values);\n    if (translations) this.#ensureTranslatable();\n    if (translations && translations.length > values.length)\n      throw new Error(\"Too many translations\");\n    this.#translations =\n      translations?.map((tr) => new Map(Object.entries(tr))) ?? [];\n  }\n\n  /**\n   * The translations for each value of this property.\n   * @returns A new array containing a {@link TranslationMap} for each value,\n   * in the same order as {@link PropertyValue#values}.\n   */\n  get translations(): TranslationMap[] {\n    return structuredClone(this.#translations);\n  }\n\n  /**\n   * Set the translation for the given language code.\n   * @param langCode The language code.\n   * @param tr The translation for that language.\n   * @param index If the property is not unique, the index of the value to set the translation of.\n   * @throws {Error} If the property is not translatable or the index is invalid.\n   */\n  setTranslation(langCode: string, tr: string, index?: number): void {\n    this.#ensureTranslatable();\n    this.#translations[index ?? 0].set(langCode, tr);\n  }\n\n  /**\n   * Remove the translation for the given language code.\n   * @param langCode The language code.\n   * @param index If the property is not unique, the index of the value to remove the translation from.\n   * @throws {Error} If the property is not translatable.\n   */\n  removeTranslation(langCode: string, index?: number): void {\n    this.#ensureTranslatable();\n    this.#translations[index ?? 0].delete(langCode);\n  }\n\n  #ensureTranslatable() {\n    if (!this.propertyType.isTranslatable)\n      throw new Error(\n        `Property \"${this.propertyType.fullName}\" is not translatable`,\n      );\n  }\n}\n\n/**\n * This class represents the {@link DateInterval} value(s) bound to a {@link DateIntervalProperty} definition.\n */\nexport class DateIntervalPropertyValue extends PropertyValue<\n  DateInterval,\n  DateIntervalProperty\n> {}\n\n/**\n * This class represents the {@link ObjectInstance} value(s) bound to a {@link TypeProperty} definition.\n */\nexport class TypePropertyValue<\n  OP extends TypeProperty = TypeProperty,\n> extends PropertyValue<ObjectInstance, OP> {}\n\n/**\n * This class represents the single enum value(s) bound to an {@link EnumProperty} definition.\n */\nexport class EnumPropertyValue extends PropertyValue<string, EnumProperty> {}\n\n/**\n * This class represents the temporal objects bound to a {@link TemporalProperty} definition.\n */\nexport class TemporalObjectPropertyValue extends TypePropertyValue<TemporalProperty> {\n  /**\n   * Set the values bound to this property.\n   * @throws {TypeError} If the property is unique.\n   */\n  set values(values: ObjectInstance[]) {\n    values.forEach((v) => {\n      this.addValue(v);\n    });\n  }\n\n  addValue(value: ObjectInstance): void {\n    this.#checkOverlaps(value);\n    super.addValue(value);\n  }\n\n  #checkOverlaps(value: ObjectInstance): void {\n    if (\n      !this.propertyType.allowsOverlaps &&\n      this.values.some(\n        (o) =>\n          !!value.existenceInterval &&\n          !!o.existenceInterval &&\n          value.existenceInterval.overlaps(o.existenceInterval),\n      )\n    )\n      throw new Error(\"Object’s existence interval overlaps another one’s\");\n  }\n}\n","import { MapFeature } from \"../model/geometry\";\n\n/**\n * Base class for the map editor’s events.\n */\nexport abstract class MapEditorEvent {\n  /**\n   * This event’s type. Used by the `Map.fire` and `Map.on` methods.\n   */\n  readonly type: string;\n\n  /**\n   * Create a new event.\n   * @param type The event’s type.\n   */\n  protected constructor(type: string) {\n    this.type = type;\n  }\n}\n\n/**\n * This event is fired when the feature selection changes.\n */\nexport class FeatureSelectionEvent extends MapEditorEvent {\n  /**\n   * This event’s type. For the `Map.on` method.\n   */\n  static readonly TYPE = \"editor.selection\";\n\n  /**\n   * The list of selected features.\n   */\n  readonly features: MapFeature[];\n\n  /**\n   * Create a new event.\n   * @param features The selected features.\n   */\n  constructor(features: MapFeature[] = []) {\n    super(FeatureSelectionEvent.TYPE);\n    this.features = features;\n  }\n}\n\n/**\n * This event is fired whenever a feature is hovered.\n */\nexport class FeatureHoverEvent extends MapEditorEvent {\n  /**\n   * This event’s type. For the `Map.on` method.\n   */\n  static readonly TYPE = \"editor.hover\";\n\n  /**\n   * The hovered feature or undefined if there are none.\n   */\n  readonly feature: MapFeature | undefined;\n\n  /**\n   * Create a new event.\n   * @param feature The hovered feature.\n   */\n  constructor(feature?: MapFeature) {\n    super(FeatureHoverEvent.TYPE);\n    this.feature = feature;\n  }\n}\n","// index.ts\nimport { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nfunction polygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  if (!options.properties && poly.type === \"Feature\") {\n    options.properties = poly.properties;\n  }\n  switch (geom.type) {\n    case \"Polygon\":\n      return singlePolygonToLine(geom, options);\n    case \"MultiPolygon\":\n      return multiPolygonToLine(geom, options);\n    default:\n      throw new Error(\"invalid poly\");\n  }\n}\nfunction singlePolygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : poly.type === \"Feature\" ? poly.properties : {};\n  return coordsToLine(coords, properties);\n}\nfunction multiPolygonToLine(multiPoly, options = {}) {\n  const geom = getGeom(multiPoly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : multiPoly.type === \"Feature\" ? multiPoly.properties : {};\n  const lines = [];\n  coords.forEach((coord) => {\n    lines.push(coordsToLine(coord, properties));\n  });\n  return featureCollection(lines);\n}\nfunction coordsToLine(coords, properties) {\n  if (coords.length > 1) {\n    return multiLineString(coords, properties);\n  }\n  return lineString(coords[0], properties);\n}\nvar turf_polygon_to_line_default = polygonToLine;\nexport {\n  coordsToLine,\n  turf_polygon_to_line_default as default,\n  multiPolygonToLine,\n  polygonToLine,\n  singlePolygonToLine\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport {\n  degreesToRadians,\n  lengthToRadians,\n  point,\n  radiansToDegrees\n} from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction destination(origin, distance, bearing, options = {}) {\n  const coordinates1 = getCoord(origin);\n  const longitude1 = degreesToRadians(coordinates1[0]);\n  const latitude1 = degreesToRadians(coordinates1[1]);\n  const bearingRad = degreesToRadians(bearing);\n  const radians = lengthToRadians(distance, options.units);\n  const latitude2 = Math.asin(\n    Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)\n  );\n  const longitude2 = longitude1 + Math.atan2(\n    Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n    Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)\n  );\n  const lng = radiansToDegrees(longitude2);\n  const lat = radiansToDegrees(latitude2);\n  return point([lng, lat], options.properties);\n}\nvar turf_destination_default = destination;\nexport {\n  turf_destination_default as default,\n  destination\n};\n//# sourceMappingURL=index.js.map","class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction checkWhichEventIsLeft (e1, e2) {\n    if (e1.p.x > e2.p.x) return 1\n    if (e1.p.x < e2.p.x) return -1\n\n    if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1\n    return 1\n}\n\nfunction checkWhichSegmentHasRightEndpointFirst (seg1, seg2) {\n    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1\n    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1\n\n    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1\n    return 1\n}\n\nclass Event {\n\n    constructor (p, featureId, ringId, eventId) {\n        this.p = {\n            x: p[0],\n            y: p[1]\n        };\n        this.featureId = featureId;\n        this.ringId = ringId;\n        this.eventId = eventId;\n\n        this.otherEvent = null;\n        this.isLeftEndpoint = null;\n    }\n\n    isSamePoint (eventToCheck) {\n        return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y\n    }\n}\n\nfunction fillEventQueue (geojson, eventQueue) {\n    if (geojson.type === 'FeatureCollection') {\n        const features = geojson.features;\n        for (let i = 0; i < features.length; i++) {\n            processFeature(features[i], eventQueue);\n        }\n    } else {\n        processFeature(geojson, eventQueue);\n    }\n}\n\nlet featureId = 0;\nlet ringId = 0;\nlet eventId = 0;\nfunction processFeature (featureOrGeometry, eventQueue) {\n    const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;\n    let coords = geom.coordinates;\n    // standardise the input\n    if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [coords];\n    if (geom.type === 'LineString') coords = [[coords]];\n\n    for (let i = 0; i < coords.length; i++) {\n        for (let ii = 0; ii < coords[i].length; ii++) {\n            let currentP = coords[i][ii][0];\n            let nextP = null;\n            ringId = ringId + 1;\n            for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {\n                nextP = coords[i][ii][iii + 1];\n\n                const e1 = new Event(currentP, featureId, ringId, eventId);\n                const e2 = new Event(nextP, featureId, ringId, eventId + 1);\n\n                e1.otherEvent = e2;\n                e2.otherEvent = e1;\n\n                if (checkWhichEventIsLeft(e1, e2) > 0) {\n                    e2.isLeftEndpoint = true;\n                    e1.isLeftEndpoint = false;\n                } else {\n                    e1.isLeftEndpoint = true;\n                    e2.isLeftEndpoint = false;\n                }\n                eventQueue.push(e1);\n                eventQueue.push(e2);\n\n                currentP = nextP;\n                eventId = eventId + 1;\n            }\n        }\n    }\n    featureId = featureId + 1;\n}\n\nclass Segment {\n\n    constructor (event) {\n        this.leftSweepEvent = event;\n        this.rightSweepEvent = event.otherEvent;\n    }\n}\n\nfunction testSegmentIntersect (seg1, seg2) {\n    if (seg1 === null || seg2 === null) return false\n\n    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId &&\n        (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false\n\n    const x1 = seg1.leftSweepEvent.p.x;\n    const y1 = seg1.leftSweepEvent.p.y;\n    const x2 = seg1.rightSweepEvent.p.x;\n    const y2 = seg1.rightSweepEvent.p.y;\n    const x3 = seg2.leftSweepEvent.p.x;\n    const y3 = seg2.leftSweepEvent.p.y;\n    const x4 = seg2.rightSweepEvent.p.x;\n    const y4 = seg2.rightSweepEvent.p.y;\n\n    const denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    const numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    const numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) return false\n        return false\n    }\n\n    const uA = numeA / denom;\n    const uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        const x = x1 + (uA * (x2 - x1));\n        const y = y1 + (uA * (y2 - y1));\n        return [x, y]\n    }\n    return false\n}\n\n// import {debugEventAndSegments, debugRemovingSegment} from './debug'\n\nfunction runCheck (eventQueue, ignoreSelfIntersections) {\n    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;\n\n    const intersectionPoints = [];\n    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);\n\n    while (eventQueue.length) {\n        const event = eventQueue.pop();\n        if (event.isLeftEndpoint) {\n            // debugEventAndSegments(event.p, outQueue.data)\n            const segment = new Segment(event);\n            for (let i = 0; i < outQueue.data.length; i++) {\n                const otherSeg = outQueue.data[i];\n                if (ignoreSelfIntersections) {\n                    if (otherSeg.leftSweepEvent.featureId === event.featureId) continue\n                }\n                const intersection = testSegmentIntersect(segment, otherSeg);\n                if (intersection !== false) intersectionPoints.push(intersection);\n            }\n            outQueue.push(segment);\n        } else if (event.isLeftEndpoint === false) {\n            outQueue.pop();\n            // const seg = outQueue.pop()\n            // debugRemovingSegment(event.p, seg)\n        }\n    }\n    return intersectionPoints\n}\n\nfunction sweeplineIntersections (geojson, ignoreSelfIntersections) {\n    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);\n    fillEventQueue(geojson, eventQueue);\n    return runCheck(eventQueue, ignoreSelfIntersections)\n}\n\nexport default sweeplineIntersections;\n","// index.ts\nimport { feature, featureCollection, point } from \"@turf/helpers\";\n\n// lib/sweepline-intersections-export.ts\nimport lib from \"sweepline-intersections\";\nvar sweeplineIntersections = lib;\n\n// index.ts\nfunction lineIntersect(line1, line2, options = {}) {\n  const { removeDuplicates = true, ignoreSelfIntersections = false } = options;\n  let features = [];\n  if (line1.type === \"FeatureCollection\")\n    features = features.concat(line1.features);\n  else if (line1.type === \"Feature\")\n    features.push(line1);\n  else if (line1.type === \"LineString\" || line1.type === \"Polygon\" || line1.type === \"MultiLineString\" || line1.type === \"MultiPolygon\") {\n    features.push(feature(line1));\n  }\n  if (line2.type === \"FeatureCollection\")\n    features = features.concat(line2.features);\n  else if (line2.type === \"Feature\")\n    features.push(line2);\n  else if (line2.type === \"LineString\" || line2.type === \"Polygon\" || line2.type === \"MultiLineString\" || line2.type === \"MultiPolygon\") {\n    features.push(feature(line2));\n  }\n  const intersections = sweeplineIntersections(\n    featureCollection(features),\n    ignoreSelfIntersections\n  );\n  let results = [];\n  if (removeDuplicates) {\n    const unique = {};\n    intersections.forEach((intersection) => {\n      const key = intersection.join(\",\");\n      if (!unique[key]) {\n        unique[key] = true;\n        results.push(intersection);\n      }\n    });\n  } else {\n    results = intersections;\n  }\n  return featureCollection(results.map((r) => point(r)));\n}\nvar turf_line_intersect_default = lineIntersect;\nexport {\n  turf_line_intersect_default as default,\n  lineIntersect\n};\n//# sourceMappingURL=index.js.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineIntersect as lineIntersects } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nfunction nearestPointOnLine(lines, pt, options = {}) {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n  let closestPt = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1\n  });\n  let length = 0;\n  flattenEach(\n    lines,\n    function(line, _featureIndex, multiFeatureIndex) {\n      const coords = getCoords(line);\n      for (let i = 0; i < coords.length - 1; i++) {\n        const start = point(coords[i]);\n        start.properties.dist = distance(pt, start, options);\n        const stop = point(coords[i + 1]);\n        stop.properties.dist = distance(pt, stop, options);\n        const sectionLength = distance(start, stop, options);\n        const heightDistance = Math.max(\n          start.properties.dist,\n          stop.properties.dist\n        );\n        const direction = bearing(start, stop);\n        const perpendicularPt1 = destination(\n          pt,\n          heightDistance,\n          direction + 90,\n          options\n        );\n        const perpendicularPt2 = destination(\n          pt,\n          heightDistance,\n          direction - 90,\n          options\n        );\n        const intersect = lineIntersects(\n          lineString([\n            perpendicularPt1.geometry.coordinates,\n            perpendicularPt2.geometry.coordinates\n          ]),\n          lineString([start.geometry.coordinates, stop.geometry.coordinates])\n        );\n        let intersectPt;\n        if (intersect.features.length > 0 && intersect.features[0]) {\n          intersectPt = __spreadProps(__spreadValues({}, intersect.features[0]), {\n            properties: {\n              dist: distance(pt, intersect.features[0], options),\n              multiFeatureIndex,\n              location: length + distance(start, intersect.features[0], options)\n            }\n          });\n        }\n        if (start.properties.dist < closestPt.properties.dist) {\n          closestPt = __spreadProps(__spreadValues({}, start), {\n            properties: __spreadProps(__spreadValues({}, start.properties), {\n              index: i,\n              multiFeatureIndex,\n              location: length\n            })\n          });\n        }\n        if (stop.properties.dist < closestPt.properties.dist) {\n          closestPt = __spreadProps(__spreadValues({}, stop), {\n            properties: __spreadProps(__spreadValues({}, stop.properties), {\n              index: i + 1,\n              multiFeatureIndex,\n              location: length + sectionLength\n            })\n          });\n        }\n        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n          closestPt = __spreadProps(__spreadValues({}, intersectPt), {\n            properties: __spreadProps(__spreadValues({}, intersectPt.properties), { index: i })\n          });\n        }\n        length += sectionLength;\n      }\n    }\n  );\n  return closestPt;\n}\nvar turf_nearest_point_on_line_default = nearestPointOnLine;\nexport {\n  turf_nearest_point_on_line_default as default,\n  nearestPointOnLine\n};\n//# sourceMappingURL=index.js.map","import { LngLat } from \"maplibre-gl\";\nimport {\n  Feature,\n  LineString as GeoLineString,\n  MultiLineString,\n  Position,\n} from \"geojson\";\nimport { lineString } from \"@turf/helpers\";\nimport { distance } from \"@turf/distance\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\n\nimport {\n  LinearFeature,\n  LineString,\n  MapFeature,\n  Point,\n  Polygon,\n} from \"../model/geometry\";\n\n/**\n * Union of the object types returned by {@link trySnapPoint}.\n */\nexport type SnapResult = SnapPoint | SnapSegmentVertex | SnapSegment;\n\n/**\n * Object returned by {@link trySnapPoint} when the point was snapped to an isolated point.\n */\nexport interface SnapPoint {\n  type: \"point\";\n  /**\n   * The snapped point.\n   */\n  point: Point;\n}\n\n/**\n * Object returned by {@link trySnapPoint} when the point was snapped to a segment’s vertex.\n */\nexport interface SnapSegmentVertex {\n  type: \"segment_vertex\";\n  /**\n   * The feature the snapped vertex belongs to.\n   */\n  feature: LinearFeature;\n  /**\n   * The path to the snapped vertex in the feature.\n   */\n  path: string;\n}\n\n/**\n * Object returned by {@link trySnapPoint} when the point was snapped to segment.\n */\nexport interface SnapSegment {\n  type: \"segment\";\n  /**\n   * The feature the snapped segment belongs to.\n   */\n  feature: LinearFeature;\n  /**\n   * The path to the snapped segment in the feature.\n   */\n  path: string;\n  /**\n   * The snap position on the segment.\n   */\n  lngLat: LngLat;\n}\n\n/**\n * Try to snap the given position to a nearby feature.\n * @param pos The position to try to snap.\n * @param features The list of available features.\n * @param zoom The current map zoom lever.\n * @param snapDistancePx Optional. Maximum snap distance in pixels.\n * @returns Information for the snap position or null if nothing was snapped.\n */\nexport function trySnapPoint(\n  pos: LngLat,\n  features: MapFeature[],\n  zoom: number,\n  snapDistancePx = 5,\n): SnapResult | null {\n  const res = getClosestFeature(pos, features);\n  if (!res) return null;\n  // Only return if pixel distance is less than threshold\n  if (\n    res.dist * 1000 >\n    snapDistancePx * getMetersPerPixel(res.lngLat.lat, zoom)\n  )\n    return null;\n  if (res.feature instanceof Point) {\n    return {\n      type: \"point\",\n      point: res.feature,\n    };\n  } else if (isLinearFeature(res.feature)) {\n    const vertexPath = checkSnapToSegmentVertex(res, features, 0.0025);\n    if (vertexPath) {\n      return {\n        type: \"segment_vertex\",\n        feature: res.feature,\n        path: vertexPath,\n      };\n    } else if (res.path) {\n      return {\n        type: \"segment\",\n        feature: res.feature,\n        path: res.path,\n        lngLat: res.lngLat,\n      };\n    }\n  }\n  return null;\n}\n\n// FIXME This function exists because otherwise TS would put a warning on the instanceof check\nfunction isLinearFeature(f: unknown): f is LinearFeature {\n  return f instanceof LinearFeature;\n}\n\n/**\n * Given a non-point feature, check if we should snap to one of the vertices of the specified segment.\n * @param feature The feature to check.\n * @param features List of allowed features.\n * If a vertex of the feature segment is not in this list, it cannot be snapped to.\n * @param snapVertexPriorityDistance The distance that needs to be undercut to trigger priority to vertices.\n * @returns The path of the selected segment vertex or null if the point is too far from a vertex.\n */\nfunction checkSnapToSegmentVertex(\n  feature: ClosestFeature,\n  features: MapFeature[],\n  snapVertexPriorityDistance: number,\n): string | null {\n  if (!feature.segment || !feature.path || !isLinearFeature(feature.feature))\n    return null;\n  const [A, B] = feature.segment;\n  const aIncluded = features.includes(A);\n  const bIncluded = features.includes(B);\n\n  if (!aIncluded && !bIncluded) return null;\n\n  const C = [feature.lngLat.lng, feature.lngLat.lat];\n  const distanceAC = distance(A.lngLat.toArray(), C);\n  const distanceBC = distance(B.lngLat.toArray(), C);\n\n  if (\n    (aIncluded && !bIncluded) ||\n    (aIncluded && bIncluded && distanceAC < distanceBC)\n  )\n    return distanceAC < snapVertexPriorityDistance ? feature.path : null;\n  else if (\n    (!aIncluded && bIncluded) ||\n    (aIncluded && bIncluded && distanceBC < distanceAC)\n  )\n    return distanceBC < snapVertexPriorityDistance\n      ? feature.feature.incrementPath(feature.path)\n      : null;\n  else return null;\n}\n\nconst EARTH_CIRCUMFERENCE = 40_075_017;\n\n/**\n * Get the number of meters per pixel for the given latitude and zoom level,\n * assuming an Equator circumference of 40,075,017 meters.\n * @param latitude A latitude.\n * @param zoomLevel A zoom level.\n * @returns The number of meters per pixel.\n */\nfunction getMetersPerPixel(latitude: number, zoomLevel: number): number {\n  const latitudeRadians = latitude * (Math.PI / 180);\n  return (\n    (EARTH_CIRCUMFERENCE * Math.cos(latitudeRadians)) / 2 ** (zoomLevel + 8)\n  );\n}\n\n/**\n * This object is returned by the {@link getClosestFeature} function.\n */\ninterface ClosestFeature {\n  /**\n   * Position of the projected point on the closest feature.\n   */\n  lngLat: LngLat;\n  /**\n   * Distance in kilometers between the point and its projection.\n   */\n  dist: number;\n  /**\n   * The feature the projected points is on.\n   */\n  feature: MapFeature;\n  /**\n   * Optional. If the feature is not a point, path to the segment on which the point was projected.\n   */\n  path?: string;\n  /**\n   * Optional. If the feature is not a point, the vertices of segment on which the point was projected.\n   */\n  segment?: [Point, Point];\n}\n\n/**\n * Return the closest point or feature border to the given point.\n * A feature border is either a {@link LineString} or a {@link Polygon}’s ring.\n * @param pos Position of the point.\n * @param features List of features to search into.\n * @returns A ClosestFeature object or null if the list is empty.\n * @see ClosestFeature\n */\nfunction getClosestFeature(\n  pos: LngLat,\n  features: MapFeature[],\n): ClosestFeature | null {\n  let closestFeature: ClosestFeature | null = null;\n  for (const feature of features) {\n    if (feature instanceof Point) {\n      const dist = distance(pos.toArray(), feature);\n      if (!closestFeature || dist < closestFeature.dist) {\n        closestFeature = {\n          lngLat: feature.lngLat,\n          dist: dist,\n          feature: feature,\n        };\n      }\n    } else if (feature instanceof LineString) {\n      const nearestPoint = nearestPointOnLine(feature, pos.toArray());\n      if (\n        (!closestFeature ||\n          nearestPoint.properties.dist < closestFeature.dist) &&\n        // Segment index may be > than actual number of segments on line feature\n        nearestPoint.properties.index < feature.vertices.length - 1\n      ) {\n        const path = nearestPoint.properties.index.toString();\n        closestFeature = {\n          lngLat: LngLat.convert(\n            nearestPoint.geometry.coordinates as [number, number],\n          ),\n          dist: nearestPoint.properties.dist,\n          feature: feature,\n          path: path, // Index of the nearest segment\n          segment: feature.getSegmentVertices(path) ?? undefined,\n        };\n      }\n    } else if (feature instanceof Polygon) {\n      const lines = polygonToLine(feature) as Feature<\n        GeoLineString | MultiLineString\n      >;\n      let coords: Position[][];\n      if (lines.geometry.type === \"LineString\") {\n        // Polygon without holes\n        coords = [lines.geometry.coordinates];\n      } else {\n        // Polygon with holes\n        coords = lines.geometry.coordinates;\n      }\n      for (let i = 0; i < coords.length; i++) {\n        const lineCoords = coords[i];\n        const nearestPoint = nearestPointOnLine(\n          lineString(lineCoords),\n          pos.toArray(),\n        );\n        if (\n          !closestFeature ||\n          nearestPoint.properties.dist < closestFeature.dist\n        ) {\n          const path = `${i}.${nearestPoint.properties.index}`;\n          closestFeature = {\n            lngLat: LngLat.convert(\n              nearestPoint.geometry.coordinates as [number, number],\n            ),\n            dist: nearestPoint.properties.dist,\n            feature: feature,\n            path: path,\n            segment: feature.getSegmentVertices(path) ?? undefined,\n          };\n        }\n      }\n    }\n  }\n  return closestFeature;\n}\n","import { IControl, Map } from \"maplibre-gl\";\nimport $ from \"jquery\";\n\nimport {\n  createControlButton,\n  createControlContainer,\n  createMdiIcon,\n} from \"../controls/helpers\";\n\n/**\n * Options for the {@link DrawControl} class.\n */\nexport interface DrawControlOptions {\n  /**\n   * Callback for when the \"Draw Point\" button is clicked.\n   */\n  onDrawPoint: () => void;\n  /**\n   * Callback for when the \"Draw Line\" button is clicked.\n   */\n  onDrawLine: () => void;\n  /**\n   * Callback for when the \"Draw Area\" button is clicked.\n   */\n  onDrawPolygon: () => void;\n  /**\n   * The title of the \"Draw Point\" button.\n   */\n  drawPointButtonTitle?: string;\n  /**\n   * The title of the \"Draw Line\" button.\n   */\n  drawLineButtonTitle?: string;\n  /**\n   * The title of the \"Draw Area\" button.\n   */\n  drawPolygonButtonTitle?: string;\n}\n\n/**\n * A control that shows 3 buttons to draw points, lines and polygons.\n * When a button is clicked, it remains active until the {@link deactivateButton} method is called\n * for that button’s index. Indices are the following:\n * * 0: draw point button\n * * 1: draw line button\n * * 2: draw polygon button\n */\nexport default class DrawControl implements IControl {\n  readonly #container: HTMLDivElement;\n  readonly #buttons: HTMLButtonElement[] = [];\n\n  constructor(options: DrawControlOptions) {\n    this.#container = createControlContainer(\"maplibregl-ctrl-draw\");\n    this.#buttons.push(\n      createControlButton({\n        title: options.drawPointButtonTitle ?? \"Draw Point\",\n        icon: createMdiIcon(\"map-marker-outline\"),\n        onClick: (button) => {\n          button.classList.add(\"active\");\n          options.onDrawPoint();\n        },\n        shortcut: [\"1\"],\n      }),\n    );\n    this.#buttons.push(\n      createControlButton({\n        title: options.drawLineButtonTitle ?? \"Draw Line\",\n        icon: createMdiIcon(\"vector-line\"),\n        onClick: (button) => {\n          button.classList.add(\"active\");\n          options.onDrawLine();\n        },\n        shortcut: [\"2\"],\n      }),\n    );\n    this.#buttons.push(\n      createControlButton({\n        title: options.drawPolygonButtonTitle ?? \"Draw Area\",\n        icon: createMdiIcon(\"vector-polygon\"),\n        onClick: (button) => {\n          button.classList.add(\"active\");\n          options.onDrawPolygon();\n        },\n        shortcut: [\"3\"],\n      }),\n    );\n    $(\"body\").on(\"keydown\", (e) => {\n      const key = +e.key - 1;\n      if (key >= 0 && key < this.#buttons.length) this.#buttons[key].click();\n    });\n  }\n\n  /**\n   * Deactivate the button at the given index.\n   * @param index The button’s index. Should be between 0 and 3 inclusive.\n   */\n  deactivateButton(index: number): void {\n    this.#buttons[index]?.classList.remove(\"active\");\n  }\n\n  /**\n   * Disable/Enable the button at the given index.\n   * @param index The button’s index. Should be between 0 and 3 inclusive.\n   * @param disabled True to disable the button, false to enable it.\n   */\n  setButtonDisabled(index: number, disabled: boolean): void {\n    if (this.#buttons[index]) this.#buttons[index].disabled = disabled;\n  }\n\n  onAdd(_: Map): HTMLElement {\n    this.#container.append(...this.#buttons);\n    return this.#container;\n  }\n\n  onRemove(): void {\n    this.#container.parentNode?.removeChild(this.#container);\n  }\n}\n","export default abstract class Component {\n  abstract get container(): JQuery;\n\n  abstract get visible(): boolean;\n\n  abstract set visible(visible: boolean);\n}\n","import $ from \"jquery\";\n\nimport { ObjectType } from \"../../model/types\";\nimport Component from \"./_component\";\n\nexport interface FeatureTypeButtonConfig {\n  onClick: () => void;\n}\n\nexport default class FeatureTypeButton extends Component {\n  readonly #$button: JQuery<HTMLButtonElement>;\n  readonly #$buttonIcon: JQuery<HTMLImageElement>;\n  readonly #$buttonText: JQuery<HTMLSpanElement>;\n\n  constructor(config: FeatureTypeButtonConfig) {\n    super();\n    this.#$button = $(\n      `<button id=\"feature-type-btn\" class=\"btn btn-secondary\"></button>`,\n    );\n    this.#$button.on(\"click\", config.onClick);\n    // noinspection HtmlRequiredAltAttribute,RequiredAttributes\n    this.#$buttonIcon = $(\"<img>\");\n    this.#$buttonText = $(\"<span></span>\");\n    this.#$button.append(this.#$buttonIcon, this.#$buttonText);\n  }\n\n  get disabled(): boolean {\n    return !!this.#$button.prop(\"disabled\");\n  }\n\n  set disabled(disable: boolean) {\n    this.#$button.prop(\"disabled\", disable);\n  }\n\n  setFeatureType(type: ObjectType | null): void {\n    // TODO set icon\n    this.#$buttonText.text(type?.localizedName ?? \"\");\n  }\n\n  setFeatureTypes(types: ObjectType[]): void {\n    if (!types.length) {\n      this.setFeatureType(null);\n    } else {\n      // TODO set icon\n      const strings = types.map((t) => t.localizedName);\n      this.#$buttonText.text([...strings].join(\", \"));\n    }\n  }\n\n  get container(): JQuery {\n    return this.#$button;\n  }\n\n  get visible(): boolean {\n    return this.#$button.is(\":visible\");\n  }\n\n  set visible(visible: boolean) {\n    if (visible) this.#$button.show();\n    else this.#$button.hide();\n  }\n}\n","import { Map } from \"maplibre-gl\";\nimport $ from \"jquery\";\n\nimport { DataTypeProvider, MapFeature } from \"../../model/geometry\";\nimport { ObjectProperty, ObjectType } from \"../../model/types\";\nimport { FeatureHoverEvent, FeatureSelectionEvent } from \"../_events\";\nimport FeatureTypeButton from \"./_feature-type-button\";\n\nimport \"./index.css\";\n\nexport default class EditorPanel {\n  readonly #$panel: JQuery;\n  readonly #featureTypeButton: FeatureTypeButton;\n  readonly #selectedFeatures = new Set<MapFeature>();\n  readonly #dataTypeProvider: DataTypeProvider;\n\n  constructor(map: Map, dataTypeProvider: DataTypeProvider) {\n    this.#dataTypeProvider = dataTypeProvider;\n    this.#$panel = $(\"#editor-panel\").show();\n    this.#featureTypeButton = new FeatureTypeButton({\n      onClick: () => {\n        this.#onTypeButtonClick();\n      },\n    });\n    this.#featureTypeButton.visible = false;\n    this.#$panel.append(this.#featureTypeButton.container);\n    map.on(FeatureSelectionEvent.TYPE, (e: FeatureSelectionEvent) => {\n      this.#selectedFeatures.clear();\n      e.features.forEach((f) => {\n        this.#selectedFeatures.add(f);\n      });\n      this.#setupForm(e.features, true);\n    });\n    map.on(FeatureHoverEvent.TYPE, (e: FeatureHoverEvent) => {\n      if (!this.#selectedFeatures.size)\n        this.#setupForm(e.feature ? [e.feature] : [], false);\n    });\n  }\n\n  getContainer(): JQuery {\n    return this.#$panel;\n  }\n\n  #setupForm(features: MapFeature[], editable: boolean): void {\n    this.#reset();\n    if (features.length === 1) {\n      this.#setupSingleForm(features[0], editable);\n    } else {\n      this.#setupMultipleForm(features);\n    }\n  }\n\n  #reset(): void {\n    this.#featureTypeButton.disabled = true;\n    this.#setType(null);\n    // TODO\n  }\n\n  #setupSingleForm(feature: MapFeature, editable: boolean): void {\n    const type = feature.dataObject?.type ?? this.#getDefaultType(feature);\n    this.#featureTypeButton.disabled = !editable;\n    this.#setType(type);\n    type.properties.forEach((property) => {\n      this.#createFieldForProperty(property);\n      if (property.isUnique) {\n        const value = feature.dataObject?.getPropertyValue(property.label);\n        if (value !== null) {\n          this.#setFieldValue(property, value);\n        }\n      } else {\n        const values =\n          feature.dataObject?.getPropertyValues(property.label) ?? [];\n        this.#setFieldValues(property, values);\n      }\n    });\n  }\n\n  #setupMultipleForm(features: MapFeature[]): void {\n    const types = features.map(\n      (f) => f.dataObject?.type ?? this.#getDefaultType(f),\n    );\n    this.#featureTypeButton.disabled = true;\n    this.#featureTypeButton.visible = !!features.length;\n    this.#featureTypeButton.setFeatureTypes(types);\n    if (features.length) {\n      // TODO show only fields common to all features (as non-editable)\n    }\n  }\n\n  #setType(type: ObjectType | null): void {\n    this.#featureTypeButton.visible = !!type;\n    this.#featureTypeButton.setFeatureType(type);\n  }\n\n  #getDefaultType(feature: MapFeature): ObjectType {\n    return this.#dataTypeProvider(\n      feature.geometry.type.toLowerCase(),\n      \"ObjectType\",\n    );\n  }\n\n  #onTypeButtonClick(): void {\n    // TODO\n    console.log(\"type button clicked\"); // DEBUG\n  }\n\n  #createFieldForProperty(property: ObjectProperty<unknown>): void {\n    console.log(\"create field for\", property.fullName); // DEBUG\n    // TODO\n  }\n\n  #setFieldValue<T>(property: ObjectProperty<T>, value: T): void {\n    console.log(\"set field value for\", property.fullName, \"to\", value); // DEBUG\n    // TODO\n  }\n\n  #setFieldValues<T>(property: ObjectProperty<T>, values: T[]) {\n    console.log(\"set field values for\", property.fullName, \"to\", values); // DEBUG\n    // TODO\n  }\n}\n","import { LngLat, Map, Popup } from \"maplibre-gl\";\nimport $ from \"jquery\";\n\nimport OttmMap from \"../map\";\nimport {\n  createControlButton,\n  createControlContainer,\n  createMdiIcon,\n} from \"../controls/helpers\";\nimport \"./_context-menu.css\";\n\n/**\n * Options for the {@link ContextMenu} class.\n */\nexport interface ContextMenuOptions {\n  onMove: () => void;\n  onCopy: () => void;\n  onPaste: () => void;\n  onDelete: () => void;\n  onContinueLine: () => void;\n  onDisconnect: () => void;\n  onExtractPoint: () => void;\n  onSplit: () => void;\n  onCircularize: () => void;\n  onSquare: () => void;\n  onFlipLong: () => void;\n  onFlipShort: () => void;\n  onReverseLine: () => void;\n  onRotate: () => void;\n  onStraightenLine: () => void;\n  moveTitle?: string;\n  copyTitle?: string;\n  pasteTitle?: string;\n  deleteTitle?: string;\n  continueLineTitle?: string;\n  disconnectTitle?: string;\n  extractPointTitle?: string;\n  splitTitle?: string;\n  circularizeTitle?: string;\n  squareTitle?: string;\n  flipLongTitle?: string;\n  flipShortTitle?: string;\n  reverseLineTitle?: string;\n  rotateTitle?: string;\n  straightenLineTitle?: string;\n}\n\n/**\n * Options for the {@link ContextMenu.show} method.\n */\nexport interface ButtonStatesOptions {\n  move?: boolean;\n  copy?: boolean;\n  paste?: boolean;\n  delete?: boolean;\n  continueLine?: boolean;\n  disconnect?: boolean;\n  extractPoint?: boolean;\n  split?: boolean;\n  circularize?: boolean;\n  square?: boolean;\n  flipLong?: boolean;\n  flipShort?: boolean;\n  reverseLine?: boolean;\n  rotate?: boolean;\n  straightenLine?: boolean;\n  // TODO regularly distribute points\n}\n\nexport class ContextMenu {\n  readonly #map: Map;\n  readonly #popup: Popup;\n  readonly #container: HTMLElement;\n  readonly #buttons: {\n    move: HTMLButtonElement;\n    copy: HTMLButtonElement;\n    paste: HTMLButtonElement;\n    delete: HTMLButtonElement;\n    continueLine: HTMLButtonElement;\n    disconnect: HTMLButtonElement;\n    extractPoint: HTMLButtonElement;\n    split: HTMLButtonElement;\n    circularize: HTMLButtonElement;\n    square: HTMLButtonElement;\n    flipLong: HTMLButtonElement;\n    flipShort: HTMLButtonElement;\n    reverseLine: HTMLButtonElement;\n    rotate: HTMLButtonElement;\n    straightenLine: HTMLButtonElement;\n    // TODO regularly distribute points\n  };\n\n  constructor(map: Map, options: ContextMenuOptions) {\n    this.#map = map;\n    this.#container = createControlContainer(\n      \"map-editor-context-menu-container\",\n    );\n    this.#buttons = {\n      move: createControlButton({\n        title: options.moveTitle ?? \"Move\",\n        icon: createMdiIcon(\"cursor-move\"),\n        onClick: () => {\n          this.#performAction(options.onMove);\n        },\n        shortcut: [\"M\"],\n      }),\n      copy: createControlButton({\n        title: options.copyTitle ?? \"Copy\",\n        icon: createMdiIcon(\"content-copy\"),\n        onClick: () => {\n          this.#performAction(options.onCopy);\n        },\n        shortcut: [\"Ctrl\", \"C\"],\n      }),\n      paste: createControlButton({\n        title: options.pasteTitle ?? \"Paste\",\n        icon: createMdiIcon(\"content-paste\"),\n        onClick: () => {\n          this.#performAction(options.onPaste);\n        },\n        shortcut: [\"Ctrl\", \"V\"],\n      }),\n      delete: createControlButton({\n        title: options.deleteTitle ?? \"Delete\",\n        icon: createMdiIcon(\"trash-can-outline\"),\n        onClick: () => {\n          this.#performAction(options.onDelete);\n        },\n        shortcut: [\"Ctrl\", \"Backspace\"],\n      }),\n      continueLine: createControlButton({\n        title: options.continueLineTitle ?? \"Continue Line\",\n        icon: createMdiIcon(\"ray-start-arrow\"),\n        onClick: () => {\n          this.#performAction(options.onContinueLine);\n        },\n        shortcut: [\"A\"],\n      }),\n      disconnect: createControlButton({\n        title: options.disconnectTitle ?? \"Disconnect\",\n        icon: createMdiIcon(\"pan-horizontal\"),\n        onClick: () => {\n          this.#performAction(options.onDisconnect);\n        },\n        shortcut: [\"D\"],\n      }),\n      extractPoint: createControlButton({\n        title: options.extractPointTitle ?? \"Extract Point\",\n        icon: createMdiIcon(\"pan-top-right\"),\n        onClick: () => {\n          this.#performAction(options.onExtractPoint);\n        },\n        shortcut: [\"E\"],\n      }),\n      split: createControlButton({\n        title: options.splitTitle ?? \"Split\",\n        icon: createMdiIcon(\"content-cut\"),\n        onClick: () => {\n          this.#performAction(options.onSplit);\n        },\n        shortcut: [\"X\"],\n      }),\n      circularize: createControlButton({\n        title: options.circularizeTitle ?? \"Circularize\",\n        icon: createMdiIcon(\"vector-circle\"),\n        onClick: () => {\n          this.#performAction(options.onCircularize);\n        },\n        shortcut: [\"O\"],\n      }),\n      square: createControlButton({\n        title: options.squareTitle ?? \"Square\",\n        icon: createMdiIcon(\"vector-square\"),\n        onClick: () => {\n          this.#performAction(options.onSquare);\n        },\n        shortcut: [\"Q\"],\n      }),\n      flipLong: createControlButton({\n        title: options.flipLongTitle ?? \"Flip Long\",\n        icon: createMdiIcon(\"dock-top\"),\n        onClick: () => {\n          this.#performAction(options.onFlipLong);\n        },\n        shortcut: [\"T\"],\n      }),\n      flipShort: createControlButton({\n        title: options.flipShortTitle ?? \"Flip Short\",\n        icon: createMdiIcon(\"dock-left\"),\n        onClick: () => {\n          this.#performAction(options.onFlipShort);\n        },\n        shortcut: [\"Y\"],\n      }),\n      reverseLine: createControlButton({\n        title: options.reverseLineTitle ?? \"Reverse Line\",\n        icon: createMdiIcon(\"chevron-double-left\"),\n        onClick: () => {\n          this.#performAction(options.onReverseLine);\n        },\n        shortcut: [\"V\"],\n      }),\n      rotate: createControlButton({\n        title: options.rotateTitle ?? \"Rotate\",\n        icon: createMdiIcon(\"backup-restore\"),\n        onClick: () => {\n          this.#performAction(options.onRotate);\n        },\n        shortcut: [\"R\"],\n      }),\n      straightenLine: createControlButton({\n        title: options.straightenLineTitle ?? \"Straighten Line\",\n        icon: createMdiIcon(\"ray-start-vertex-end\"),\n        onClick: () => {\n          this.#performAction(options.onStraightenLine);\n        },\n        shortcut: [\"S\"],\n      }),\n    };\n    $(\"body\").on(\"keydown\", (e) => {\n      if (this.#map instanceof OttmMap && this.#map.textFieldHasFocus) return;\n      switch (e.key) {\n        case \"v\":\n          if (e.ctrlKey) this.#performAction(options.onPaste);\n          else this.#performAction(options.onReverseLine);\n          break;\n        case \"c\":\n          if (e.ctrlKey) this.#performAction(options.onCopy);\n          break;\n        case \"m\":\n          this.#performAction(options.onMove);\n          break;\n        case \"Backspace\":\n          if (e.ctrlKey) this.#performAction(options.onDelete);\n          break;\n        case \"a\":\n          this.#performAction(options.onContinueLine);\n          break;\n        case \"d\":\n          this.#performAction(options.onDisconnect);\n          break;\n        case \"e\":\n          this.#performAction(options.onExtractPoint);\n          break;\n        case \"x\":\n          this.#performAction(options.onSplit);\n          break;\n        case \"o\":\n          this.#performAction(options.onCircularize);\n          break;\n        case \"q\":\n          this.#performAction(options.onSquare);\n          break;\n        case \"t\":\n          this.#performAction(options.onFlipLong);\n          break;\n        case \"y\":\n          this.#performAction(options.onFlipShort);\n          break;\n        case \"r\":\n          this.#performAction(options.onRotate);\n          break;\n        case \"s\":\n          this.#performAction(options.onStraightenLine);\n          break;\n      }\n    });\n    this.#container.append(\n      this.#buttons.move,\n      this.#buttons.continueLine,\n      this.#buttons.disconnect,\n      this.#buttons.split,\n      this.#buttons.circularize,\n      this.#buttons.square,\n      this.#buttons.flipLong,\n      this.#buttons.flipShort,\n      this.#buttons.reverseLine,\n      this.#buttons.rotate,\n      this.#buttons.straightenLine,\n      this.#buttons.copy,\n      this.#buttons.paste,\n      this.#buttons.delete,\n    );\n    this.#popup = new Popup().setDOMContent(this.#container);\n    this.#popup._closeButton.style.display = \"none\";\n  }\n\n  /**\n   * Show this menu at the given coordinates on the map.\n   * If all buttons are disabled, the menu will not be shown.\n   * @param at The coordinates to show this menu at.\n   * @param buttonStates The states of this menu’s buttons.\n   * The states of each button may be either `true` to enable, `false` to disable.\n   * Any disabled button will not be shown.\n   */\n  show(at: LngLat, buttonStates: ButtonStatesOptions = {}): void {\n    this.#container.style.display = \"block\";\n    let anyEnabled = false;\n    for (const [key, button] of Object.entries(this.#buttons)) {\n      const enabled = buttonStates[key as keyof ButtonStatesOptions];\n      this.#setButtonState(button, !!enabled);\n      if (enabled) anyEnabled = true;\n    }\n    if (anyEnabled) {\n      this.#popup.setLngLat(at).addTo(this.#map);\n      this.#popup.addClassName(\"map-editor-context-menu\");\n    }\n  }\n\n  /**\n   * Hide this context menu.\n   */\n  hide(): void {\n    this.#popup.remove();\n    this.#container.style.display = \"none\";\n    for (const button of Object.values(this.#buttons))\n      this.#setButtonState(button, false);\n  }\n\n  /**\n   * Indicate whether this context menu is visible.\n   * @returns True if it is, false otherwise.\n   */\n  isVisible(): boolean {\n    return this.#popup.isOpen();\n  }\n\n  /**\n   * Set the state of the given button.\n   * @param button The button.\n   * @param enable The state.\n   */\n  #setButtonState(button: HTMLButtonElement, enable: boolean): void {\n    button.style.display = enable ? \"block\" : \"none\";\n    button.disabled = !enable;\n  }\n\n  /**\n   * Perform the specified action then hide this menu.\n   * @param action The function to call.\n   */\n  #performAction(action: () => void): void {\n    action();\n    this.hide();\n  }\n}\n","import {\n  ColorSpecification,\n  DataDrivenPropertyValueSpecification,\n  FilterSpecification,\n  GeoJSONSource,\n  LngLat,\n  Map as MglMap,\n  MapMouseEvent,\n  MapTouchEvent,\n  PointLike,\n} from \"maplibre-gl\";\nimport $ from \"jquery\";\nimport Split from \"split.js\";\n\nimport { Dict } from \"../../types\";\nimport {\n  Action,\n  DataTypeProvider,\n  DataTypes,\n  LinearFeature,\n  LineString,\n  LngLatVector,\n  MapFeature,\n  Point,\n  Polygon,\n  PolylineDirection,\n  SelectionMode,\n} from \"../model/geometry\";\nimport {\n  Enum,\n  EnumProperty,\n  FloatProperty,\n  ObjectInstance,\n  ObjectType,\n  Unit,\n  UnitType,\n} from \"../model/types\";\nimport OttmMap from \"../map\";\nimport { isSecondaryClick } from \"../utils\";\nimport { FeatureHoverEvent, FeatureSelectionEvent } from \"./_events\";\nimport { SnapResult, trySnapPoint } from \"./_snap\";\nimport DrawControl from \"./_controls\";\nimport EditorPanel from \"./_side-panel\";\nimport { ButtonStatesOptions, ContextMenu } from \"./_context-menu\";\n\nimport \"./_index.css\";\n\n/**\n * Enumeration of the map editor’s modes.\n */\nenum EditMode {\n  VIEW_ONLY = \"view_only\",\n  SELECT = \"select\",\n  DRAW_POINT = \"draw_point\",\n  DRAW_LINE = \"draw_line\",\n  DRAW_POLYGON = \"draw_polygon\",\n  MOVE_FEATURES = \"move_features\",\n}\n\n/**\n * Enumeration of available map cursors.\n */\nenum Cursor {\n  POINT = \"point\",\n  LINE = \"linestring\",\n  POLYGON = \"polygon\",\n  DRAW = \"draw\",\n  GRAB = \"grab\",\n  GRABBING = \"grabbing\",\n  CONNECT_VERTEX = \"draw-connect-vertex\",\n  CONNECT_LINE = \"draw-connect-line\",\n}\n\ntype GeometrySpecification =\n  | PointSpecification\n  | LineStringSpecification\n  | PolygonSpecification;\n\ninterface GeomSpecBase {\n  dbId: number;\n  layer?: number;\n  dataObject?: ObjectInstance;\n}\n\ntype PointSpecification = GeomSpecBase & {\n  type: \"Point\";\n  lng: number;\n  lat: number;\n};\ntype LineStringSpecification = GeomSpecBase & {\n  type: \"LineString\";\n  verticesDbIds: number[];\n};\ntype PolygonSpecification = GeomSpecBase & {\n  type: \"Polygon\";\n  verticesDbIds: number[][];\n};\n\nclass MapEditor {\n  static readonly #HIGHLIGHT_BASE_COLOR: string = \"#00000000\";\n  static readonly #HIGHLIGHT_SELECTED_COLOR: string = \"#3bb2d0d0\";\n  static readonly #HIGHLIGHT_HOVERED_COLOR: string = \"#ff6d8bd0\";\n\n  static readonly #BORDER_COLOR: string = \"#101010\";\n  static readonly #NON_EDITABLE_COLOR: string = \"#e0e0e0\";\n\n  /**\n   * The minimal allowed zoom to edit features.\n   */\n  static readonly #EDIT_MIN_ZOOM: number = 15;\n\n  readonly #map: MglMap;\n  readonly #$canvasContainer: JQuery;\n  readonly #sidePanel: EditorPanel;\n  readonly #contextMenu: ContextMenu;\n  readonly #$editZoomNoticePanel: JQuery;\n  readonly #drawPointControl: DrawControl;\n  /**\n   * All the features currently managed by this editor.\n   */\n  readonly #features = new Map<string, MapFeature>();\n  /**\n   * Maps a point geometry’s database ID to the corresponding point feature.\n   */\n  readonly #dbIdToPoint = new Map<number, Point>();\n  /**\n   * The currently selected features.\n   */\n  readonly #selectedFeatures = new Set<MapFeature>();\n  /**\n   * The feature currently being hovered by the mouse cursor.\n   */\n  #hoveredFeature: MapFeature | null = null;\n  /**\n   * The current edit mode.\n   */\n  #editMode: EditMode = EditMode.VIEW_ONLY;\n  /**\n   * The point currently being dragged.\n   */\n  #draggedPoint: Point | null = null;\n  /**\n   * If a point is being dragged and snaps to another feature,\n   * this field contains relevant data to that snapped feature.\n   */\n  #snapResult:\n    | (SnapResult & {\n        /**\n         * The list of features that have the same segment as the snapped one.\n         */\n        featuresWithSameSegment?: {\n          /**\n           * The feature.\n           */\n          feature: LinearFeature;\n          /**\n           * The path to the segment on the feature.\n           */\n          path: string;\n        }[];\n      })\n    | null = null;\n  /**\n   * The points currently being moved.\n   */\n  #movedPoints: {\n    /**\n     * A point being moved.\n     */\n    point: Point;\n    /**\n     * The point’s distance to the mouse cursor.\n     */\n    offset: LngLatVector;\n    /**\n     * The point’s position before being moved.\n     */\n    startPos: LngLat;\n  }[] = [];\n  /**\n   * The line string currently being drawn.\n   */\n  #drawnLineString: LineString | null = null;\n  /**\n   * When drawing a line, indicates where the next point will be added on that line:\n   * * `true`: at the end.\n   * * `false`: at the start.\n   */\n  #drawnStringAppendEnd = true;\n  /**\n   * The polygon currently being drawn.\n   */\n  #drawnPolygon: Polygon | null = null;\n  /**\n   * The points that were created when drawing the last linear feature.\n   * This list is used for deleting all points that were drawn when the current drawing is cancelled.\n   */\n  readonly #drawnPoints: Point[] = [];\n  /**\n   * The last known position of the mouse on the map.\n   */\n  #mousePositionCache: LngLat | null = null;\n\n  /**\n   * Internal cache of available data types.\n   */\n  readonly #dataTypes: {\n    units: Dict<UnitType>;\n    enums: Dict<Enum>;\n    objects: Dict<ObjectType>;\n  } = {\n    units: {},\n    enums: {},\n    objects: {},\n  };\n\n  #lastFeatureId = 0;\n\n  // TODO find a way to add holes to polygons\n\n  /**\n   * Create a new editor for the given map.\n   * @param map A map.\n   * @param dataTypes All available data types.\n   */\n  constructor(\n    map: MglMap,\n    dataTypes: {\n      units: Dict<UnitType>;\n      enums: Dict<Enum>;\n      objects: Dict<ObjectType>;\n    },\n  ) {\n    this.#dataTypes.units = { ...dataTypes.units };\n    this.#dataTypes.enums = { ...dataTypes.enums };\n    this.#dataTypes.objects = { ...dataTypes.objects };\n    this.#map = map;\n    this.#$canvasContainer = $(this.#map.getCanvasContainer());\n    this.#sidePanel = new EditorPanel(this.#map, (n, t) =>\n      this.#getDataType(n, t),\n    );\n    this.#contextMenu = new ContextMenu(this.#map, {\n      onMove: () => {\n        this.#moveSelectedFeatures();\n      },\n      moveTitle: window.ottm.translate(\"map.context_menu.move.tooltip\"),\n      onCopy: () => {\n        this.#copySelectedFeatures();\n      },\n      copyTitle: window.ottm.translate(\"map.context_menu.copy.tooltip\"),\n      onPaste: () => {\n        this.#pasteFeatures();\n      },\n      pasteTitle: window.ottm.translate(\"map.context_menu.paste.tooltip\"),\n      onDelete: () => {\n        this.#deleteSelectedFeatures();\n      },\n      deleteTitle: window.ottm.translate(\"map.context_menu.delete.tooltip\"),\n      onContinueLine: () => {\n        this.#continueSelectedLine();\n      },\n      continueLineTitle: window.ottm.translate(\n        \"map.context_menu.continue_line.tooltip\",\n      ),\n      onDisconnect: () => {\n        this.#disconnectSelectedVertices();\n      },\n      disconnectTitle: window.ottm.translate(\n        \"map.context_menu.disconnect.tooltip\",\n      ),\n      onExtractPoint: () => {\n        this.#extractSelectedVertices();\n      },\n      extractPointTitle: window.ottm.translate(\n        \"map.context_menu.extract_point.tooltip\",\n      ),\n      onSplit: () => {\n        this.#splitSelectedLines();\n      },\n      splitTitle: window.ottm.translate(\"map.context_menu.split.tooltip\"),\n      onCircularize: () => {\n        this.#circularizeSelectedFeatures();\n      },\n      circularizeTitle: window.ottm.translate(\n        \"map.context_menu.circularize.tooltip\",\n      ),\n      onSquare: () => {\n        this.#squareSelectedFeatures();\n      },\n      squareTitle: window.ottm.translate(\"map.context_menu.square.tooltip\"),\n      onFlipLong: () => {\n        this.#flipLongSelectedFeatures();\n      },\n      flipLongTitle: window.ottm.translate(\n        \"map.context_menu.flip_long.tooltip\",\n      ),\n      onFlipShort: () => {\n        this.#flipShortSelectedFeatures();\n      },\n      flipShortTitle: window.ottm.translate(\n        \"map.context_menu.flip_short.tooltip\",\n      ),\n      onReverseLine: () => {\n        this.#reverseSelectedLines();\n      },\n      reverseLineTitle: window.ottm.translate(\n        \"map.context_menu.reverse_line.tooltip\",\n      ),\n      onRotate: () => {\n        this.#rotateSelectedFeatures();\n      },\n      rotateTitle: window.ottm.translate(\"map.context_menu.rotate.tooltip\"),\n      onStraightenLine: () => {\n        this.#straightenSelectedLines();\n      },\n      straightenLineTitle: window.ottm.translate(\n        \"map.context_menu.straighten_line.tooltip\",\n      ),\n    });\n    this.#drawPointControl = new DrawControl({\n      onDrawPoint: () => {\n        if (this.#editMode === EditMode.DRAW_POINT) {\n          this.#disableDrawPointMode();\n        } else {\n          this.#enableDrawPointMode();\n        }\n      },\n      onDrawLine: () => {\n        if (this.#editMode === EditMode.DRAW_LINE) {\n          this.#disableDrawLineMode();\n        } else {\n          this.#enableDrawLineMode();\n        }\n      },\n      onDrawPolygon: () => {\n        if (this.#editMode === EditMode.DRAW_POLYGON) {\n          this.#disableDrawPolygonMode();\n        } else {\n          this.#enableDrawPolygonMode();\n        }\n      },\n      drawPointButtonTitle: window.ottm.translate(\n        \"map.controls.edit.draw_point.tooltip\",\n      ),\n      drawLineButtonTitle: window.ottm.translate(\n        \"map.controls.edit.draw_line.tooltip\",\n      ),\n      drawPolygonButtonTitle: window.ottm.translate(\n        \"map.controls.edit.draw_polygon.tooltip\",\n      ),\n    });\n    this.#map.addControl(this.#drawPointControl, \"top-left\");\n    this.#map.dragRotate.disable();\n\n    // Setup map callbacks\n    this.#map.on(\"click\", (e) => {\n      this.#onClick(e);\n    });\n    this.#map.on(\"dblclick\", (e) => {\n      this.#onDoubleClick(e);\n    });\n    this.#map.on(\"mousemove\", (e) => {\n      this.#onMouseMouve(e);\n    });\n    this.#map.on(\"touchmove\", (e) => {\n      if (e.points.length !== 1) {\n        return;\n      }\n      this.#onMouseMouve(e);\n    });\n    this.#map.on(\"mousedown\", (e) => {\n      this.#onMouseDown(e);\n    });\n    this.#map.on(\"touchstart\", (e) => {\n      if (e.points.length !== 1) {\n        return;\n      }\n      this.#onMouseDown(e);\n    });\n    this.#map.on(\"mouseup\", (e) => {\n      this.#onMouseUp(e);\n    });\n    this.#map.on(\"touchend\", (e) => {\n      if (e.points.length !== 1) {\n        return;\n      }\n      this.#onMouseUp(e);\n    });\n    this.#map.on(\"controls.styles.tiles_changed\", () => {\n      if (this.#map.getLayersOrder().length) {\n        // Put tiles layer beneath every other feature (i.e. the lowest one)\n        this.#map.moveLayer(\"tiles\", this.#map.getLayersOrder()[0]);\n      }\n    });\n    this.#map.on(\"zoomstart\", () => {\n      this.#onZoomChangeStart();\n    });\n    this.#map.on(\"zoomend\", () => {\n      this.#onZoomChangeEnd();\n    });\n    this.#map.on(\"load\", () => {\n      this.#onZoomChangeEnd();\n    });\n    $(\"body\").on(\"keydown\", (e) => {\n      if (\n        e.originalEvent &&\n        (!(this.#map instanceof OttmMap) || !this.#map.textFieldHasFocus)\n      )\n        this.#onKeyDown(e.originalEvent);\n    });\n\n    // Setup splitter\n    const canvasContainerParent = this.#$canvasContainer.parent();\n    canvasContainerParent.addClass(\"split\");\n    const sidePanelContainer = this.#sidePanel.getContainer();\n    sidePanelContainer.addClass(\"split\");\n    Split([sidePanelContainer[0], canvasContainerParent[0]], {\n      sizes: [20, 80],\n      minSize: [0, 100],\n      gutterSize: 5,\n    });\n\n    // Setup edit zoom notice panel\n    const message = window.ottm.translate(\"map.edit_zoom_notice\");\n    this.#$editZoomNoticePanel = $(`\n<div id=\"edit-zoom-notice-panel\">\n  <span class=\"mdi mdi-plus\"></span> ${message}\n</div>\n`);\n    this.#$editZoomNoticePanel.on(\"click\", () => {\n      this.#map.easeTo({ zoom: MapEditor.#EDIT_MIN_ZOOM });\n    });\n    canvasContainerParent.append(this.#$editZoomNoticePanel);\n  }\n\n  /**\n   * Create a {@link MapFeature} for the given specification and add it to the map.\n   * @param geomSpec The specification to create a feature from.\n   */\n  createFeature(geomSpec: GeometrySpecification): void {\n    const getPoints = (verticesIds: number[]) => {\n      return verticesIds.map((id) => {\n        const point = this.#dbIdToPoint.get(id);\n        if (!point) throw new Error(`No point with ID ${id}`);\n        return point;\n      });\n    };\n    const typeProvider: DataTypeProvider = (n, t) => this.#getDataType(n, t);\n\n    const id = this.#getNextFeatureId();\n    if (geomSpec.type === \"Point\") {\n      const coords = new LngLat(geomSpec.lng, geomSpec.lat);\n      this.#addFeature(\n        new Point(\n          id,\n          typeProvider,\n          coords,\n          geomSpec.dbId,\n          geomSpec.layer,\n          geomSpec.dataObject,\n        ),\n      );\n    } else if (geomSpec.type === \"LineString\") {\n      const points = getPoints(geomSpec.verticesDbIds);\n      this.#addFeature(\n        new LineString(\n          id,\n          typeProvider,\n          points,\n          geomSpec.dbId,\n          geomSpec.layer,\n          geomSpec.dataObject,\n        ),\n      );\n    } else {\n      const points = geomSpec.verticesDbIds.map((ids) => getPoints(ids));\n      this.#addFeature(\n        new Polygon(\n          id,\n          typeProvider,\n          points,\n          geomSpec.dbId,\n          geomSpec.layer,\n          geomSpec.dataObject,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Get the data type for the given name and type string.\n   * @param typeName The type’s name.\n   * @param metaType A string representing the class of the type to return.\n   * @returns The type for the given name or undefined if it does not exist.\n   */\n  #getDataType<K extends keyof DataTypes>(\n    typeName: string,\n    metaType: K,\n  ): DataTypes[K] {\n    switch (metaType) {\n      case \"UnitType\":\n        return this.#dataTypes.units[typeName] as DataTypes[K];\n      case \"Enum\":\n        return this.#dataTypes.enums[typeName] as DataTypes[K];\n      case \"ObjectType\":\n        return this.#dataTypes.objects[typeName] as DataTypes[K];\n      default:\n        throw new Error(`Invalid value \"${metaType}\"`);\n    }\n  }\n\n  /**\n   * Return the next available feature ID.\n   * Updates the global counter.\n   */\n  #getNextFeatureId(): string {\n    return (this.#lastFeatureId++).toString();\n  }\n\n  /**\n   * Add the given feature to the map.\n   * @param feature The feature to add.\n   */\n  #addFeature(feature: MapFeature): void {\n    // TODO handle z-order\n    // TODO put linestrings over polygons with the same z-order\n    if (feature.id && this.#features.get(feature.id)) return;\n\n    this.#features.set(feature.id, feature);\n    if (feature instanceof Point) {\n      if (feature.dbId) this.#dbIdToPoint.set(feature.dbId, feature);\n    } else if (feature instanceof LineString) {\n      // Add all vertices\n      feature.vertices.forEach((v) => {\n        this.#addFeature(v);\n      });\n    } else if (feature instanceof Polygon) {\n      // Add all vertices\n      feature.vertices\n        .flatMap((s) => s)\n        .forEach((v) => {\n          this.#addFeature(v);\n        });\n    }\n\n    this.#map.addSource(feature.id, {\n      type: \"geojson\",\n      data: feature,\n    });\n    this.#addLayersForFeature(feature);\n    // Put all points above all current features\n    if (feature instanceof LineString) {\n      feature.vertices.forEach((v) => {\n        this.#moveLayers(v.id);\n        this.#updateFeatureData(v);\n      });\n    } else if (feature instanceof Polygon) {\n      feature.vertices\n        .flatMap((s) => s)\n        .forEach((v) => {\n          this.#moveLayers(v.id);\n          this.#updateFeatureData(v);\n        });\n    }\n  }\n\n  /**\n   * Delete the feature with the given ID.\n   * Bound features are updated.\n   * @param featureId The ID of the feature to delete.\n   */\n  #removeFeature(featureId: string): void {\n    const feature = this.#features.get(featureId);\n    if (!feature) return;\n\n    this.#getLayerIdStack(featureId)?.forEach((id) => {\n      this.#map.removeLayer(id);\n    });\n    // Remove now to avoid potential infinite recursions\n    this.#features.delete(featureId);\n\n    if (feature instanceof Point) {\n      if (feature.dbId) this.#dbIdToPoint.delete(feature.dbId);\n      this.#updateBoundFeaturesOfDeletedPoint(feature);\n    } else if (feature instanceof LineString) {\n      this.#deleteVerticesOfDeletedLineString(feature);\n    } else if (feature instanceof Polygon) {\n      this.#deleteVerticesOfDeletedPolygon(feature);\n    }\n\n    this.#map.removeSource(featureId);\n    this.#selectedFeatures.delete(feature);\n    if (this.#hoveredFeature?.id === featureId) this.#hoveredFeature = null;\n  }\n\n  /**\n   * Update the bound features of the specified deleted point.\n   * @param point The point that is being deleted.\n   */\n  #updateBoundFeaturesOfDeletedPoint(point: Point): void {\n    point.boundFeatures.forEach((boundFeature) => {\n      point.unbindFeature(boundFeature);\n      const action = boundFeature.removeVertex(point);\n      let deletedBound = false;\n      if (action.type === \"delete_feature\") {\n        this.#removeFeature(boundFeature.id);\n        deletedBound = true;\n      } else if (action.type === \"delete_ring\") {\n        (boundFeature as Polygon).deleteRing(action.ringIndex);\n        // Delete vertices that were only bound to the feature\n        action.points.forEach((p) => {\n          if (p.boundFeatures.length === 0) this.#removeFeature(p.id);\n        });\n      }\n      if (!deletedBound) this.#updateFeatureData(boundFeature);\n    });\n  }\n\n  /**\n   * Delete the vertices that were only bound to the given deleted line.\n   * @param line The line being deleted.\n   */\n  #deleteVerticesOfDeletedLineString(line: LineString): void {\n    this.#deleteVerticesOfDeletedLinearFeature(line, line.vertices);\n  }\n\n  /**\n   * Delete the vertices that were only bound to the given deleted polygon.\n   * @param polygon The polygon being deleted.\n   */\n  #deleteVerticesOfDeletedPolygon(polygon: Polygon): void {\n    polygon.vertices.forEach((ring) => {\n      this.#deleteVerticesOfDeletedLinearFeature(polygon, ring);\n    });\n  }\n\n  /**\n   * Delete the vertices that were only bound to the given deleted linear feature.\n   * @param feature The feature being deleted.\n   * @param vertices An array of vertices to check for deletion.\n   */\n  #deleteVerticesOfDeletedLinearFeature(\n    feature: LinearFeature,\n    vertices: Point[],\n  ): void {\n    vertices.forEach((vertex) => {\n      vertex.unbindFeature(feature);\n      if (vertex.boundFeatures.length === 0) this.#removeFeature(vertex.id);\n      else this.#updateFeatureData(vertex);\n    });\n  }\n\n  /**\n   * Quit the current edit mode. Any ongoing drawing is interrupted.\n   * @param mousePos The current mouse position. Used to refresh the cursor.\n   */\n  #disableCurrentEditMode(mousePos?: PointLike): void {\n    switch (this.#editMode) {\n      case EditMode.VIEW_ONLY:\n      case EditMode.SELECT:\n        this.#refreshCursor(mousePos);\n        break;\n      case EditMode.DRAW_POINT:\n        this.#disableDrawPointMode(mousePos);\n        break;\n      case EditMode.DRAW_LINE:\n        this.#disableDrawLineMode(mousePos);\n        break;\n      case EditMode.DRAW_POLYGON:\n        this.#disableDrawPolygonMode(mousePos);\n        break;\n      case EditMode.MOVE_FEATURES:\n        this.#disableMoveFeaturesMode();\n        break;\n    }\n  }\n\n  /**\n   * Enable the \"draw_point\" mode.\n   */\n  #enableDrawPointMode(): void {\n    if (this.#editMode === EditMode.VIEW_ONLY) return;\n    this.#disableCurrentEditMode();\n    this.#editMode = EditMode.DRAW_POINT;\n    this.#setCanvasCursor(Cursor.DRAW);\n  }\n\n  /**\n   * Disable the \"draw_point\" mode and go back to \"select\" mode.\n   * Any ongoing drawing is interrupted.\n   * @param mousePos The current mouse position.\n   */\n  #disableDrawPointMode(mousePos?: PointLike): void {\n    this.#editMode = EditMode.SELECT;\n    this.#refreshCursor(mousePos);\n    this.#drawPointControl.deactivateButton(0);\n  }\n\n  /**\n   * Enable the \"draw_line\" mode.\n   * If one or both of the arguments are not specified,\n   * or the point is not at one end of the line, a new line is created.\n   * @param line Optional. The line to continue drawing.\n   * @param from If \"line\" is specified, the point to continue drawing from.\n   * Must be at one end of the specified line.\n   */\n  #enableDrawLineMode(line?: LineString, from?: Point): void {\n    if (this.#editMode === EditMode.VIEW_ONLY) return;\n    this.#disableCurrentEditMode();\n    this.#editMode = EditMode.DRAW_LINE;\n    if (line && from && line.isEndVertex(from)) {\n      this.#drawnLineString = line;\n      this.#draggedPoint = this.#createNewPoint(from.lngLat);\n      this.#drawnStringAppendEnd = line.vertices.indexOf(from) !== 0;\n      if (this.#drawnStringAppendEnd) {\n        this.#drawnLineString.appendVertex(\n          this.#draggedPoint,\n          this.#drawnLineString.getNextVertexPath(),\n        );\n      } else {\n        this.#drawnLineString.appendVertex(this.#draggedPoint, \"0\");\n      }\n      this.#updateFeatureData(this.#drawnLineString);\n    } else {\n      this.#drawnLineString = new LineString(this.#getNextFeatureId(), (n, t) =>\n        this.#getDataType(n, t),\n      );\n      this.#addFeature(this.#drawnLineString);\n    }\n    this.#setCanvasCursor(Cursor.DRAW);\n  }\n\n  /**\n   * Disable the \"draw_line\" mode and go back to \"select\" mode.\n   * Any ongoing drawing is interrupted.\n   * @param mousePos The current mouse position.\n   */\n  #disableDrawLineMode(mousePos?: PointLike): void {\n    if (!this.#drawnLineString) return;\n    this.#quitLinearDrawing(this.#drawnLineString, 1, mousePos);\n    this.#drawnLineString = null;\n  }\n\n  /**\n   * Enable the \"draw_polygon\" mode.\n   */\n  #enableDrawPolygonMode(): void {\n    if (this.#editMode === EditMode.VIEW_ONLY) return;\n    this.#disableCurrentEditMode();\n    this.#editMode = EditMode.DRAW_POLYGON;\n    this.#drawnPolygon = new Polygon(this.#getNextFeatureId(), (n, t) =>\n      this.#getDataType(n, t),\n    );\n    this.#addFeature(this.#drawnPolygon);\n    this.#setCanvasCursor(Cursor.DRAW);\n  }\n\n  /**\n   * Disable the \"draw_polygon\" mode and go back to \"select\" mode.\n   * Any ongoing drawing is interrupted.\n   * @param mousePos The current mouse position.\n   */\n  #disableDrawPolygonMode(mousePos?: PointLike): void {\n    if (!this.#drawnPolygon) return;\n    this.#quitLinearDrawing(this.#drawnPolygon, 2, mousePos, () => {\n      this.#drawnPolygon?.lockRing(0);\n    });\n    this.#drawnPolygon = null;\n  }\n\n  /**\n   * Quit the current \"draw_line\" or \"draw_polygon\" mode and go back to \"select\" mode.\n   * @param feature The feature currently being drawn.\n   * @param buttonIndex The index of the draw control button to deactivate.\n   * @param mousePos The current mouse position.\n   * @param onValidDrawing Callback called when the current drawing finishes normally.\n   */\n  #quitLinearDrawing(\n    feature: LinearFeature,\n    buttonIndex: number,\n    mousePos?: PointLike,\n    onValidDrawing?: () => void,\n  ): void {\n    this.#editMode = EditMode.SELECT;\n    let action: Action | null = null;\n    if (this.#draggedPoint) {\n      action = feature.removeVertex(this.#draggedPoint);\n      this.#removeFeature(this.#draggedPoint.id);\n      this.#draggedPoint = null;\n    }\n    if (action?.type === \"delete_feature\") {\n      // FIXME prevent deletion of pre-existing isolated points\n      this.#removeFeature(feature.id);\n      this.#drawnPoints.forEach((p) => {\n        this.#removeFeature(p.id);\n      });\n    } else {\n      if (feature.isEmpty()) {\n        this.#removeFeature(feature.id);\n      } else {\n        onValidDrawing?.();\n        this.#updateFeatureData(feature);\n        this.#selectFeature(feature, false);\n      }\n    }\n    this.#drawnPoints.splice(0);\n    this.#refreshCursor(mousePos);\n    this.#drawPointControl.deactivateButton(buttonIndex);\n  }\n\n  /**\n   * Quit the current \"move_features\" mode and go back to \"select\" mode.\n   * All features that were moved are put back to their position before being moved.\n   */\n  #disableMoveFeaturesMode() {\n    this.#editMode = EditMode.SELECT;\n    const features = new Set<LinearFeature>();\n    this.#movedPoints.forEach(({ point, startPos }) => {\n      point.lngLat = startPos;\n      this.#updateFeatureData(point);\n      point.boundFeatures.forEach((f) => {\n        features.add(f);\n      });\n    });\n    features.forEach((f) => {\n      this.#updateFeatureData(f);\n    });\n    this.#movedPoints.splice(0);\n  }\n\n  /**\n   * Return the feature currently under the mouse according to the following conditions:\n   * * If there are any points, the highest one is returned.\n   * * If there are no points, the lowest feature is returned.\n   * * If there are no features, null is returned.\n   * @param mousePos Mouse position.\n   * @returns The feature or null if none are at the given mouses position.\n   */\n  #getFeatureUnderMouse(mousePos: PointLike): MapFeature | null {\n    const layersOrder = this.#map.getLayersOrder();\n    let selectedIndex = Infinity;\n    let selectedFeature: MapFeature | null = null;\n    for (const featureId of this.#getFeatureIds(mousePos)) {\n      const currentIndex = layersOrder.indexOf(featureId);\n      if (currentIndex === -1) continue;\n      const feature = this.#features.get(featureId);\n      const currentIsPoint = feature instanceof Point;\n      const selectedIsNotPoint = !(selectedFeature instanceof Point);\n      if (\n        !selectedFeature ||\n        (currentIsPoint &&\n          (selectedIsNotPoint || currentIndex > selectedIndex)) ||\n        (!currentIsPoint && selectedIsNotPoint && currentIndex < selectedIndex)\n      ) {\n        selectedIndex = currentIndex;\n        selectedFeature = feature ?? null;\n      }\n    }\n    return selectedFeature;\n  }\n\n  /**\n   * Return the list of feature IDs that are currently visible.\n   * @param at If specified, only the IDs of features under the given pixel position will be returned.\n   * @param exclude List of feature IDs to exclude from the results.\n   * @returns An array of distinct feature IDs that correspond to the criteria.\n   */\n  #getFeatureIds(at?: PointLike, exclude?: Set<string>): string[] {\n    const ids = this.#map\n      .queryRenderedFeatures(at)\n      .filter((f) => !exclude?.has(f.source))\n      .map((f) => f.source);\n    return [...new Set(ids)]; // Remove duplicates\n  }\n\n  /**\n   * Moves a feature’s layers to a different z-position.\n   * @param featureId The ID of the feature to move the layer’s of.\n   * @param beforeId The ID of an existing feature to insert the layers before.\n   * When viewing the map, the `featureId`’s layers will appear beneath the `beforeId`’s layers.\n   * If `beforeId` is omitted, the layers will be appended to the end of the layers\n   * array and appear above all other layers on the map.\n   * @see OttmMap.moveLayer\n   */\n  #moveLayers(featureId: string, beforeId?: string): void {\n    if (beforeId) {\n      const bottomLayer = this.#getLayerIdStack(beforeId)?.[0];\n      this.#getLayerIdStack(featureId)?.forEach((id) => {\n        this.#map.moveLayer(id, bottomLayer);\n      });\n    } else {\n      this.#getLayerIdStack(featureId)?.forEach((id) => {\n        this.#map.moveLayer(id);\n      });\n    }\n  }\n\n  /**\n   * Return the stack of layer IDs for the given feature ID.\n   * @param featureId A feature’s ID.\n   * @returns The IDs stack as a string array or null if the feature was not found.\n   */\n  #getLayerIdStack(featureId: string): string[] | null {\n    const feature = this.#features.get(featureId);\n    if (feature instanceof Point)\n      return [feature.id + \"-highlight\", feature.id];\n    else if (feature instanceof LineString)\n      return [\n        feature.id + \"-highlight\",\n        feature.id,\n        feature.id + \"-foreground\",\n      ];\n    else if (feature instanceof Polygon)\n      return [feature.id, feature.id + \"-highlight\", feature.id + \"-border\"];\n    return null;\n  }\n\n  /**\n   * Hide associated layers for zoom < MapEditor.EDIT_MIN_ZOOM.\n   */\n  static readonly #FILTER_TOGGLE_VISIBILITY_FOR_ZOOM: FilterSpecification = [\n    \"step\",\n    [\"zoom\"],\n    false, // If 0 <= zoom < MapEditor.EDIT_MIN_ZOOM\n    MapEditor.#EDIT_MIN_ZOOM,\n    true, // If MapEditor.EDIT_MIN_ZOOM <= zoom\n  ];\n  /**\n   * Select a color depending on the feature’s \"selectionMode\" property.\n   */\n  static readonly #CHOOSE_COLOR_FOR_SELECTION_MODE: DataDrivenPropertyValueSpecification<ColorSpecification> =\n    [\n      \"match\",\n      [\"get\", \"selectionMode\"],\n      SelectionMode.SELECTED,\n      MapEditor.#HIGHLIGHT_SELECTED_COLOR, // Case 1\n      SelectionMode.HOVERED,\n      MapEditor.#HIGHLIGHT_HOVERED_COLOR, // Case 2\n      MapEditor.#HIGHLIGHT_BASE_COLOR, // Default\n    ];\n\n  /**\n   * Create the layers for the given feature and add them to the map.\n   * @param feature A feature.\n   * @see https://maplibre.org/maplibre-style-spec/expressions/\n   */\n  #addLayersForFeature(feature: MapFeature): void {\n    if (feature instanceof Point) {\n      this.#map.addLayer({\n        id: feature.id + \"-highlight\",\n        type: \"circle\",\n        source: feature.id,\n        paint: {\n          \"circle-radius\": [\"+\", [\"get\", \"radius\"], 4],\n          \"circle-color\": MapEditor.#CHOOSE_COLOR_FOR_SELECTION_MODE,\n        },\n        filter: MapEditor.#FILTER_TOGGLE_VISIBILITY_FOR_ZOOM,\n      });\n      this.#map.addLayer({\n        id: feature.id,\n        type: \"circle\",\n        source: feature.id,\n        paint: {\n          \"circle-radius\": [\"get\", \"radius\"],\n          \"circle-color\": [\"get\", \"color\"],\n          \"circle-stroke-width\": 1,\n          \"circle-stroke-color\": MapEditor.#BORDER_COLOR,\n        },\n        filter: MapEditor.#FILTER_TOGGLE_VISIBILITY_FOR_ZOOM,\n      });\n    } else if (feature instanceof LineString) {\n      this.#map.addLayer({\n        id: feature.id + \"-highlight\",\n        type: \"line\",\n        source: feature.id,\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-width\": [\"+\", [\"get\", \"width\"], 8],\n          \"line-color\": MapEditor.#CHOOSE_COLOR_FOR_SELECTION_MODE,\n        },\n        filter: MapEditor.#FILTER_TOGGLE_VISIBILITY_FOR_ZOOM,\n      });\n      this.#map.addLayer({\n        id: feature.id,\n        type: \"line\",\n        source: feature.id,\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-width\": [\"get\", \"width\"],\n          \"line-color\": [\n            \"step\",\n            [\"zoom\"],\n            MapEditor.#NON_EDITABLE_COLOR, // If 0 < zoom < MapEditor.EDIT_MIN_ZOOM\n            MapEditor.#EDIT_MIN_ZOOM,\n            [\"get\", \"color\"], // If zoom >= MapEditor.EDIT_MIN_ZOOM\n          ],\n        },\n      });\n      this.#map.addLayer({\n        id: feature.id + \"-foreground\",\n        type: \"line\",\n        source: feature.id,\n        layout: {\n          \"line-cap\": \"butt\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-width\": [\"get\", \"fgWidth\"],\n          \"line-color\": [\"get\", \"fgColor\"],\n        },\n        filter: MapEditor.#FILTER_TOGGLE_VISIBILITY_FOR_ZOOM,\n      });\n    } else if (feature instanceof Polygon) {\n      this.#map.addLayer({\n        id: feature.id,\n        type: \"fill\",\n        source: feature.id,\n        paint: {\n          \"fill-color\": [\"concat\", [\"get\", \"color\"], \"30\"], // Add transparency\n        },\n        filter: MapEditor.#FILTER_TOGGLE_VISIBILITY_FOR_ZOOM,\n      });\n      this.#map.addLayer({\n        id: feature.id + \"-highlight\",\n        type: \"line\",\n        source: feature.id,\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-width\": 8,\n          \"line-color\": MapEditor.#CHOOSE_COLOR_FOR_SELECTION_MODE,\n        },\n        filter: MapEditor.#FILTER_TOGGLE_VISIBILITY_FOR_ZOOM,\n      });\n      this.#map.addLayer({\n        id: feature.id + \"-border\",\n        type: \"line\",\n        source: feature.id,\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-color\": [\"get\", \"color\"],\n        },\n        filter: MapEditor.#FILTER_TOGGLE_VISIBILITY_FOR_ZOOM,\n      });\n    } else throw TypeError(`Unexpected type: ${feature}`);\n    this.#onObjectDataUpdate(feature);\n  }\n\n  #onObjectDataUpdate(feature: MapFeature): void {\n    if (feature instanceof LineString) {\n      this.#map.setPaintProperty(\n        feature.id,\n        \"line-dasharray\",\n        feature.properties.dash,\n      );\n      this.#map.setPaintProperty(\n        feature.id + \"-foreground\",\n        \"line-dasharray\",\n        feature.properties.fgDash,\n      );\n    }\n  }\n\n  /**\n   * Set the cursor for the map’s canvas.\n   * @param cursor The cursor type.\n   */\n  #setCanvasCursor(cursor: Cursor): void {\n    this.#$canvasContainer.addClass(`cursor-${cursor}`);\n    for (const c of Object.values(Cursor))\n      if (c !== cursor) this.#$canvasContainer.removeClass(`cursor-${c}`);\n  }\n\n  /**\n   * Called when the mouse moves over the map.\n   * @param e The mouse event.\n   */\n  #onMouseMouve(e: MapMouseEvent | MapTouchEvent): void {\n    this.#mousePositionCache = e.lngLat;\n    if (this.#editMode === EditMode.VIEW_ONLY) return;\n    if (this.#editMode === EditMode.MOVE_FEATURES) {\n      this.#onMoveFeatures(e);\n      return;\n    }\n    const hoveredFeature = this.#getFeatureUnderMouse(e.point);\n    if (hoveredFeature) {\n      if (!this.#draggedPoint) this.#setHover(hoveredFeature);\n    } else this.#clearHover();\n\n    if (this.#draggedPoint) this.#onDragPoint(e);\n    else this.#refreshCursor();\n  }\n\n  /**\n   * Called when a {@link Point} is dragged.\n   * @param e The mouse event.\n   */\n  #onDragPoint(e: MapMouseEvent | MapTouchEvent): void {\n    const draggedPoint = this.#draggedPoint;\n    if (!draggedPoint) return;\n\n    this.#clearSelection();\n    this.#setCanvasCursor(Cursor.DRAW);\n\n    // Prevent linear features from connecting to themselves\n    // -> exclude points bound to the bound features of the dragged point\n    const excludedIds = new Set<string>();\n    draggedPoint.boundFeatures.forEach((f) => {\n      excludedIds.add(f.id);\n      // Exclude all the feature’s points\n      if (f instanceof LineString) {\n        const lastPath = (f.vertices.length - 1).toString();\n        // Allow other end point if #draggedPoint is at an end\n        if (!f.isLoop() && f.getVertexPath(draggedPoint) === \"0\") {\n          f.vertices\n            .filter((v) => f.getVertexPath(v) !== lastPath)\n            .forEach((v) => {\n              excludedIds.add(v.id);\n            });\n        } else if (!f.isLoop() && f.getVertexPath(draggedPoint) === lastPath) {\n          f.vertices.slice(1).forEach((v) => {\n            excludedIds.add(v.id);\n          });\n        } else {\n          f.vertices.forEach((v) => {\n            excludedIds.add(v.id);\n          });\n        }\n      } else if (f instanceof Polygon) {\n        f.vertices\n          .flatMap((s) => s)\n          .forEach((v) => {\n            excludedIds.add(v.id);\n          });\n      }\n    });\n    // Exclude point itself\n    excludedIds.add(draggedPoint.id);\n    const features = this.#getFeatureIds(undefined, excludedIds).map((id) => {\n      const feature = this.#features.get(id);\n      if (!feature) throw new Error(`Missing feature with ID ${id}`);\n      return feature;\n    });\n    const snapResult = trySnapPoint(e.lngLat, features, this.#map.getZoom());\n    this.#snapResult = null;\n\n    if (snapResult) {\n      if (snapResult.type === \"point\" || snapResult.type === \"segment_vertex\") {\n        let point: Point;\n        if (snapResult.type === \"point\") {\n          point = snapResult.point;\n        } else {\n          const { feature, path } = snapResult;\n          const vertex = feature.getVertex(path);\n          if (!vertex) throw new Error(`Invalid path \"${path}\"`);\n          point = vertex;\n        }\n\n        const canSnap = point.boundFeatures.every((f) => {\n          const path = f.getVertexPath(point);\n          if (!path)\n            throw new Error(\n              `Point #${point.id} does not belong to feature #${f.id}`,\n            );\n          return f.canAcceptVertex(draggedPoint, path);\n        });\n        if (canSnap) {\n          this.#snapResult = snapResult;\n          // Move dragged point to the snap position\n          draggedPoint.onDrag(point.lngLat);\n          this.#setHover(point);\n          this.#setCanvasCursor(Cursor.CONNECT_VERTEX);\n        }\n      } else {\n        // segment\n        const { feature, path, lngLat } = snapResult;\n        let canSnap = feature.canInsertVertex(draggedPoint, path);\n\n        let p1: Point, p2: Point;\n        if (canSnap) {\n          const vertices = feature.getSegmentVertices(path);\n          if (!vertices) throw new Error(`Invalid path \"${path}\"`);\n          [p1, p2] = vertices;\n          // Check if any excluded feature shares the same segment\n          for (const id of excludedIds) {\n            const f = this.#features.get(id);\n            if (isLinearFeature(f) && f.getSegmentPath(p1, p2)) {\n              // An excluded feature shares the segment, cancel snapping\n              canSnap = false;\n              break;\n            }\n          }\n        }\n\n        if (canSnap) {\n          const otherFeatures: { feature: LinearFeature; path: string }[] = [];\n          // Get all non-excluded features that share the same segment\n          features.forEach((f) => {\n            if (isLinearFeature(f) && f !== feature) {\n              const path = f.getSegmentPath(p1, p2);\n              if (path)\n                otherFeatures.push({\n                  feature: f,\n                  path: path,\n                });\n            }\n          });\n\n          this.#snapResult = snapResult;\n          if (otherFeatures.length) {\n            // Add all features that share the same segment\n            this.#snapResult.featuresWithSameSegment = otherFeatures;\n          }\n          // Move dragged point to the snap position\n          draggedPoint.onDrag(lngLat);\n          this.#setHover(feature);\n          this.#setCanvasCursor(Cursor.CONNECT_LINE);\n        }\n      }\n    }\n\n    if (!this.#snapResult) {\n      this.#clearHover();\n      draggedPoint.onDrag(e.lngLat);\n      if (\n        (this.#editMode === EditMode.DRAW_LINE &&\n          this.#canFinishLineDrawing(e.point)[0]) ||\n        (this.#editMode === EditMode.DRAW_POLYGON &&\n          this.#canFinishPolygonDrawing(e.point)[0])\n      )\n        this.#setCanvasCursor(Cursor.CONNECT_VERTEX);\n    }\n\n    this.#updateFeatureData(draggedPoint);\n    draggedPoint.boundFeatures.forEach((f) => {\n      this.#updateFeatureData(f);\n    });\n  }\n\n  /**\n   * Check whether the line feature currently being drawn can be finished.\n   * @param p The current mouse cursor position.\n   * @returns A tuple with a boolean indicating whether the drawing can be finished,\n   * and the last drawn vertex of the feature.\n   */\n  #canFinishLineDrawing(p: PointLike): [boolean, Point | null] {\n    if (!this.#drawnLineString) return [false, null];\n    const verticesNb = this.#drawnLineString.vertices.length;\n    if (verticesNb <= 2) return [false, null];\n\n    const features = this.#getFeatureIds(p);\n    const lastVertex = this.#drawnStringAppendEnd\n      ? this.#drawnLineString.getVertex((verticesNb - 2).toString())\n      : this.#drawnLineString.getVertex(\"1\");\n    if (!lastVertex) return [false, null];\n    return [features.some((id) => id === lastVertex.id), lastVertex];\n  }\n\n  /**\n   * Check whether the polygon feature currently being drawn can be finished.\n   * @param p The current mouse cursor position.\n   * @returns A tuple with a boolean indicating whether the drawing can be finished,\n   * and the last drawn vertex of the feature.\n   */\n  #canFinishPolygonDrawing(p: PointLike): [boolean, Point | null] {\n    if (!this.#drawnPolygon) return [false, null];\n    const rings = this.#drawnPolygon.vertices;\n    if (rings.length === 0) return [false, null];\n    const externalRing = rings[0];\n    if (externalRing.length < 3) return [false, null];\n    const features = this.#getFeatureIds(p);\n    const lastVertex = this.#drawnPolygon.getVertex(\n      `0.${externalRing.length - 2}`,\n    );\n    if (!lastVertex) return [false, null];\n    return [features.some((id) => id === lastVertex.id), lastVertex];\n  }\n\n  /**\n   * Called when a {@link MapFeature} is moved.\n   * @param e The mouse event.\n   */\n  #onMoveFeatures(e: MapMouseEvent | MapTouchEvent): void {\n    this.#setCanvasCursor(Cursor.GRABBING);\n    const features = new Set<LinearFeature>();\n    this.#movedPoints.forEach(({ point, offset }) => {\n      point.onDrag(e.lngLat, offset);\n      this.#updateFeatureData(point);\n      point.boundFeatures.forEach((f) => {\n        features.add(f);\n      });\n    });\n    // Update each bound feature only once\n    features.forEach((f) => {\n      this.#updateFeatureData(f);\n    });\n  }\n\n  /**\n   * Called when the mouse is pressed down on the map.\n   * @param e The mouse event.\n   */\n  #onMouseDown(e: MapMouseEvent | MapTouchEvent): void {\n    if (this.#editMode === EditMode.SELECT) {\n      // Cannot use instanceof on \"e\" so we have to test its \"type\" property to narrow its type\n      if (e.type === \"mousedown\" && isSecondaryClick(e.originalEvent)) {\n        // We check manually for a secondary mouse button click\n        // as the \"contextmenu\" event seems to not fire on circle features\n        this.#onContextMenu(e);\n        return;\n      }\n      if (this.#hoveredFeature instanceof Point) {\n        e.preventDefault();\n        this.#draggedPoint = this.#hoveredFeature;\n        this.#moveLayers(this.#draggedPoint.id); // Put on top\n      } else {\n        this.#setCanvasCursor(Cursor.GRABBING);\n      }\n    }\n    if (this.#contextMenu.isVisible()) this.#contextMenu.hide();\n  }\n\n  /**\n   * Called when the mouse is released on the map.\n   * @param e The mouse event.\n   */\n  #onMouseUp(e: MapMouseEvent | MapTouchEvent): void {\n    if (this.#editMode !== EditMode.SELECT) return;\n\n    const draggedPoint = this.#draggedPoint;\n    const snapResult = this.#snapResult;\n\n    if (snapResult && draggedPoint) {\n      if (snapResult.type === \"point\" || snapResult.type === \"segment_vertex\") {\n        const point = this.#getSnappedPoint();\n        if (!point) return;\n        draggedPoint.onDrag(point.lngLat);\n        if (point.dataObject && !draggedPoint.dataObject)\n          draggedPoint.copyDataOf(point);\n        point.boundFeatures.forEach((f) => {\n          f.replaceVertex(draggedPoint, point);\n        });\n        this.#removeFeature(point.id);\n      } else {\n        // segment\n        this.#addSnappedPointToSegment();\n      }\n      draggedPoint.boundFeatures.forEach((f) => {\n        this.#updateFeatureData(f);\n      });\n      this.#updateFeatureData(draggedPoint);\n      this.#moveLayers(draggedPoint.id); // Put point on top\n      this.#snapResult = null;\n    }\n    if (draggedPoint) {\n      this.#setHover(draggedPoint);\n      this.#draggedPoint = null;\n    }\n    this.#refreshCursor(e.point);\n  }\n\n  /**\n   * Called when the mouse is clicked on the map.\n   * @param e The mouse event.\n   */\n  #onClick(e: MapMouseEvent): void {\n    switch (this.#editMode) {\n      case EditMode.DRAW_POINT:\n        this.#drawPoint(e);\n        break;\n      case EditMode.DRAW_LINE:\n        if (this.#drawnLineString) {\n          this.#drawLinearFeatureVertex(this.#drawnLineString, e);\n        }\n        break;\n      case EditMode.DRAW_POLYGON:\n        if (this.#drawnPolygon) {\n          this.#drawLinearFeatureVertex(this.#drawnPolygon, e);\n        }\n        break;\n      case EditMode.MOVE_FEATURES:\n        this.#placeMovedFeatures(e);\n        break;\n      case EditMode.SELECT:\n        if (this.#hoveredFeature) {\n          const keepSelection = e.originalEvent.ctrlKey;\n          if (keepSelection && this.#selectedFeatures.has(this.#hoveredFeature))\n            this.#deselectFeature(this.#hoveredFeature);\n          else this.#selectFeature(this.#hoveredFeature, keepSelection);\n        } else this.#clearSelection();\n        break;\n      case EditMode.VIEW_ONLY:\n        this.#clearSelection();\n        break;\n    }\n  }\n\n  /**\n   * Called when the user requests the context menu.\n   * @param e The mouse event.\n   */\n  #onContextMenu(e: MapMouseEvent): void {\n    const buttonStates: ButtonStatesOptions = {};\n    if (this.#hoveredFeature) {\n      if (this.#hoveredFeature.selectionMode !== SelectionMode.SELECTED)\n        this.#selectFeature(this.#hoveredFeature, false);\n      buttonStates.move = this.#getMoveFeaturesActionCandidates().length !== 0;\n      buttonStates.copy = this.#getCopyFeaturesActionCandidates().length !== 0;\n      buttonStates.delete =\n        this.#getDeleteFeaturesActionCandidates().length !== 0;\n      buttonStates.continueLine =\n        this.#getContinueLineActionCandidate() !== null;\n      buttonStates.disconnect =\n        this.#getDisconnectVerticesActionCandidates().length !== 0;\n      buttonStates.extractPoint =\n        this.#getExtractVerticesActionCandidates().length !== 0;\n      buttonStates.split = this.#getSplitLinesActionCandidates().length !== 0;\n      buttonStates.circularize =\n        this.#getCircularizeFeaturesActionCandidates().length !== 0;\n      buttonStates.square =\n        this.#getSquareFeaturesActionCandidates().length !== 0;\n      const canFlip = this.#getFlipFeaturesActionCandidates().length !== 0;\n      buttonStates.flipLong = canFlip;\n      buttonStates.flipShort = canFlip;\n      buttonStates.reverseLine =\n        this.#getReverseLinesActionCandidates().length !== 0;\n      buttonStates.rotate =\n        this.#getRotateFeaturesActionCandidates().length !== 0;\n      buttonStates.straightenLine =\n        this.#getStraightenLinesActionCandidates().length !== 0;\n    } else {\n      buttonStates.paste =\n        this.#getPasteFeaturesActionCandidates().length !== 0;\n      this.#clearSelection();\n    }\n    this.#contextMenu.show(e.lngLat, buttonStates);\n  }\n\n  /**\n   * Draw a point feature at the mouse cursor’s position.\n   * @param e The mouse event.\n   */\n  #drawPoint(e: MapMouseEvent): void {\n    this.#selectFeature(this.#drawNewPoint(e), false);\n    this.#disableDrawPointMode(e.point);\n    this.#setCanvasCursor(Cursor.POINT);\n  }\n\n  /**\n   * Draw a vertex of the currently drawn feature at the mouse cursor’s position.\n   * @param feature The feature to draw the point for.\n   * @param e The mouse event.\n   */\n  #drawLinearFeatureVertex(feature: LinearFeature, e: MapMouseEvent): void {\n    if (this.#snapResult && this.#draggedPoint) {\n      if (\n        this.#snapResult.type === \"point\" ||\n        this.#snapResult.type === \"segment_vertex\"\n      ) {\n        const point = this.#getSnappedPoint();\n        if (!point) return;\n\n        const atLineEnd =\n          feature instanceof LineString && feature.isEndVertex(point);\n        // Keep already existing point\n        feature.replaceVertex(point, this.#draggedPoint);\n        this.#removeFeature(this.#draggedPoint.id);\n        this.#moveLayers(point.id); // Put point on top\n        this.#draggedPoint = null;\n        // If the vertex is drawn on the first vertex of the drawn line, end the drawing\n        if (atLineEnd) {\n          this.#updateFeatureData(point);\n          this.#setHover(point);\n          this.#setCanvasCursor(Cursor.POINT);\n          this.#disableDrawLineMode(e.point);\n          this.#snapResult = null;\n          return;\n        }\n      } else {\n        // segment\n        this.#addSnappedPointToSegment();\n        this.#drawnPoints.push(this.#draggedPoint);\n      }\n      this.#snapResult = null;\n    } else {\n      const [canFinish, lastVertex] =\n        feature instanceof LineString\n          ? this.#canFinishLineDrawing(e.point)\n          : this.#canFinishPolygonDrawing(e.point);\n      if (canFinish && lastVertex) {\n        this.#setHover(lastVertex);\n        this.#setCanvasCursor(Cursor.POINT);\n        if (feature instanceof LineString) this.#disableDrawLineMode(e.point);\n        else this.#disableDrawPolygonMode(e.point);\n        return;\n      }\n\n      if (!this.#draggedPoint) {\n        const point = this.#drawNewPoint(e);\n        if (point !== this.#hoveredFeature) this.#drawnPoints.push(point);\n        if (feature instanceof LineString && !this.#drawnStringAppendEnd)\n          feature.appendVertex(point, \"0\");\n        else feature.appendVertex(point, feature.getNextVertexPath());\n        this.#updateFeatureData(point);\n      }\n    }\n\n    const prevPoint = this.#draggedPoint;\n    // Create next point\n    const p = this.#createNewPoint(e.lngLat);\n    if (feature instanceof LineString && !this.#drawnStringAppendEnd)\n      feature.appendVertex(p, \"0\");\n    else feature.appendVertex(p, feature.getNextVertexPath());\n    this.#draggedPoint = p;\n    if (prevPoint) this.#updateFeatureData(prevPoint);\n    this.#updateFeatureData(feature);\n    if (\n      (feature instanceof LineString && feature.vertices.length > 2) ||\n      (feature instanceof Polygon && feature.vertices[0].length > 3)\n    )\n      this.#setCanvasCursor(Cursor.CONNECT_VERTEX);\n  }\n\n  /**\n   * Draw a new point feature at the mouse cursor’s position.\n   * If the point falls on a pre-existing one, the latter is returned.\n   * If the point falls on a pre-existing segment, it is added to it before being returned.\n   * Otherwise the point is created as is then returned.\n   * @param e The mouse event.\n   * @returns The newly created point or a pre-existing one.\n   */\n  #drawNewPoint(e: MapMouseEvent): Point {\n    let point: Point | null;\n    if (this.#hoveredFeature instanceof Point) {\n      // Select existing point instead of creating a new one\n      point = this.#hoveredFeature;\n    } else if (!(point = this.#createNewPointOnHoveredSegment(e))) {\n      point = this.#createNewPoint(e.lngLat);\n    }\n    this.#moveLayers(point.id); // Put point on top\n    return point;\n  }\n\n  /**\n   * If the current snap result has type \"point\" or \"segment vertex\", returns the point matching the result.\n   * Otherwise null is returned.\n   */\n  #getSnappedPoint(): Point | null {\n    if (this.#snapResult?.type === \"point\") {\n      return this.#snapResult.point;\n    } else if (this.#snapResult?.type === \"segment_vertex\") {\n      const { feature, path } = this.#snapResult;\n      return feature.getVertex(path);\n    }\n    return null;\n  }\n\n  /**\n   * If the current snap result has type \"segment\", adds the dragged point to the snapped segment.\n   * All features that share that same segment are updated.\n   */\n  #addSnappedPointToSegment(): void {\n    const draggedPoint = this.#draggedPoint;\n    if (this.#snapResult?.type === \"segment\" && draggedPoint) {\n      const { feature, path, lngLat } = this.#snapResult;\n      draggedPoint.onDrag(lngLat);\n      feature.insertVertexAfter(draggedPoint, path);\n      // Insert vertex to all features that share the same segment\n      this.#snapResult.featuresWithSameSegment?.forEach(({ feature, path }) => {\n        feature.insertVertexAfter(draggedPoint, path);\n      });\n      this.#moveLayers(draggedPoint.id); // Put point on top\n    }\n  }\n\n  /**\n   * Place down all features that are currently being moved.\n   * @param e The mouse event.\n   */\n  #placeMovedFeatures(e: MapMouseEvent) {\n    this.#editMode = EditMode.SELECT;\n    this.#movedPoints.splice(0);\n    this.#refreshCursor(e.point);\n  }\n\n  /**\n   * Called when the mouse is double-clicked on the map.\n   * @param e The mouse event.\n   */\n  #onDoubleClick(e: MapMouseEvent): void {\n    if (isLinearFeature(this.#hoveredFeature)) {\n      const point = this.#createNewPointOnHoveredSegment(e);\n      if (point) {\n        this.#setHover(point);\n        this.#setCanvasCursor(Cursor.POINT);\n      }\n    }\n  }\n\n  /**\n   * Called when a key is pressed.\n   * @param e The keyboard event.\n   */\n  #onKeyDown(e: KeyboardEvent): void {\n    if (this.#editMode === EditMode.SELECT) {\n      if (e.key === \"Delete\") this.#deleteSelectedFeatures();\n    } else {\n      // Interrupt any ongoing drawings\n      if (e.key === \"Escape\") this.#disableCurrentEditMode();\n    }\n  }\n\n  /**\n   * Called right before the map’s zoom level changes.\n   */\n  #onZoomChangeStart(): void {\n    // Prevent unzooming past threshold if a point is being dragged\n    if (this.#draggedPoint) this.#map.setMinZoom(MapEditor.#EDIT_MIN_ZOOM);\n    else this.#map.setMinZoom(0);\n  }\n\n  /**\n   * Called right after the map’s zoom level has changed.\n   */\n  #onZoomChangeEnd(): void {\n    const zoom = this.#map.getZoom();\n    if (\n      zoom < MapEditor.#EDIT_MIN_ZOOM &&\n      this.#editMode !== EditMode.VIEW_ONLY\n    ) {\n      this.#disableCurrentEditMode(); // Interrupt any action\n      this.#editMode = EditMode.VIEW_ONLY;\n      this.#clearHover();\n      this.#setCanvasCursor(Cursor.GRAB);\n      for (let i = 0; i < 3; i++)\n        this.#drawPointControl.setButtonDisabled(i, true);\n      this.#$editZoomNoticePanel.show();\n    } else if (\n      zoom >= MapEditor.#EDIT_MIN_ZOOM &&\n      this.#editMode === EditMode.VIEW_ONLY\n    ) {\n      this.#editMode = EditMode.SELECT;\n      for (let i = 0; i < 3; i++)\n        this.#drawPointControl.setButtonDisabled(i, false);\n      this.#$editZoomNoticePanel.hide();\n    }\n  }\n\n  /**\n   * Create a point at the given position on the currently hovered segment.\n   * The current selection set is not changed.\n   * @param e The mouse event.\n   * @returns The newly created point or null if none were.\n   */\n  #createNewPointOnHoveredSegment(e: MapMouseEvent): Point | null {\n    if (isLinearFeature(this.#hoveredFeature)) {\n      // Search which linear feature was clicked\n      const features = this.#getFeatureIds(e.point)\n        .map((id) => this.#features.get(id))\n        .filter((f) => isLinearFeature(f));\n\n      const snapResult = trySnapPoint(e.lngLat, features, this.#map.getZoom());\n      // User clicked near a line, add a new point to it\n      if (snapResult?.type === \"segment\") {\n        const { feature, path, lngLat } = snapResult;\n\n        const newPoint: Point = this.#createNewPoint(lngLat);\n        const segmentVertices = feature.getSegmentVertices(path);\n        if (!segmentVertices) throw new Error(`Invalid path ${path}`);\n        const [p1, p2] = segmentVertices;\n        const update = (feature: LinearFeature, path: string) => {\n          feature.insertVertexAfter(newPoint, path);\n          this.#updateFeatureData(feature);\n        };\n        update(feature, path);\n        // Update all features that share the same segment\n        features.forEach((f) => {\n          if (isLinearFeature(f) && f !== feature) {\n            const path = f.getSegmentPath(p1, p2);\n            if (path) update(f, path);\n          }\n        });\n        this.#updateFeatureData(newPoint);\n        return newPoint;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Set the hovered feature. If a feature was already hovered and is not selected, its highlight is removed.\n   * If the feature is selected, its highlight color is not changed.\n   * @param feature The feature to set as being hovered.\n   * @throws {Error} If the feature is null.\n   */\n  #setHover(feature: MapFeature): void {\n    if (this.#hoveredFeature === feature) return;\n    if (\n      this.#hoveredFeature &&\n      !this.#selectedFeatures.has(this.#hoveredFeature)\n    ) {\n      this.#hoveredFeature.selectionMode = SelectionMode.NONE;\n      this.#updateFeatureData(this.#hoveredFeature);\n    }\n    this.#hoveredFeature = feature;\n    if (!this.#selectedFeatures.has(this.#hoveredFeature)) {\n      this.#hoveredFeature.selectionMode = SelectionMode.HOVERED;\n      this.#updateFeatureData(this.#hoveredFeature);\n    }\n    this.#map.fire(new FeatureHoverEvent(this.#hoveredFeature));\n  }\n\n  /**\n   * Clear the currently hovered feature.\n   */\n  #clearHover(): void {\n    if (this.#hoveredFeature) {\n      if (!this.#selectedFeatures.has(this.#hoveredFeature)) {\n        this.#hoveredFeature.selectionMode = SelectionMode.NONE;\n        this.#updateFeatureData(this.#hoveredFeature);\n      }\n      this.#hoveredFeature = null;\n      this.#map.fire(new FeatureHoverEvent());\n    }\n  }\n\n  /**\n   * Select the given feature.\n   * @param feature The feature to select.\n   * @param keepSelection If true, the feature will be added to the current selection list,\n   * otherwise the list is cleared beforehand.\n   * @throws {Error} If the feature is null.\n   */\n  #selectFeature(feature: MapFeature, keepSelection: boolean): void {\n    let changed = false;\n    if (this.#selectedFeatures.size && !keepSelection) {\n      this.#clearSelection(false);\n      changed = true;\n    }\n    if (!this.#selectedFeatures.has(feature)) {\n      this.#selectedFeatures.add(feature);\n      feature.selectionMode = SelectionMode.SELECTED;\n      this.#updateFeatureData(feature);\n      changed = true;\n    }\n    if (changed) {\n      // Only fire if the selection set changed\n      this.#map.fire(new FeatureSelectionEvent([...this.#selectedFeatures]));\n    }\n  }\n\n  /**\n   * Deselect the given feature.\n   * @param feature The feature to deselect.\n   * @throws {Error} If the feature is null.\n   */\n  #deselectFeature(feature: MapFeature): void {\n    if (this.#selectedFeatures.delete(feature)) {\n      feature.selectionMode = SelectionMode.NONE;\n      this.#updateFeatureData(feature);\n      this.#map.fire(new FeatureSelectionEvent([...this.#selectedFeatures]));\n    }\n  }\n\n  /**\n   * Clear the current selection.\n   * @param fire If true and the selection set changed, an event is fired; otherwise an event is never fired.\n   */\n  #clearSelection(fire = true): void {\n    if (this.#selectedFeatures.size) {\n      this.#selectedFeatures.forEach((feature) => {\n        feature.selectionMode = SelectionMode.NONE;\n        this.#updateFeatureData(feature);\n      });\n      this.#selectedFeatures.clear();\n      if (fire) this.#map.fire(new FeatureSelectionEvent());\n    }\n  }\n\n  /**\n   * In \"select\" mode, refresh the mouse cursor based on the currently hovered feature.\n   * If the edit mode is something else, nothing happens.\n   *\n   * @param mousePos The mouse position. If specified, the feature under the mouse position will be used instead.\n   */\n  #refreshCursor(mousePos?: PointLike): void {\n    if (this.#editMode === EditMode.SELECT) {\n      const feature = mousePos\n        ? this.#getFeatureUnderMouse(mousePos)\n        : this.#hoveredFeature;\n      if (feature) {\n        const cursor = {\n          Point: Cursor.POINT,\n          LineString: Cursor.LINE,\n          Polygon: Cursor.POLYGON,\n        }[feature.geometry.type];\n        this.#setCanvasCursor(cursor);\n      } else {\n        this.#setCanvasCursor(Cursor.GRAB);\n      }\n    }\n  }\n\n  /**\n   * Create a new point at the given position.\n   * @param lngLat The point’s position.\n   * @returns The newly created point.\n   */\n  #createNewPoint(lngLat: LngLat): Point {\n    const newPoint = new Point(\n      this.#getNextFeatureId(),\n      (n, t) => this.#getDataType(n, t),\n      lngLat,\n    );\n    this.#addFeature(newPoint);\n    return newPoint;\n  }\n\n  /**\n   * Return all values that are currently eligible for the \"move features\" action:\n   * * all selected features.\n   */\n  #getMoveFeaturesActionCandidates(): MapFeature[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    // Eliminate points that are bound to a selected linear feature\n    return [...this.#selectedFeatures].filter(\n      (f) =>\n        !(f instanceof Point) ||\n        !f.boundFeatures.some((ff) => this.#selectedFeatures.has(ff)),\n    );\n  }\n\n  /**\n   * Move the selected features.\n   */\n  #moveSelectedFeatures(): void {\n    const mousePositionCache = this.#mousePositionCache;\n    if (!mousePositionCache) return;\n\n    this.#movedPoints.splice(0);\n    const points = new Set<Point>();\n\n    this.#getMoveFeaturesActionCandidates().forEach((f) => {\n      if (f instanceof Point) {\n        points.add(f);\n        this.#movedPoints.push({\n          point: f,\n          offset: LngLatVector.sub(f.lngLat, mousePositionCache),\n          startPos: f.lngLat,\n        });\n      } else if (f instanceof LineString) {\n        // Add all vertices to the list\n        f.vertices.forEach((v) => {\n          if (!points.has(v)) {\n            points.add(v);\n            this.#movedPoints.push({\n              point: v,\n              offset: LngLatVector.sub(v.lngLat, mousePositionCache),\n              startPos: v.lngLat,\n            });\n          }\n        });\n      } else if (f instanceof Polygon) {\n        // Add all vertices of all rings to the list\n        f.vertices\n          .flatMap((s) => s)\n          .forEach((v) => {\n            if (!points.has(v)) {\n              points.add(v);\n              this.#movedPoints.push({\n                point: v,\n                offset: LngLatVector.sub(v.lngLat, mousePositionCache),\n                startPos: v.lngLat,\n              });\n            }\n          });\n      }\n    });\n\n    if (this.#movedPoints.length) {\n      this.#editMode = EditMode.MOVE_FEATURES;\n      this.#setCanvasCursor(Cursor.GRABBING);\n    }\n  }\n\n  /**\n   * Return all values that are currently eligible for the \"copy features\" action:\n   * * all selected features.\n   */\n  #getCopyFeaturesActionCandidates(): MapFeature[] {\n    return this.#editMode === EditMode.SELECT\n      ? [...this.#selectedFeatures]\n      : [];\n  }\n\n  #copySelectedFeatures(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return all values that are currently eligible for the \"paste features\" action:\n   * * TODO\n   */\n  #getPasteFeaturesActionCandidates(): MapFeature[] {\n    return []; // TODO\n  }\n\n  #pasteFeatures(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return all values that are currently eligible for the \"delete features\" action:\n   * * all selected features.\n   */\n  #getDeleteFeaturesActionCandidates(): MapFeature[] {\n    return this.#editMode === EditMode.SELECT\n      ? [...this.#selectedFeatures]\n      : [];\n  }\n\n  /**\n   * If in \"select\" mode, delete the currently selected features and clear the selection set.\n   */\n  #deleteSelectedFeatures(): void {\n    this.#getDeleteFeaturesActionCandidates().forEach((f) => {\n      this.#removeFeature(f.id);\n    });\n    this.#selectedFeatures.clear();\n  }\n\n  /**\n   * Return the point that is currently eligible for the \"continue line\" action along with the line that matched:\n   * * only one point is selected and that point is at the end of exactly one line.\n   */\n  #getContinueLineActionCandidate(): [Point, LineString] | null {\n    if (this.#editMode !== EditMode.SELECT || this.#selectedFeatures.size !== 1)\n      return null;\n    const v = this.#selectedFeatures.values().next().value;\n    if (!(v instanceof Point)) return null;\n    let line: LineString | null = null;\n    // Vertex must be the first/last vertex of exactly one line\n    for (const f of v.boundFeatures) {\n      if (f instanceof LineString && f.isEndVertex(v)) {\n        if (line) return null;\n        line = f;\n      }\n    }\n    return line ? [v, line] : null;\n  }\n\n  /**\n   * Continue drawing the line the selected vertex is at one end of.\n   */\n  #continueSelectedLine(): void {\n    const candidate = this.#getContinueLineActionCandidate();\n    if (candidate) {\n      const [point, line] = candidate;\n      this.#enableDrawLineMode(line, point);\n    }\n  }\n\n  /**\n   * Return the points that are currently eligible for the \"disconnect vertices\" action:\n   * * all selected points that are bound to at least two features.\n   */\n  #getDisconnectVerticesActionCandidates(): Point[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    return [...this.#selectedFeatures].filter(\n      (f) => f instanceof Point && f.boundFeatures.length >= 2,\n    ) as Point[];\n  }\n\n  #disconnectSelectedVertices(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return the points that are currently eligible for the \"extract vertices\" action:\n   * * all selected points with data that are bound to at least one feature.\n   */\n  #getExtractVerticesActionCandidates(): Point[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    return [...this.#selectedFeatures].filter(\n      (f) =>\n        f instanceof Point && !!f.dataObject && f.boundFeatures.length !== 0,\n    ) as Point[];\n  }\n\n  #extractSelectedVertices(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return the lines that are currently eligible for the \"split lines\" action,\n   * along with the indices where to split them:\n   * * all lines that have selected points and the latter are not at any end of the former.\n   */\n  #getSplitLinesActionCandidates(): [LineString, number[]][] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    const idToIndex: Record<string, number> = {};\n    const lines: [LineString, number[]][] = [];\n    for (const f of this.#selectedFeatures) {\n      if (f instanceof Point && f.boundFeatures.length !== 0) {\n        f.boundFeatures.forEach((ff) => {\n          if (ff instanceof LineString && !ff.isEndVertex(f)) {\n            const i = ff.vertices.indexOf(f);\n            if (!idToIndex[ff.id]) {\n              idToIndex[ff.id] = lines.length;\n              lines.push([ff, [i]]);\n            } else {\n              lines[idToIndex[ff.id]][1].push(i);\n            }\n          }\n        });\n      }\n    }\n    return lines;\n  }\n\n  #splitSelectedLines(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return the linear features that are currently eligible for the \"circularize features\" action:\n   * * all selected polygons that are already nearly circular.\n   * * all selected lines that form a loop that are already nearly circular.\n   * @see LinearFeature.isNearlyCircular\n   */\n  #getCircularizeFeaturesActionCandidates(): LinearFeature[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    return [...this.#selectedFeatures].filter(\n      (f) => isLinearFeature(f) && f.isNearlyCircular(0),\n    ) as LinearFeature[];\n  }\n\n  #circularizeSelectedFeatures(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return the linear features that are currently eligible for the \"square features\" action:\n   * * all selected polygons that are already nearly square.\n   * * all selected lines that form a loop that are already nearly square.\n   * @see LinearFeature.isNearlySquare\n   */\n  #getSquareFeaturesActionCandidates(): LinearFeature[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    return [...this.#selectedFeatures].filter(\n      (f) => isLinearFeature(f) && f.isNearlySquare(0),\n    ) as LinearFeature[];\n  }\n\n  #squareSelectedFeatures(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return the features that are currently eligible for the \"flip long features\" action:\n   * * all selected features, as long as it is not a single point, two points, or a single line with only two vertices.\n   */\n  #getFlipFeaturesActionCandidates(): MapFeature[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    const entries = this.#selectedFeatures.values();\n    if (this.#selectedFeatures.size === 1) {\n      const { value: feature } = entries.next();\n      if (\n        feature instanceof Point ||\n        (feature instanceof LineString && feature.vertices.length === 2)\n      )\n        return [];\n    } else if (this.#selectedFeatures.size === 2) {\n      const { value: feature1 } = entries.next();\n      const { value: feature2 } = entries.next();\n      if (feature1 instanceof Point && feature2 instanceof Point) return [];\n    }\n    return [...this.#selectedFeatures];\n  }\n\n  #flipLongSelectedFeatures(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  #flipShortSelectedFeatures(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return the lines that are currently eligible for the \"reverse lines\" action:\n   * * all selected lines.\n   */\n  #getReverseLinesActionCandidates(): LineString[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    return [...this.#selectedFeatures].filter(isLinearFeature) as LineString[];\n  }\n\n  /**\n   * Reverse the direction of all selected lines.\n   */\n  #reverseSelectedLines(): void {\n    this.#getReverseLinesActionCandidates().forEach((line) => {\n      line.direction =\n        line.direction === PolylineDirection.FORWARD\n          ? PolylineDirection.BACKWARD\n          : PolylineDirection.FORWARD;\n      this.#updateFeatureData(line);\n    });\n  }\n\n  /**\n   * Return the features that are currently eligible for the \"rotate features\" action:\n   * * all selected features if there are more than one.\n   * * the single selected feature if it is not a point.\n   */\n  #getRotateFeaturesActionCandidates(): MapFeature[] {\n    if (\n      this.#editMode !== EditMode.SELECT ||\n      (this.#selectedFeatures.size === 1 &&\n        this.#selectedFeatures.values().next().value instanceof Point)\n    )\n      return [];\n    return [...this.#selectedFeatures];\n  }\n\n  #rotateSelectedFeatures(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Return the lines that are currently eligible for the \"straighten lines\" action:\n   * * all selected lines that are nearly straight.\n   */\n  #getStraightenLinesActionCandidates(): LineString[] {\n    if (this.#editMode !== EditMode.SELECT) return [];\n    return [...this.#selectedFeatures].filter(\n      (f) => f instanceof LineString && f.isNearlyStraight(),\n    ) as LineString[];\n  }\n\n  #straightenSelectedLines(): void {\n    // TODO\n    console.log(\"Not implemented yet.\");\n  }\n\n  /**\n   * Update the given feature’s map data.\n   * @param feature A feature.\n   */\n  #updateFeatureData(feature: MapFeature): void {\n    (this.#map.getSource(feature.id) as GeoJSONSource).setData(feature);\n  }\n}\n\n// This function exists because otherwise TS would put a warning\n// on the \"instanceof\" if \"f\" is a MapFeature for some reason\nfunction isLinearFeature(f: unknown): f is LinearFeature {\n  return f instanceof LinearFeature;\n}\n\n/**\n * Hook a feature editor to the given map.\n * @param map The map.\n */\nexport default function initMapEditor(map: OttmMap): void {\n  // TEMP\n  const lengthUnitType = new UnitType(\"length\", \"Length\");\n  const millimeterUnit = new Unit(lengthUnitType, \"mm\", true);\n  lengthUnitType.addUnit(millimeterUnit);\n  const track_level_enum = new Enum(\"track_level\", \"Track Level\", {\n    surface: \"Surface\",\n    tunnel: \"Underground\",\n    bridge: \"Bridge\",\n  });\n\n  const geometry = new ObjectType(\"geometry\", \"Geometry\", null);\n  const point = new ObjectType(\"point\", \"Point\", geometry, \"Point\");\n  const linestring = new ObjectType(\n    \"linestring\",\n    \"Line\",\n    geometry,\n    \"LineString\",\n  );\n  const polygon = new ObjectType(\"polygon\", \"Polygon\", geometry, \"Polygon\");\n  const track_section = new ObjectType(\n    \"track_section\",\n    \"Track Section\",\n    linestring,\n  );\n  track_section.addProperty(\n    new EnumProperty(\n      track_section,\n      \"level\",\n      \"Level\",\n      true,\n      false,\n      track_level_enum,\n    ),\n  );\n  const conv_track_section = new ObjectType(\n    \"conventional_track_section\",\n    \"Railway Track Section\",\n    track_section,\n  );\n  conv_track_section.addProperty(\n    new FloatProperty(\n      conv_track_section,\n      \"gauges\",\n      \"Gauge\",\n      false,\n      false,\n      0,\n      undefined,\n      lengthUnitType,\n    ),\n  );\n\n  const mapEditor = new MapEditor(map, {\n    units: {\n      length: lengthUnitType,\n    },\n    enums: {\n      track_level: track_level_enum,\n    },\n    objects: {\n      geometry,\n      point,\n      linestring,\n      polygon,\n      track_section,\n      conventional_track_section: conv_track_section,\n    },\n  });\n\n  const track1 = new ObjectInstance(conv_track_section);\n  track1.setPropertyValue(\"level\", \"surface\");\n  track1.addValueToProperty(\"gauges\", 1435);\n\n  map.on(\"load\", () => {\n    mapEditor.createFeature({\n      dbId: 0,\n      type: \"Point\",\n      lng: 1.45,\n      lat: 43.6005,\n    });\n    mapEditor.createFeature({ dbId: 1, type: \"Point\", lng: 1.45, lat: 43.6 });\n    mapEditor.createFeature({ dbId: 2, type: \"Point\", lng: 1.4505, lat: 43.6 });\n    mapEditor.createFeature({\n      dbId: 3,\n      type: \"Point\",\n      lng: 1.4505,\n      lat: 43.6005,\n    });\n    mapEditor.createFeature({\n      dbId: 4,\n      type: \"Point\",\n      lng: 1.4506,\n      lat: 43.601,\n    });\n    mapEditor.createFeature({\n      dbId: 5,\n      type: \"Point\",\n      lng: 1.4505,\n      lat: 43.601,\n    });\n    mapEditor.createFeature({\n      dbId: 6,\n      type: \"Point\",\n      lng: 1.451,\n      lat: 43.6015,\n    });\n    mapEditor.createFeature({\n      dbId: 7,\n      type: \"Point\",\n      lng: 1.4515,\n      lat: 43.6015,\n    });\n    mapEditor.createFeature({\n      dbId: 8,\n      type: \"Point\",\n      lng: 1.4508,\n      lat: 43.601,\n    });\n    mapEditor.createFeature({\n      dbId: 9,\n      type: \"Point\",\n      lng: 1.451,\n      lat: 43.6013,\n    });\n    mapEditor.createFeature({\n      dbId: 100,\n      type: \"LineString\",\n      verticesDbIds: [1, 2, 3, 4],\n      dataObject: track1,\n    });\n    mapEditor.createFeature({\n      dbId: 200,\n      type: \"Polygon\",\n      verticesDbIds: [\n        [3, 5, 6, 7],\n        [4, 8, 9],\n      ],\n    });\n  });\n}\n"],"names":["global","ssr","document","addEventListener","removeEventListener","getBoundingClientRect","gutterStartDragging","aGutterSize","bGutterSize","HORIZONTAL","NOOP","calc","prefix","el","isString","v","elementOrSelector","ele","getOption","options","propName","def","value","getGutterSize","gutterSize","isFirst","isLast","gutterAlign","defaultGutterFn","i","gutterDirection","gut","defaultElementStyleFn","dim","size","gutSize","style","defaultGutterStyleFn","obj","Split","idsOption","ids","dimension","clientAxis","position","positionEnd","clientSize","elements","firstElement","parent","parentStyle","parentFlexDirection","sizes","minSize","minSizes","maxSize","maxSizes","expandToMin","snapOffset","snapOffsets","dragInterval","direction","cursor","gutter","elementStyle","gutterStyle","setElementSize","prop","setGutterSize","gutterElement","getSizes","element","getMousePosition","e","adjust","offset","a","b","percentage","drag","calculateSizes","aBounds","bBounds","innerSize","computedStyle","trimToMin","sizesToTrim","parentSize","excessPixels","toSpare","pixelSizes","pixelSize","elementGutterSize","elementMinSize","newPixelSize","takenPixels","stopDragging","self","startDragging","pairs","id","pair","temp","adjustToMin","computedSize","setSizes","newSizes","trimmed","newSize","destroy","preserveStyles","preserveGutter","area","geojson","geomReduce","geom","calculateArea","total","polygonArea","coords","ringArea","FACTOR","earthRadius","PI_OVER_180","coordsLength","lower","middle","upper","lowerX","middleY","upperX","getCoord","coord","getCoords","getGeom","bearing","start","end","calculateFinalBearing","coordinates1","coordinates2","lon1","degreesToRadians","lon2","lat1","lat2","radiansToDegrees","bear","rhumbBearing","bear360","calculateRhumbBearing","from","to","phi1","phi2","deltaLambda","deltaPsi","theta","angle","startPoint","midPoint","endPoint","isObject","A","O","B","azimuthAO","bearingToAzimuth","azimuthBO","angleAO","distance","dLat","dLon","radiansToLength","length","segmentReduce","previousValue","segment","copyLngLat","lngLat","LngLat","isSecondaryClick","_LngLatVector","lng","lat","__publicField","ll1","ll2","LngLatVector","SelectionMode","SelectionMode2","MapFeature","dataTypesProvider","geometry","dbId","layer","dataObject","expectedGeomType","actualGeomType","mode","feature","Point","__privateAdd","_lngLat","_boundFeatures","__privateGet","__privateSet","radius","mousePos","f","LineString","_LinearFeature","draggedVertex","ringIndex","getPolygonArea","getPolygonPerimeter","ring","vPrev","vCurr","vNext","turfAngle","t","LinearFeature","PolylineDirection","_LineString","vertices","_LineString_instances","_vertices","_direction","vertex","path","d","__privateMethod","getVertexIndex_fn","at","atI","lastI","newVertex","oldVertex","index","v1","v2","i1","i2","west","south","east","north","g","color","_PATH_PATTERN","m","_Polygon","_Polygon_instances","_lockStatus","ringI","vertexI","rings","indices","_a","points","Polygon","toPolygon","polygon","UnitType","label","localizedName","_units","unit","Unit","type","symbol","isDefault","Enum","values","_values","ObjectType","parentType","geometryType","temporal","deprecated","_geometryType","_properties","properties","name","property","p","other","ObjectProperty","objectType","unique","propertyValue","PropertyValue","propertyType","_PropertyValue_instances","ensureUnique_fn","ensureValid_fn","ensureNotUnique_fn","NumberProperty","min","max","unitType","FloatProperty","FloatPropertyValue","StringProperty","multiline","translatable","translations","StringPropertyValue","EnumProperty","enumType","EnumPropertyValue","_ObjectInstance","existenceInterval","_ObjectInstance_instances","_type","_existenceInterval","newType","toKeep","interval","getPropertyOrThrow_fn","pValue","createPropertyBinding_fn","_ObjectInstance_static","isNumberProperty_fn","langCode","tr","NumberPropertyValue","ObjectInstance","_unit","expectedType","actualType","_StringPropertyValue_instances","_translations","ensureTranslatable_fn","MapEditorEvent","_FeatureSelectionEvent","features","FeatureSelectionEvent","_FeatureHoverEvent","FeatureHoverEvent","polygonToLine","poly","singlePolygonToLine","multiPolygonToLine","coordsToLine","multiPoly","lines","featureCollection","multiLineString","lineString","destination","origin","longitude1","latitude1","bearingRad","radians","lengthToRadians","latitude2","longitude2","point","TinyQueue","data","compare","defaultCompare","item","top","bottom","pos","current","halfLength","left","best","right","checkWhichEventIsLeft","e1","e2","checkWhichSegmentHasRightEndpointFirst","seg1","seg2","Event","featureId","ringId","eventId","eventToCheck","fillEventQueue","eventQueue","processFeature","featureOrGeometry","ii","currentP","nextP","iii","Segment","event","testSegmentIntersect","x1","y1","x2","y2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","x","y","runCheck","ignoreSelfIntersections","intersectionPoints","outQueue","otherSeg","intersection","sweeplineIntersections","lib","lineIntersect","line1","line2","removeDuplicates","intersections","results","key","r","__defProp","__defProps","__getOwnPropDescs","__getOwnPropSymbols","__hasOwnProp","__propIsEnum","__defNormalProp","__spreadValues","__spreadProps","nearestPointOnLine","pt","closestPt","flattenEach","line","_featureIndex","multiFeatureIndex","stop","sectionLength","heightDistance","perpendicularPt1","perpendicularPt2","intersect","lineIntersects","intersectPt","trySnapPoint","zoom","snapDistancePx","res","getClosestFeature","getMetersPerPixel","isLinearFeature","vertexPath","checkSnapToSegmentVertex","snapVertexPriorityDistance","aIncluded","bIncluded","C","distanceAC","distanceBC","EARTH_CIRCUMFERENCE","latitude","zoomLevel","latitudeRadians","closestFeature","dist","nearestPoint","lineCoords","DrawControl","_container","_buttons","createControlContainer","createControlButton","createMdiIcon","button","$","disabled","_","Component","FeatureTypeButton","config","_$button","_$buttonIcon","_$buttonText","disable","types","strings","visible","EditorPanel","map","dataTypeProvider","_EditorPanel_instances","_$panel","_featureTypeButton","_selectedFeatures","_dataTypeProvider","onTypeButtonClick_fn","setupForm_fn","editable","reset_fn","setupSingleForm_fn","setupMultipleForm_fn","setType_fn","getDefaultType_fn","createFieldForProperty_fn","setFieldValue_fn","_b","setFieldValues_fn","ContextMenu","_ContextMenu_instances","_map","_popup","performAction_fn","OttmMap","Popup","buttonStates","anyEnabled","enabled","setButtonState_fn","enable","action","Cursor","_MapEditor","dataTypes","_MapEditor_instances","_$canvasContainer","_sidePanel","_contextMenu","_$editZoomNoticePanel","_drawPointControl","_features","_dbIdToPoint","_hoveredFeature","_editMode","_draggedPoint","_snapResult","_movedPoints","_drawnLineString","_drawnStringAppendEnd","_drawnPolygon","_drawnPoints","_mousePositionCache","_dataTypes","_lastFeatureId","n","getDataType_fn","moveSelectedFeatures_fn","copySelectedFeatures_fn","pasteFeatures_fn","deleteSelectedFeatures_fn","continueSelectedLine_fn","disconnectSelectedVertices_fn","extractSelectedVertices_fn","splitSelectedLines_fn","circularizeSelectedFeatures_fn","squareSelectedFeatures_fn","flipLongSelectedFeatures_fn","flipShortSelectedFeatures_fn","reverseSelectedLines_fn","rotateSelectedFeatures_fn","straightenSelectedLines_fn","disableDrawPointMode_fn","enableDrawPointMode_fn","disableDrawLineMode_fn","enableDrawLineMode_fn","disableDrawPolygonMode_fn","enableDrawPolygonMode_fn","onClick_fn","onDoubleClick_fn","onMouseMouve_fn","onMouseDown_fn","onMouseUp_fn","onZoomChangeStart_fn","onZoomChangeEnd_fn","onKeyDown_fn","canvasContainerParent","sidePanelContainer","message","_EDIT_MIN_ZOOM","geomSpec","getPoints","verticesIds","typeProvider","getNextFeatureId_fn","addFeature_fn","_HIGHLIGHT_BASE_COLOR","_HIGHLIGHT_SELECTED_COLOR","_HIGHLIGHT_HOVERED_COLOR","_BORDER_COLOR","_NON_EDITABLE_COLOR","typeName","metaType","__privateWrapper","s","addLayersForFeature_fn","moveLayers_fn","updateFeatureData_fn","removeFeature_fn","getLayerIdStack_fn","updateBoundFeaturesOfDeletedPoint_fn","deleteVerticesOfDeletedLineString_fn","deleteVerticesOfDeletedPolygon_fn","boundFeature","deletedBound","deleteVerticesOfDeletedLinearFeature_fn","disableCurrentEditMode_fn","refreshCursor_fn","disableMoveFeaturesMode_fn","setCanvasCursor_fn","createNewPoint_fn","quitLinearDrawing_fn","buttonIndex","onValidDrawing","selectFeature_fn","startPos","getFeatureUnderMouse_fn","layersOrder","selectedIndex","selectedFeature","getFeatureIds_fn","currentIndex","currentIsPoint","selectedIsNotPoint","exclude","beforeId","bottomLayer","_c","_FILTER_TOGGLE_VISIBILITY_FOR_ZOOM","_CHOOSE_COLOR_FOR_SELECTION_MODE","onObjectDataUpdate_fn","c","onMoveFeatures_fn","hoveredFeature","setHover_fn","clearHover_fn","onDragPoint_fn","draggedPoint","clearSelection_fn","excludedIds","lastPath","snapResult","canSnap","p1","p2","otherFeatures","canFinishLineDrawing_fn","canFinishPolygonDrawing_fn","verticesNb","lastVertex","externalRing","onContextMenu_fn","getSnappedPoint_fn","addSnappedPointToSegment_fn","drawPoint_fn","drawLinearFeatureVertex_fn","placeMovedFeatures_fn","keepSelection","deselectFeature_fn","getMoveFeaturesActionCandidates_fn","getCopyFeaturesActionCandidates_fn","getDeleteFeaturesActionCandidates_fn","getContinueLineActionCandidate_fn","getDisconnectVerticesActionCandidates_fn","getExtractVerticesActionCandidates_fn","getSplitLinesActionCandidates_fn","getCircularizeFeaturesActionCandidates_fn","getSquareFeaturesActionCandidates_fn","canFlip","getFlipFeaturesActionCandidates_fn","getReverseLinesActionCandidates_fn","getRotateFeaturesActionCandidates_fn","getStraightenLinesActionCandidates_fn","getPasteFeaturesActionCandidates_fn","drawNewPoint_fn","atLineEnd","canFinish","prevPoint","createNewPointOnHoveredSegment_fn","newPoint","segmentVertices","update","changed","fire","ff","mousePositionCache","candidate","idToIndex","entries","feature1","feature2","MapEditor","initMapEditor","lengthUnitType","millimeterUnit","track_level_enum","linestring","track_section","conv_track_section","mapEditor","track1"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,12,13,14,15,16]}