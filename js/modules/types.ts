import $ from "jquery";
import Cookies from "js-cookie";

declare global {
  interface Window {
    // Inject global properties
    ottm: OTTM;
    // Cf. PageContext class in ottm/page_handlers/_core.py for site-wide entries
    //  and get_js_config() in ottm/api/wiki/pages.py for wiki-related entries
    OTTM_CONFIG: {
      config: Dict<any>,
      page: Dict<any>,
      user: Dict<any>,
      languages: {
        code: string,
        name: string,
        writingDirection: string,
        comma: string,
        and: string,
        dayNames: string[],
        abbrDayNames: string[],
        monthNames: string[],
        abbrMonthNames: string[],
        ampm: [string, string],
        decimalSep: string,
        thousandsSep: string,
      }[],
      translations: Dict<string>,
    };
  }
}

export type Dict<T> = {
  [key: string]: T
}

/**
 * Immutable object that maps keys to values.
 * @template T The type of this mapping’s values.
 */
export class Mapping<T> {
  private readonly mappings: Dict<T>;

  /**
   * Internal data is queried from the global `WIKI_CONFIG` object generated by the server.
   * The object and associated `<script>` tag are deleted once this object is initialized.
   * @param data Initial data.
   */
  constructor(data: Dict<T>) {
    this.mappings = data;
  }

  /**
   * Return the value for the given key.
   * @param key The key.
   * @return The corresponding value or undefined if the key is absent.
   */
  get(key: string): T {
    return this.mappings[key];
  }

  /**
   * Check whether this object contains the given key.
   * @param key The key to check.
   * @return True if the key is present, false otherwise.
   */
  containsKey(key: string): boolean {
    return this.get(key) !== undefined;
  }

  /**
   * @return An array of all keys of this object.
   */
  keys(): string[] {
    return Object.keys(this.mappings);
  }

  /**
   * @return An array of all values of this object.
   */
  values(): T[] {
    return Object.values(this.mappings);
  }

  /**
   * @return An array of all key-value entries of this object.
   */
  entries(): [string, T][] {
    return Object.entries(this.mappings);
  }

  /**
   * @return An iterator over the key of this object.
   */
  [Symbol.iterator]() {
    const keys = this.keys();
    let i = -1;
    return {
      next: () => ({value: keys[++i], done: !(i in keys)}),
    };
  }
}

/**
 * Class representing a UI language.
 */
export class Language {
  public readonly code: string;
  public readonly name: string;
  public readonly comma: string;
  public readonly and: string;
  public readonly writingDirection: string;
  public readonly dayNames: string[];
  public readonly abbrDayNames: string[];
  public readonly monthNames: string[];
  public readonly abbrMonthNames: string[];
  public readonly ampm: [string, string];
  public readonly decimalSep: string;
  public readonly thousandsSep: string;

  constructor(
    code: string,
    name: string,
    writingDirection: string,
    comma: string,
    and: string,
    dayNames: string[],
    abbrDayNames: string[],
    monthNames: string[],
    abbrMonthNames: string[],
    ampm: [string, string],
    decimalSep: string,
    thousandsSep: string
  ) {
    if (dayNames.length !== 7) {
      throw new Error("dayNames expected 7 values");
    }
    if (abbrDayNames.length !== 7) {
      throw new Error("abbrDayNames expected 7 values");
    }
    if (monthNames.length !== 12) {
      throw new Error("monthNames expected 12 values");
    }
    if (abbrMonthNames.length !== 12) {
      throw new Error("abbrMonthNames expected 12 values");
    }
    if (ampm.length !== 2) {
      throw new Error("ampm expected 2 values");
    }
    this.code = code;
    this.name = name;
    this.writingDirection = writingDirection;
    this.comma = comma;
    this.and = and;
    this.dayNames = dayNames;
    this.abbrDayNames = abbrDayNames;
    this.monthNames = monthNames;
    this.abbrMonthNames = abbrMonthNames;
    this.ampm = ampm;
    this.decimalSep = decimalSep;
    this.thousandsSep = thousandsSep;
  }

  /**
   * Format the given number.
   * @param n A number.
   * @return The formatted number.
   */
  formatNumber(n: number): string {
    const s = n.toString();
    const decPart = s.includes(".") ? s.split(".")[1] : "";
    // Regex from https://stackoverflow.com/a/2901298/3779986
    const intPart = Math.floor(n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSep);
    return intPart + (decPart ? this.decimalSep + decPart : "");
  }

  /**
   * Turn a list of string into a simple list using commas and 'and'.
   * @param values List of values to format.
   * @return Formatted list.
   */
  listToText(values: any[]): string {
    if (values.length === 0) {
      return "";
    }
    if (values.length === 1) {
      return values[0];
    }
    let list = values.slice(0, values.length - 1).join(this.comma);
    return `${list}${this.and}${values[values.length - 1]}`;
  }
}

/**
 * The site’s global object class.
 */
export class OTTM {
  /** Site’s configuration values. */
  public readonly config: Mapping<any>;
  /** Current page’s data. */
  public readonly page: Mapping<any>;
  /** Current user’s data. */
  public readonly user: Mapping<any>;
  /** UI translations. */
  public readonly translations: Mapping<string>;
  /** Map of all available UI languages. */
  public readonly languages: Dict<Language> = {};

  constructor() {
    this.config = new Mapping(window.OTTM_CONFIG.config);
    this.page = new Mapping(window.OTTM_CONFIG.page);
    this.user = new Mapping(window.OTTM_CONFIG.user);
    this.translations = new Mapping(window.OTTM_CONFIG.translations);
    for (const langData of window.OTTM_CONFIG.languages) {
      this.languages[langData.code] = new Language(
        langData.code,
        langData.name,
        langData.writingDirection,
        langData.comma,
        langData.and,
        langData.dayNames,
        langData.abbrDayNames,
        langData.monthNames,
        langData.abbrMonthNames,
        langData.ampm,
        langData.decimalSep,
        langData.thousandsSep,
      );
    }
    delete window.OTTM_CONFIG;
    $("#ottm-config-script").remove();
  }

  /**
   * @return The language object of the current page.
   */
  getPageLanguage(): Language {
    return this.languages[this.page.get("language")];
  }

  /**
   * Convert a date to the given timezone.
   * @param date Date to convert.
   * @param timezone Target timezone.
   * @returns Converted date.
   */
  convertDateTimezone(date: Date, timezone: string): Date {
    return new Date(date.toLocaleString("en-US", {timeZone: timezone}));
  }

  /**
   * Format a date as "HH:MM".
   * @param date Date to format.
   * @returns Formatted time.
   */
  formatTime(date: Date): string {
    // Append 0s if necessary
    const hours = date.getHours().toLocaleString("en-US", {minimumIntegerDigits: 2});
    const minutes = date.getMinutes().toLocaleString("en-US", {minimumIntegerDigits: 2});
    return `${hours}:${minutes}`;
  }

  /**
   * Add the shortcut to the title attribute of any element that has an access key.
   */
  setAccessKeys() {
    $("*[accesskey]").each((_, element) => {
      const $element = $(element);
      const accessKey = $element.attr("accesskey");
      if (accessKey) {
        const title = $element.attr("title");
        const shortcut = `[Alt+Shift+${accessKey}]`;
        $element.attr("title", (title ? title + " " : "") + shortcut);
      }
    });
  }

  /**
   * Set referer URL to login-related links.
   */
  setReferer() {
    const path = window.location.pathname + window.location.hash;
    const linkSelectors = [
      "#nav-login-link",
      "#nav-logout-link",
    ];
    for (const linkSelector of linkSelectors) {
      const $link = $(linkSelector);
      if ($link.length) {
        this.setReturnTo($link, path);
      }
    }
  }

  /**
   * Add "return_to" argument to the given link’s href attribute.
   * @param $link Link element to modify.
   * @param path Path to pass to "return_to" argument.
   * @param args Additional arguments to append to URL.
   */
  setReturnTo($link: JQuery, path: string, args?: Dict<any>) {
    const url = new URL($link.prop("href"));
    // TODO use URLSearchParams
    url.search = "return_to=" + encodeURIComponent(path);
    if (args) {
      url.search += "&" + $.map(Object.entries(args),
        e => `${encodeURIComponent(e[0])}=${encodeURIComponent(e[1])}`).join("&");
    }
    $link.attr("href", url.href);
  }

  /**
   * Return the value of a cookie.
   * @param name Cookie’s name.
   * @param defaultValue A value to return if the cookie is undefined.
   * @returns The cookie’s value.
   */
  getCookie(name: string, defaultValue?: string): string {
    return Cookies.get(name) ?? defaultValue;
  }

  /**
   * Set the value of a cookie.
   * @param name Cookie’s name.
   * @param value Cookie’s value.
   * @param options Options.
   */
  setCookie(name: string, value: string, options: Cookies.CookieAttributes) {
    Cookies.set(name, value, options);
  }

  /**
   * Delete a cookie.
   * @param name Cookie’s name.
   * @param options Options.
   */
  deleteCookie(name: string, options: Cookies.CookieAttributes) {
    Cookies.remove(name, options);
  }
}
