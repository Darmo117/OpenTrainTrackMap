import $ from "jquery";
import Cookies from "js-cookie";

declare global {
  interface Window {
    // Inject global properties
    ottm: OTTM;
    // Cf. PageContext class in ottm/page_handlers/_core.py for site-wide entries
    //  and get_js_config() in ottm/api/wiki/pages.py for wiki-related entries
    OTTM_CONFIG: {
      config: Dict,
      page: Dict,
      user: Dict,
      languages: {
        code: string,
        name: string,
        writingDirection: string,
        comma: string,
        and: string,
        dayNames: string[],
        abbrDayNames: string[],
        monthNames: string[],
        abbrMonthNames: string[],
        ampm: [string, string],
        decimalSep: string,
        thousandsSep: string,
      }[],
      translations: Dict<string>,
    };
  }
}

export type Dict<T = any> = {
  [key: string]: T
}

/**
 * Immutable object that maps keys to values.
 * @template T The type of this mapping’s values.
 */
export class Mapping<T = any> {
  readonly #mappings: Dict<T>;

  /**
   * Internal data is queried from the global `WIKI_CONFIG` object generated by the server.
   * The object and associated `<script>` tag are deleted once this object is initialized.
   * @param data Initial data.
   */
  constructor(data: Dict<T>) {
    this.#mappings = data;
  }

  /**
   * Return the value for the given key.
   * @param key The key.
   * @return The corresponding value or undefined if the key is absent.
   */
  get(key: string): T {
    return this.#mappings[key];
  }

  /**
   * Check whether this object contains the given key.
   * @param key The key to check.
   * @return True if the key is present, false otherwise.
   */
  containsKey(key: string): boolean {
    return this.get(key) !== undefined;
  }

  /**
   * @return An array of all keys of this object.
   */
  keys(): string[] {
    return Object.keys(this.#mappings);
  }

  /**
   * @return An array of all values of this object.
   */
  values(): T[] {
    return Object.values(this.#mappings);
  }

  /**
   * @return An array of all key-value entries of this object.
   */
  entries(): [string, T][] {
    return Object.entries(this.#mappings);
  }

  /**
   * @return An iterator over the entries of this object.
   */
  [Symbol.iterator](): Iterator<[string, T]> {
    const entries = this.entries();
    let i = -1;
    return {
      next: () => ({
        value: entries[++i],
        done: !(i in entries),
      }),
    };
  }
}

/**
 * Class representing a UI language.
 */
export class Language {
  readonly code: string;
  readonly name: string;
  readonly comma: string;
  readonly and: string;
  readonly writingDirection: string;
  readonly dayNames: string[];
  readonly abbrDayNames: string[];
  readonly monthNames: string[];
  readonly abbrMonthNames: string[];
  readonly ampm: [string, string];
  readonly decimalSep: string;
  readonly thousandsSep: string;

  constructor(
    code: string,
    name: string,
    writingDirection: string,
    comma: string,
    and: string,
    dayNames: string[],
    abbrDayNames: string[],
    monthNames: string[],
    abbrMonthNames: string[],
    ampm: [string, string],
    decimalSep: string,
    thousandsSep: string
  ) {
    if (dayNames.length !== 7) {
      throw new Error("dayNames expected 7 values");
    }
    if (abbrDayNames.length !== 7) {
      throw new Error("abbrDayNames expected 7 values");
    }
    if (monthNames.length !== 12) {
      throw new Error("monthNames expected 12 values");
    }
    if (abbrMonthNames.length !== 12) {
      throw new Error("abbrMonthNames expected 12 values");
    }
    if (ampm.length !== 2) {
      throw new Error("ampm expected 2 values");
    }
    this.code = code;
    this.name = name;
    this.writingDirection = writingDirection;
    this.comma = comma;
    this.and = and;
    this.dayNames = dayNames;
    this.abbrDayNames = abbrDayNames;
    this.monthNames = monthNames;
    this.abbrMonthNames = abbrMonthNames;
    this.ampm = ampm;
    this.decimalSep = decimalSep;
    this.thousandsSep = thousandsSep;
  }

  /**
   * Format the given number.
   * @param n A number.
   * @return The formatted number.
   */
  formatNumber(n: number): string {
    const s = n.toString();
    const decPart = s.includes(".") ? s.split(".")[1] : "";
    // Regex from https://stackoverflow.com/a/2901298/3779986
    const intPart = Math.floor(n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSep);
    return intPart + (decPart ? this.decimalSep + decPart : "");
  }

  /**
   * Turn a list of string into a simple list using commas and 'and'.
   * @param values List of values to format.
   * @return Formatted list.
   */
  listToText(values: any[]): string {
    if (values.length === 0) {
      return "";
    }
    if (values.length === 1) {
      return values[0];
    }
    let list = values.slice(0, values.length - 1).join(this.comma);
    return `${list}${this.and}${values[values.length - 1]}`;
  }
}

/**
 * The site’s global object class.
 */
export class OTTM {
  /** Site’s configuration values. */
  readonly config: Mapping;
  /** Current page’s data. */
  readonly page: Mapping;
  /** Current user’s data. */
  readonly user: Mapping;
  /** Map of all available UI languages. */
  readonly languages: Mapping<Language>;
  /** UI translations. */
  readonly translations: Mapping<string>;
  /* Expose the Mapping and Language classes to make them accessible to gadgets and other user-defined scripts. */
  readonly Mapping = Mapping;
  readonly Language = Language;

  constructor() {
    this.config = new Mapping(window.OTTM_CONFIG.config);
    this.page = new Mapping(window.OTTM_CONFIG.page);
    this.user = new Mapping(window.OTTM_CONFIG.user);
    this.translations = new Mapping(window.OTTM_CONFIG.translations);
    const langs: Dict<Language> = {};
    for (const langData of window.OTTM_CONFIG.languages) {
      langs[langData.code] = new Language(
        langData.code,
        langData.name,
        langData.writingDirection,
        langData.comma,
        langData.and,
        langData.dayNames,
        langData.abbrDayNames,
        langData.monthNames,
        langData.abbrMonthNames,
        langData.ampm,
        langData.decimalSep,
        langData.thousandsSep,
      );
    }
    this.languages = new Mapping(langs);
    delete window.OTTM_CONFIG;
    $("#ottm-config-script").remove();
  }

  /**
   * Translate the given key.
   * @param key The key.
   * @param defaultValue Optional value to return if the key is undefined. May be a function that returns a string.
   * @return The translation or the key if no translation was found and no default value was provided.
   */
  translate(key: string, defaultValue?: string | (() => string)): string {
    return this.translations.get(key) ?? ((defaultValue instanceof Function ? defaultValue() : defaultValue) ?? key);
  }

  /**
   * @return The language object of the current page.
   */
  getPageLanguage(): Language {
    return this.languages.get(this.page.get("language"));
  }

  /**
   * Convert a date to the given timezone.
   * @param date Date to convert.
   * @param timezone Target timezone.
   * @returns Converted date.
   */
  convertDateTimezone(date: Date, timezone: string): Date {
    return new Date(date.toLocaleString("en-US", {timeZone: timezone}));
  }

  /**
   * Format a date as "HH:MM".
   * @param date Date to format.
   * @returns Formatted time.
   */
  formatTime(date: Date): string {
    // Append 0s if necessary
    const hours = date.getHours().toLocaleString("en-US", {minimumIntegerDigits: 2});
    const minutes = date.getMinutes().toLocaleString("en-US", {minimumIntegerDigits: 2});
    return `${hours}:${minutes}`;
  }

  /**
   * Set referrer URL to login-related links.
   */
  setReferrer() {
    const path = window.location.pathname + window.location.hash;
    const linkSelectors = [
      "#nav-login-link",
      "#nav-logout-link",
    ];
    for (const linkSelector of linkSelectors) {
      const $link = $(linkSelector);
      if ($link.length) {
        this.#setReturnTo($link, path);
      }
    }
  }

  /**
   * Add "return_to" argument to the given link’s href attribute.
   * @param $link Link element to modify.
   * @param path Path to pass to "return_to" argument.
   * @param args Additional arguments to append to URL.
   */
  #setReturnTo($link: JQuery, path: string, args?: Dict) {
    const url = new URL($link.prop("href"));
    const params = new URLSearchParams({return_to: path});
    if (args) {
      for (const [k, v] of Object.entries(args)) {
        params.append(k, v ?? "");
      }
    }
    url.search = params.toString();
    $link.attr("href", url.href);
  }

  /**
   * Return the value of a cookie.
   * @param name Cookie’s name.
   * @param defaultValue A value to return if the cookie is undefined.
   * @returns The cookie’s value.
   */
  getCookie(name: string, defaultValue?: string): string {
    return Cookies.get(name) ?? defaultValue;
  }

  /**
   * Set the value of a cookie.
   * @param name Cookie’s name.
   * @param value Cookie’s value.
   * @param options Options.
   */
  setCookie(name: string, value: string, options: Cookies.CookieAttributes) {
    Cookies.set(name, value, options);
  }

  /**
   * Delete a cookie.
   * @param name Cookie’s name.
   * @param options Options.
   */
  deleteCookie(name: string, options: Cookies.CookieAttributes) {
    Cookies.remove(name, options);
  }
}
