import abc as _abc
import importlib as _importlib
import logging as _logging
import time as _time
import typing as _typ

import django.urls as dj_urls


class Skin(_abc.ABC):
    def __init__(self, name: str, label: str, settings):
        self.__name = name
        self.__label = label
        self._settings = settings

    @property
    def name(self) -> str:
        return self.__name

    @property
    def label(self) -> str:
        return self.__label

    def format_internal_link(self, api, current_page_title: str, page_title: str, text: str = None,
                             tooltip: str = None, anchor: str = None, no_red_link: bool = False,
                             css_classes: _typ.List[str] = None, access_key: str = None, **url_params):
        ns_id, title = api.extract_namespace_and_title(page_title, ns_as_id=True)
        page_exists = no_red_link or api.page_exists(ns_id, title)
        url = dj_urls.reverse('wikipy:page', kwargs={'raw_page_title': api.as_url_title(page_title)})
        link_text = text or page_title
        link_tooltip = tooltip or link_text

        if current_page_title == page_title and not anchor and len(url_params) == 0:
            return f'<b class="wpy-self-link">{link_text}</b>'
        elif page_exists:
            if url_params == {}:
                if anchor:
                    url += '#' + anchor
            else:
                params = [f'{p}={v}' for p, v in url_params.items() if v is not None]
                if params:
                    url += '?' + '&'.join(params)
        elif ns_id != -1:
            url += '?action=edit&redlink=1'
            paren = self._settings.i18n.trans('link.redlink.tooltip')
            link_tooltip += f' ({paren})'

        return self._format_link(api, url, link_text, link_tooltip, page_exists, css_classes or [], access_key)

    @_abc.abstractmethod
    def _format_link(self, api, url: str, text: str, tooltip: str, page_exists: bool, css_classes: _typ.List[str],
                     access_key: str = None):
        pass

    def render_wikicode(self, api, parsed_wikicode, disable_comment: bool = False) -> str:
        """
        Renders the given parsed wikicode.
        :param api: The "WikiPy_app.api" module.
        :param parsed_wikicode: The parsed wikicode to render.
        :type parsed_wikicode: django_wiki.api.ParsedWikicode
        :param disable_comment: If true, the generation comment will not be appended to the rendered HTML.
        :return: The parsed wikicode.
        """
        start = _time.time()
        render = self._render_wikicode_impl(api, parsed_wikicode)
        total = (_time.time() - start) * 1000
        if not disable_comment:
            comment = f"""
<!--
Page generated by WikiPy in {total:0.4}\u00a0ms.
Skin: {self.label}
-->"""
        else:
            comment = ''

        return render + comment

    @_abc.abstractmethod
    def _render_wikicode_impl(self, api, parsed_wikicode) -> str:
        """
        Renders the given parsed wikicode.

        :param parsed_wikicode: The parsed wikicode to render.
        :type parsed_wikicode: django_wiki.api.ParsedWikicode
        :return: The parsed wikicode.
        """
        pass


_LOADED_SKINS = {}


def load_skin(name: str, settings):
    try:
        module = _importlib.import_module('._' + name, package=__name__)
        # noinspection PyUnresolvedReferences
        skin = module.load_skin(settings)
        _LOADED_SKINS[skin.name] = skin
    except ModuleNotFoundError:
        _logging.warning(f'unknown skin name "{name}", ignored')


def get_skin(name: str) -> Skin:
    if name in _LOADED_SKINS:
        return _LOADED_SKINS[name]
    return _LOADED_SKINS['default']


def get_loaded_skins_names() -> _typ.List[str]:
    return sorted(_LOADED_SKINS.keys())
